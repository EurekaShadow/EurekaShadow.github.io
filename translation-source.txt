===FILE_INFO:docs\embedded\STM32\STM32F103C8T6.mdx===
---FRONTMATTER---
sidebar_label: 'STM32F103C8T6'
sidebar_position: 1.0
description: 这里有STM32F103C8T6相关的内容！
---END FRONTMATTER---

---CONTENT---
以下内容正在施工中。。。🥱
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\example.mdx===
---FRONTMATTER---
date: 2025年07月06日 星期日 21:47:57
last_updated: 2025年07月06日 星期日 21:47:57
---END FRONTMATTER---

---CONTENT---
## 🕒 最近更新

---
- [2025年8月27日 - 国际化](/blog/i18n)
- [2025年8月27日 - Testpage2](/docs/mydoc/testpage2)
- [2025年8月27日 - 为 Docusaurus 添加 Algolia 搜索功能](/blog/Algolia)
- [2025年8月26日 - 最小覆盖子串](/blog/LeetCode76)
---

<!-- 其他内容 -->


### 这个一个测试
This is a test

哈哈哈哈


12356
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\Issues.mdx===
---FRONTMATTER---
slug: /Issues
title: 遇到的问题
sidebar_position: 3
description: 这个页面主要记录在部署文件站中遇到的问题以及解决方法。
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## <B2>部署延迟</B2>

这是本地经过 `yarn deploy` 后显示的情况，可见 `Done in ...`。但是真的部署成功了吗？

<p><CardImg src="/img/Issues/Deploy_Fake_Done.jpg" alt="实际尚未部署成功" isCenter={true} isBoxed={true} /></p>

之后点击 `https://eurekashadow.github.io/` 或者域名 `https://www.eurekashadow.xin/`,会出现下面这个页面：

<p><CardImg src="/img/Issues/After_Dploy.jpg" alt="There isn't a Git Pages site here." isCenter={true} isBoxed={true} /></p>

这是可能是因为：GitHub Actions 使用的免费 CI/CD 资源（Runner）是共享的，在全球用户<Highlight> 高峰期 </Highlight>时出现了<Highlight> 排队现象 </Highlight>。
打开`Github` 中的 `Actions` 可以看到正在排队状态，所以慢慢等吧。过一段时间，就会部署成功了：
<p><CardImg src="/img/Issues/Real_Deploy_Done.jpg" alt="实际尚未部署成功" isCenter={true} isBoxed={true} /></p>

经过后续使用发现，**修复CNAME问题后**，再也没有出现这种所谓的部署延时的问题，也许根本不是什么<Highlight> 高峰期 </Highlight>导致的，罪魁祸首可能是原来**错误的
CNAME.txt**！

---

## <B2>关于CNAME</B2>

我看这篇[文章](https://xxx.zhangyuqi.top/docs/MyWebsite/StudyBuildWebsite#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D)的时候，ta说要在static目录下创建一个
CNAME.txt的空白文件。

现在我遇到的问题是，每次本地显示部署完成后Github端总是 **自定义域名丢失** 像这样：（之前我已经填过域名了）
<p><CardImg src="/img/Issues/domain_issue1.jpg" alt="域名被吞" isCenter={true} isBoxed={true} /></p>

<details>
<summary>问题分析</summary>

重新填写域名：
<p><CardImg src="/img/Issues/domain_issue2.jpg" alt="重新填写域名" isCenter={true} isBoxed={true} /></p>

填写域名后会再次触发Github Actions：
<p><CardImg src="/img/Issues/deploy_done_in26s.jpg" alt="真正部署成功" isCenter={true} isBoxed={true} /></p>

这时候我打开Github仓库，查看 `git-pages` 分支，发现它又构建了一个 `CNAME` 文件（如下图，无文件格式），里面的内容是我的域名 `www.eurekashadow.xin` 
我推测是在Github上重新添加 `Custom domain` 时自动构建了这个CNAME文件。那么之前提到的 `CNAME.txt` 是不是多余的呢？或者说实际上应该构建的是 `CNAME` 然后在里面加上域名 `www.eurekashadow.xin` 呢？
<p><CardImg src="/img/Issues/About_CNAME1.jpg" alt="CNAME是多余的？" isCenter={true} isBoxed={true} /></p>

`CANME` 文件中内容：
<p><CardImg src="/img/Issues/About_CNAME2.jpg" alt="CNAME是多余的？" isCenter={true} isBoxed={true} /></p>

</details>

### <B3>CNAME问题结论</B3>

经测试发现，`CNAME.txt` 确实是 **多余的** ！正确的做法：

<details>
<summary>创建**无文件格式的**CNAME</summary>

<p><CardImg src="/img/Issues/Creat_CNAME1.jpg" alt="步骤1" isCenter={true} isBoxed={true} /></p>
<p><CardImg src="/img/Issues/Creat_CNAME2.jpg" alt="步骤2" isCenter={true} isBoxed={true} /></p>
<p><CardImg src="/img/Issues/Creat_CNAME3.jpg" alt="步骤3" isCenter={true} isBoxed={true} /></p>

</details>

在新建的 `CNAME` 里面加入自己的域名：
<p><CardImg src="/img/Issues/Modified_CNAME.jpg" alt="加入域名" isCenter={true} isBoxed={true} /></p>

之后就可以正常部署了：



``` bash
yarn deploy
```


Github上的域名不会丢失：
<p><CardImg src="/img/Issues/CNAME_Issue_Fixed.jpg" alt="CNAME问题已解决" isCenter={true} isBoxed={true} /></p>

---

## <B2>高亮与行号冲突（未解决）</B2>

这是我的 docusaurus.config.js 配置：

```js title="docusaurus.config.js"
prism: {
  // 代码高亮主题 - 浅色主题使用 GitHub 风格
  theme: prismThemes.github,
  // 代码高亮主题 - 深色主题使用 Dracula 风格
  darkTheme: prismThemes.dracula,
  
  // 自定义代码高亮标记配置
  magicComments: [
	// 高亮标记 - 用于突出显示重要代码行
	{
	  className: 'code-block-highlighted-line',  // CSS 类名
	  line: 'highlight-next-line',               // 行内标记
	  block: { start: 'highlight-start', end: 'highlight-end' }  // 块标记
	},
	// 新增代码标记 - 用于标识新增的代码行
	{
	  className: 'code-block-add-line',
	  line: 'highlight-add-line',
	  block: { start: 'highlight-add-start', end: 'highlight-add-end' }
	},
	// 更新代码标记 - 用于标识修改的代码行
	{
	  className: 'code-block-update-line',
	  line: 'highlight-update-line',
	  block: { start: 'highlight-update-start', end: 'highlight-update-end' }
	},
	// 错误代码标记 - 用于标识有问题的代码行
	{
	  className: 'code-block-error-line',
	  line: 'highlight-error-line',
	  block: { start: 'highlight-error-start', end: 'highlight-error-end' }
	},
  ],
  
  // 额外支持的语言（超出默认支持的语言列表）
  // 默认支持的语言列表参考：https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/generate-prism-languages/index.ts#L9-L23
  // Prism.js 完整支持语言列表：https://prismjs.com/#supported-languages
  additionalLanguages: [
	'java',   // Java 编程语言
	'json',   // JSON 数据格式
	'c',
  ],
},
```

这是关于 custom.css 配置：
```css title="custom.css"
/* 代码高亮行的样式 */
.code-block-highlighted-line {
  background-color: rgba(255, 255, 0, 0.2); /* 黄色高亮 */
  display: block;
  margin: 0; /* 避免布局问题 */
  padding: 0 1em; /* 使用 em 单位更灵活 */
}

.code-block-add-line {
  background-color: rgba(0, 255, 0, 0.2); /* 绿色新增 */
  display: block;
  margin: 0;
  padding: 0 1em;
}

.code-block-update-line {
  background-color: rgba(0, 0, 255, 0.2); /* 蓝色更新 */
  display: block;
  margin: 0;
  padding: 0 1em;
}

.code-block-error-line {
  background-color: rgba(255, 0, 0, 0.2); /* 红色错误 */
  display: block;
  margin: 0;
  padding: 0 1em;
}

/* 深色主题下的样式 */
html[data-theme='dark'] .code-block-highlighted-line {
  background-color: rgba(255, 255, 0, 0.2);
}

html[data-theme='dark'] .code-block-add-line {
  background-color: rgba(0, 255, 0, 0.2);
}

html[data-theme='dark'] .code-block-update-line {
  background-color: rgba(0, 0, 255, 0.2);
}

html[data-theme='dark'] .code-block-error-line {
  background-color: rgba(255, 0, 0, 0.2);
}
```

这是高亮和行号同时使用的方法：
```
\```c showLineNumbers
#include <stdio.h>

int main() {
    //高亮下一行( highlight-next-line)
    printf("Hello, World!\n");
    
    //高亮开始( highlight-start)
    int x = 10;
    int y = 20;
    int sum = x + y;
    //高亮结束( highlight-end)
    
    return 0;
}
\```
```
这是显示冲突的情况：
<p><CardImg src="/img/Issues/HighlightConflict.jpg" alt="CNAME问题已解决" isCenter={true} isBoxed={true} /></p>

高亮、行号可以**单独使用**，但两者**同时使用**就会造成**冲突**，[别人](https://imroc.cc/note/docusaurus/codeblock#%E9%AB%98%E4%BA%AE%E5%A4%9A%E8%A1%8C/)都可以正常使用，为什么我就不行了？暂时未排查出原因！

暂时的妥协方法就是两者**分开使用**了。（20250919）

---

## <B2>📦 node_modules 体积过大导致卡顿问题</B2>

### 🎯 问题现象

在本地开发环境中观察到明显的性能问题：

- 当 `node_modules` 文件夹体积过大时（如达到 17GB），本地运行的网站出现严重卡顿
- 页面间跳转缓慢，通常需要 3 秒以上才能完成导航
- 开发服务器编译时间显著增加
- 整体开发体验下降，影响工作效率

### 🔧 问题解决

通过清理 `node_modules` 文件夹解决此问题：

```bash title="bash"
npm install rimraf -g                           # 安装 rimraf 工具
rimraf node_modules                             # 删除 node_modules
npm cache clean --force                         # 清除缓存
# npm config set registry https://registry.npmmirror.com/  # 使用新淘宝镜像（可选）
npm install                                     # 重新安装依赖		
```		

### ✨ 清理后的效果

- `node_modules` 体积从 17GB 减少到约 200MB
- 项目编译速度显著提升
- 页面跳转几乎瞬间完成
- 本地开发环境运行流畅

### 💡 为什么清理是安全的

1. **依赖声明机制**
   - 所有项目实际使用的依赖都明确记录在 `package.json` 文件中
   - `node_modules` 只是这些声明依赖的"实例化"结果
   - 重新安装时会根据 `package.json` 恢复所有必需依赖

2. **npm/yarn 的设计原则**
   - 包管理器会确保 `package.json` 中声明的所有依赖都被正确安装
   - 不会在重新安装时遗漏任何明确声明的依赖

### 📝 问题结论

`node_modules` 体积过大会显著影响本地开发环境性能，定期清理是保持开发环境高效运行的有效方法。此问题在大型项目中尤为明显，应作为常规维护工作来执行。

### ⚠️ 重要补充（后续观察）

经过进一步实践发现，开发环境卡顿可能有多个原因：

1. `node_modules` 体积问题（本小节主要讨论）
2. Docusaurus 构建缓存问题（可能**更重要**）

如果仅清理 `node_modules` 效果不明显，建议尝试清理 Docusaurus 构建缓存。

### 🚀 真正有效的解决方案

<Tabs>
  <TabItem value="yarn" label="yarn">
    ```bash
    yarn clear
    ```
  </TabItem>
  
  <TabItem value="npx" label="npx">
    ```bash
    npx docusaurus clear
    ```
  </TabItem>  
</Tabs>

这表明开发环境卡顿主要由 Docusaurus 构建缓存和开发服务器状态引起，而非 node_modules 体积问题。不过，定期清理不必要的依赖仍然很有必要，可以有效减少磁盘空间浪费。

---

## <B2>build文件夹过大问题</B2>

这个问题排了好久好久，终于得以解决，吾心甚慰！~🥱

## 问题描述
build文件夹，或者更准确的说是其中的有6个js文件巨大，每个都有接近20mb左右，最终导致build文件夹总体达128mb。问了一下AI它说这是一种非常异常的情况，大型文件站的build文件夹都不一定能达到这个量级。

## 解决过程
于是我想方设法给build"瘦身"。一开始发现`ForMDX.js`文件中导入了没有用到的大型库，当时我几乎以为问题就要解决了，但是点击build属性一看还是128mb，给了我当头一击，我当时都要碎了。

现在已经半夜2点了，唉，今天的凡人还没看呢，老魔心魔不知道怎么呈现的。然后在AI的辅助下，一步步排查仍然没发现问题所在，后来灵机一动，把没用到的 `src/components/FileBlock.tsx`与`src/theme/MDXComponents.tsx`这两个文件删去，问题解决！build成功"瘦身"，变为13mb左右。

## 当前状态
现在是既没有喜悦也没用懊恼，只是无感，人麻了。关于此问题的进一步记录明天再来弄吧，睡觉先。

<details>
<summary>AI的问题总结</summary>

## 问题背景
- **现象**：build 文件夹达到 128MB 的异常大小
- **解决后**：删除两个未完成的文件后，build 文件夹降至 13MB 正常大小
- **问题根源**：
  - 保留`src/components/FileBlock.tsx`
  - 保留`src/theme/MDXComponents.tsx`
  - 但未完成 `docusaurus.config.js` 中 `plugins` 配置

## 问题成因分析

### 根本原因
1. **循环依赖和错误导入**
   - FileBlock 组件中使用了 `require('!!raw-loader!@site/' + filepath)`
   - 动态导入让 webpack 尝试处理项目中所有文件

2. **MDX 组件循环引用**
   - MDXComponents.tsx 重新导出了 CodeBlock 组件
   - 造成了组件映射的混乱

3. **构建工具混乱**
   - webpack 无法正确解析依赖关系
   - 大量不必要的文件被打包
   - 生成错误的代码分割 chunks

## 问题解决过程

### 完整问题链
```
未完成的 FileBlock 组件 → 动态 raw-loader 导入 → webpack 尝试处理所有文件 → 
大量重复打包 → 错误的代码分割 → 生成巨型 JS 文件 → 128MB 构建文件
```


### 解决方法
删除两个干扰文件后，webpack 恢复正常工作：
1. 消除动态导入源
2. 恢复正常组件映射
3. 清除构建工具困惑

## 经验教训

### 开发实践要点
1. **未完成功能的潜在危害**
   - 即使未启用，残留代码也可能严重影响项目
   - 及时清理未使用的代码文件

2. **动态导入风险**
   - `require('!!raw-loader!@site/' + filepath)` 类动态路径需谨慎使用
   - 会触发构建工具处理所有可能文件

3. **组件覆盖注意事项**
   - 覆盖 Docusaurus 默认组件时要确保不破坏原有依赖关系

### 预防措施
- 及时清理未使用的代码文件
- 实验新功能时使用单独分支
- 定期检查自定义组件的依赖引入
- 注意主题组件的正确覆盖方式

## 后续建议

如需重新实现代码文件导入功能：
1. 完成完整的插件配置，特别是 `exclude` 规则
2. 限制文件访问范围，使用白名单机制
3. 避免完全动态路径，使用更具体的路径模式

## 结论
**13MB 的构建大小是正常的**，说明问题已彻底解决。此案例说明在前端开发中，问题根源可能来自看似无关的残留文件，需要格外注意未完成功能的清理工作。

</details>

## CardImg 组件点击图片卡死问题

原来关于图片组件的代码是放在，`ForMDX.js` 中的，后来迁出为 `CardImg.js`。

在 `CardImg.js` 中应该引入： 
```
import { PhotoProvider, PhotoView } from 'react-photo-view';
import Lazyimg from 'react-lazyimg-component';
import 'react-photo-view/dist/react-photo-view.css';
```

实际上缺了：
```
import 'react-photo-view/dist/react-photo-view.css';
```

由于 `ForMDX.js` 中仍然保留那三条引入，故 `CardImg.js` 与 `ForMDX.js` 具有`隐式依赖`，此时图片组件正常工作。

但是由于后续在排查 `build` 文件夹过大问题的时候，发现 `ForMDX.js` 那三条引入是**多余的**，删去。此时**隐式依赖断裂**，图片组件无法工作。
这种问题往往是很棘手的，虽然在本次问题中，再不济我也可以通过重构图片组件复现功能。但是如果在某种情况下这种重构变得尤为困难，甚至说简直不可能的时候，
想要排查这种 `隐式依赖` 就会变得 **极为困难！** 这次只是侥幸，记得图片组件似乎是要三个引入的，所以顺利将问题解决。日后应谨记此教训，在开发中，要尽量避免类似的错误。🥱

---

## Vercel Preview 部署错误问题解决

### 问题描述
当使用 `yarn deploy` 部署到 GitHub Pages 的 `gh-pages` 分支时，Vercel 会自动检测到分支变化并尝试创建 Preview 部署，但由于 `gh-pages` 分支只包含静态文件而没有 `package.json`，导致构建失败，GitHub Deployments 中显示 ❌preview 错误。

### 问题原因
- Vercel 默认会为所有分支推送创建 Preview 部署
- `gh-pages` 分支是构建后的静态文件，缺少源代码和构建配置
- Vercel 尝试运行 `npm run build` 失败

### 解决方案

**配置生产环境构建：**
1. 进入 Vercel 项目 Settings → Git
2. 在 Behavior 选项中选择 **"Only build production"**
3. 确保生产分支设置为 `main`（或主分支）
4. 保存设置
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\Links.mdx===
---FRONTMATTER---
slug: /Links
title: 常用链接
sidebar_position: 2
description: 这个页面主要放置一些常用、实用的链接。
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


## <B2>[squoosh](https://squoosh.app/ "图片压缩")</B2>

## <B2>[Favicon.io](https://favicon.io/favicon-converter/ "图片生成ICON")</B2>

## <B2>[Docusaurus文档](https://www.docusaurus.io/zh-CN/docs/ "Docusaurus")</B2>

## <B2>[LeetCode](https://leetcode.cn/ "力扣")</B2>

## <B2>[问小白](https://www.wenxiaobai.com/ "DeepSeek平替")</B2>

## <B2>[test-site-Vercel(本网站)](https://www.eurekashadow.xin/ "Vercel上部署的网站")</B2>

## <B2>[test-site-gitpages](https://eurekashadow.github.io/ "gitpages上部署的网站")</B2>

## <B2>[my-site-Vercel](https://eurekax.space/ "Vercel上部署的网站")</B2>

## <B2>[my-site-gitpages](https://eureka12138github.github.io/ "gitpages上部署的网站")</B2>

## <B2>[Vercel](https://vercel.com/ "Vercel")</B2>

## <B2>[Algolia](https://www.algolia.com/ "Algolia")</B2>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\mydoc\testpage0.mdx===
---FRONTMATTER---
sidebar_label: '测试页0'
sidebar_position: 1
description: 测试页0，包含常用组件与跳转示例。
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W,Button, MyColor, Card} from '@site/src/components/ForMDX';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CardImg from '@site/src/components/CardImg';


## 本文档全部import：
```
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W,Button, MyColor, Card} from '@site/src/components/ForMDX';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

## 🔗 按钮链接


<div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem' }}>
  <a href="https://www.bilibili.com/video/BV12v4y1y7uV" class="source_card_button" target="_blank">📖 STM32 教程</a>
  <a href="/docs/reflection-space" class="source_card_button" target="_blank">🌸 回想空间</a>
  <a href="https://e.tb.cn/h.hTZaa83WZiz2Wfr" class="source_card_button" target="_blank">🌽 还不错的玉米</a>
  <a href="https://qun.qq.com/universal-share/share?ac=1&authKey=BvgzFVJKMU0dbLEz%2BkWm8tydUKa%2F%2BTpBiaW9Ner6BemqNZfLQyN3xGlo%2BjLzhTL5&busi_data=eyJncm91cENvZGUiOiI5MzgyMTk4NjMiLCJ0b2tlbiI6IkUzNFhjVzJuUE9FY3IxSm14SmFza2J1RWhTcHJWMElMTkxITkNHcjBwcXhmMVN5Y21JUVljZ25ieldaRUFCUjEiLCJ1aW4iOiIyNTYwMjkxMjQxIn0%3D&data=lHupxGd_sZuAjGp9DpXZH7KnauiAdCCqC_JIFVTwLE5-rOMCTKgggw9oo9XpURlTsaCKXlUUDCeolPJ87PqKZA&svctype=4&tempid=h5_group_info" class="source_card_button" target="_blank">📱 测试群链接</a>
</div>

<div style={{ marginBottom: '20px' }}></div>
**代码：**（无需`import`）
```js
<div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem' }}>
  <a href="https://www.bilibili.com/video/BV12v4y1y7uV" class="source_card_button" target="_blank">📖 STM32 教程</a>
  <a href="/docs/reflection-space" class="source_card_button" target="_blank">🌸 回想空间</a>
  <a href="https://e.tb.cn/h.hTZaa83WZiz2Wfr" class="source_card_button" target="_blank">🌽 还不错的玉米</a>
  <a href="https://qun.qq.com/universal-share/share?ac=1&authKey=BvgzFVJKMU0dbLEz%2BkWm8tydUKa%2F%2BTpBiaW9Ner6BemqNZfLQyN3xGlo%2BjLzhTL5&busi_data=eyJncm91cENvZGUiOiI5MzgyMTk4NjMiLCJ0b2tlbiI6IkUzNFhjVzJuUE9FY3IxSm14SmFza2J1RWhTcHJWMElMTkxITkNHcjBwcXhmMVN5Y21JUVljZ25ieldaRUFCUjEiLCJ1aW4iOiIyNTYwMjkxMjQxIn0%3D&data=lHupxGd_sZuAjGp9DpXZH7KnauiAdCCqC_JIFVTwLE5-rOMCTKgggw9oo9XpURlTsaCKXlUUDCeolPJ87PqKZA&svctype=4&tempid=h5_group_info" class="source_card_button" target="_blank">📱 测试群链接</a>
</div>
```


---

## 按钮下载（外链）
<a href="https://pan.baud-dance.com/d/STM32CubeIDE/st-stm32cubeide_1.18.0_24413_20250227_1633_x86_64.exe" class="source_download_button" target="_blank">立即下载</a>

**代码：**（无需`import`）

```js
<a href="https://pan.baud-dance.com/d/STM32CubeIDE/st-stm32cubeide_1.18.0_24413_20250227_1633_x86_64.exe" class="source_download_button" target="_blank">立即下载</a>
```

---

## 自定义按钮
<div style={{
  display: 'flex',
  flexDirection: 'column',
  rowGap: '1rem'
}}>
  {/* 第一行按钮 */}
  <div style={{ display: 'flex', gap: '1rem' }}>
    <Button icon="📘" href="https://example.com">默认按钮</Button>
    <Button icon="📘" href="https://example.com" color="#2D8E0A">绿色按钮</Button>
	<Button icon="📘" href="https://example.com" color="#1877F2" size="large">蓝色大按钮</Button>
  </div>

  {/* 第二行按钮 */}
  <div style={{ display: 'flex', gap: '1rem' }}>
    <Button icon="📘" href="https://example.com">默认按钮</Button>
    <Button icon="📘" href="#">按钮1</Button>
	<Button icon="📘" href="https://github.com/your-repo" color="#333"textColor="white" size="medium">GitHub 仓库</Button>
  </div>

  {/* 第三行按钮 */}
  <div style={{ display: 'flex', gap: '1rem' }}>
	<Button icon="⚙️" onClick={() => alert('点击了')}>打开设置</Button>
	<Button loading>加载中...</Button>
	<Button disabled>不可点击</Button>
  </div> 
  
</div>

<div style={{height: '20px'}}></div>

**代码：**(需 ` import {Button} from '@site/src/components/ForMDX'; `)
```js
<div style={{
  display: 'flex',
  flexDirection: 'column',
  rowGap: '1rem'
}}>
  {/* 第一行按钮 */}
  <div style={{ display: 'flex', gap: '1rem' }}>
    <Button icon="📘" href="https://example.com">默认按钮</Button>
    <Button icon="📘" href="https://example.com" color="#2D8E0A">绿色按钮</Button>
	<Button icon="📘" href="https://example.com" color="#1877F2" size="large">蓝色大按钮</Button>
  </div>

  {/* 第二行按钮 */}
  <div style={{ display: 'flex', gap: '1rem' }}>
    <Button icon="📘" href="https://example.com">默认按钮</Button>
    <Button icon="📘" href="#">按钮1</Button>
	<Button icon="📘" href="https://github.com/your-repo" color="#333"textColor="white" size="medium">GitHub 仓库</Button>
  </div>

  {/* 第三行按钮 */}
  <div style={{ display: 'flex', gap: '1rem' }}>
	<Button icon="⚙️" onClick={() => alert('点击了')}>打开设置</Button>
	<Button loading>加载中...</Button>
	<Button disabled>不可点击</Button>
  </div> 
  
</div>
```
---

## 高亮/关键词
<p><Highlight bgColor={MyColor.docusaurusGreen} fontColor={MyColor.white}>Docusaurus green</Highlight>and<Highlight bgColor={MyColor.Pink} fontColor={MyColor.white}>Pink</Highlight>are my favorite colors.</p>
<Highlight>这是一个高亮段落</Highlight>
<Highlight bgColor={MyColor.Blue} fontColor={MyColor.black}>这是一个高亮段落</Highlight> 
<p>这是一个<Keyword>关键词</Keyword>哈哈哈哈</p>哈哈哈

**代码：**（需 `import {Highlight,Keyword} from '@site/src/components/ForMDX';` ）
```js
<p><Highlight bgColor={MyColor.docusaurusGreen} fontColor={MyColor.white}>Docusaurus green</Highlight>and<Highlight bgColor={MyColor.Pink} fontColor={MyColor.white}>Pink</Highlight>are my favorite colors.</p>
<Highlight>这是一个高亮段落</Highlight>
<Highlight bgColor={MyColor.Blue} fontColor={MyColor.black}>这是一个高亮段落</Highlight> 
<p>这是一个<Keyword>关键词</Keyword>哈哈哈哈</p>哈哈哈
```

---

## 🔁卡片链接

以下是一些页面跳转的卡片式按钮示例，可用于快速导航测试或构建索引页。

<div style={{ display: 'grid', gap: '1rem' }}>
    <Card>
      <a href="/docs/mydoc/testpage5" target="_blank"><strong>1️⃣ 跳转至：</strong>测试页5🔗</a>
    </Card>
	
    <Card>
      <a href="/docs/mydoc/testpage1" target="_blank"><strong>5️⃣ 跳转至：</strong>测试页1🔗</a>
    </Card>
</div>

<div style={{height: '20px'}}></div>

**代码：**（无需 `import` ）
```js
<div style={{ display: 'grid', gap: '1rem' }}>
    <Card>
      <a href="/docs/mydoc/testpage5" target="_blank"><strong>1️⃣ 跳转至：</strong>测试页5🔗</a>
    </Card>
	
    <Card>
      <a href="/docs/mydoc/testpage1" target="_blank"><strong>5️⃣ 跳转至：</strong>测试页1🔗</a>
    </Card>
</div>
```

---

## 显示代码行号

```c showLineNumbers
int main(){
    Timer_Init();
    OLED_Init();
    while(1){
        Task();
    }
}
```
**代码：**
```c 
\```c showLineNumbers
int main(){
    Timer_Init();
    OLED_Init();
    while(1){
        Task();
    }
}
\```
```
---

## 显示代码文件名

```c title="main.c"
int main(){
    Timer_Init();
    OLED_Init();
    while(1){
        Task();
    }
}
```
**代码：**
```c 
\```c title="main.c"
int main(){
    Timer_Init();
    OLED_Init();
    while(1){
        Task();
    }
}
\```
```
---

## 高亮代码行
```c
#include <stdio.h>

int main() {
    // highlight-next-line
    printf("Hello, World!\n");
    
    // highlight-start
    int x = 10;
    int y = 20;
    int sum = x + y;
    // highlight-end
    
    return 0;
}
```
**代码：**
```c 
\```c
#include <stdio.h>

int main() {
    \// highlight-next-line
    printf("Hello, World!\n");
    
    \// highlight-start
    int x = 10;
    int y = 20;
    int sum = x + y;
    \// highlight-end
    
    return 0;
}
\```
```

## 新增代码标记
```c
#include <stdio.h>

int main() {
    // highlight-add-line
    printf("Hello, World!\n");
    
    // highlight-add-start
    int x = 10;
    int y = 20;
    int sum = x + y;
    // highlight-add-end
    
    return 0;
}
```
**代码：**
```c
\```c
#include <stdio.h>

int main() {
    \// highlight-add-line
    printf("Hello, World!\n");
    
    \// highlight-add-start
    int x = 10;
    int y = 20;
    int sum = x + y;
    \// highlight-add-end
    
    return 0;
}
\```
```

## 更新代码标记
```c
#include <stdio.h>

int main() {
    // highlight-update-line
    printf("Hello, World!\n");
    
    // highlight-update-start
    int x = 10;
    int y = 20;
    int sum = x + y;
    // highlight-update-end
    
    return 0;
}
```
**代码：**
```c
\```c
#include <stdio.h>

int main() {
    \// highlight-update-line
    printf("Hello, World!\n");
    
    \// highlight-update-start
    int x = 10;
    int y = 20;
    int sum = x + y;
    \// highlight-update-end
    
    return 0;
}
\```
```

## 错误代码标记
```c
#include <stdio.h>

int main() {
    // highlight-error-line
    printf("Hello, World!\n");
    
    // highlight-error-start
    int x = 10;
    int y = 20;
    int sum = x + y;
    // highlight-error-end
    
    return 0;
}
```
**代码：**
```c
\```c
#include <stdio.h>

int main() {
    \// highlight-error-line
    printf("Hello, World!\n");
    
    \// highlight-error-start
    int x = 10;
    int y = 20;
    int sum = x + y;
    \// highlight-error-end
    
    return 0;
}
\```
```


## 多语言

<Tabs>

  <TabItem value="js" label="JavaScript">
```js
function helloWorld() {
	console.log('Hello, world!');
}
```
  </TabItem>

  <TabItem value="py" label="Python">
```py
def hello_world():
	print("Hello, world!")
```
  </TabItem>

  <TabItem value="java" label="Java">
```java
class HelloWorld {
  public static void main(String args[]) {
  System.out.println("Hello, World");
 }
}
```
  </TabItem>
  
  <TabItem value="c" label="C">
```c
int main() {
	printf("Hello, World!\n");   
	return 0;
}
```
  </TabItem>  
  
</Tabs>

**代码：**（需 `import Tabs from '@theme/Tabs';` `import TabItem from '@theme/TabItem';`）

```
<Tabs>

  <TabItem value="js" label="JavaScript">
\```js
function helloWorld() {
	console.log('Hello, world!');
}
\```
  </TabItem>

  <TabItem value="py" label="Python">
\```py
def hello_world():
	print("Hello, world!")
\```
  </TabItem>

  <TabItem value="java" label="Java">
\```java
class HelloWorld {
  public static void main(String args[]) {
  System.out.println("Hello, World");
 }
}
\```
  </TabItem>
  
  <TabItem value="c" label="C">
\```c
int main() {
	printf("Hello, World!\n");   
	return 0;
}
\```
  </TabItem>  
  
</Tabs>
```

<details>
<summary>补充说明</summary>

在上面的多语言中，`value` 是**唯一**且可自定义的，但最好和后面的 `label`对应。不可出现下面这种情况：
```
<Tabs>

<TabItem value="bash" label="有密钥">

\```bash
ffmpeg -allowed_extensions ALL -i "index.m3u8" -c copy -bsf:a aac_adtstoasc -hls_key_info_file "index/0.key" "output.mp4"
\```

</TabItem>  
  
<TabItem value="bash" label="无密钥">

\```bash
ffmpeg -i "index.m3u8" -c copy -bsf:a aac_adtstoasc "output.mp4"
\```

</TabItem>   
  
</Tabs>
```

会报错：

> Docusaurus error: Duplicate values "bash" found in `<Tabs>`. Every value needs to be unique.


少量演示代码可以直接使用上面的多语言模块，但难以维护。使用这个方法[基于 CodeBlock 实现 FileBlock](https://imroc.cc/note/docusaurus/fileblock#%E5%9F%BA%E4%BA%8E-codeblock-%E5%AE%9E%E7%8E%B0-fileblock)
可以解决这个问题，但我还没实现，因为需要用到插件，暂时就先到这儿吧，日后如有需要再研究。
</details>

---

## 折叠详情组件

<details>
<summary>Test</summary>

example:
```c
int main(){
    while(1){
        
    }
}
```

</details>

**代码：**
```
<details>
<summary>Test</summary>

example:
\```c
int main(){
    while(1){
        
    }
}
\```

</details>
```
---

## 插入音频

<audio controls>
  <source src="/audio/王铮亮-不凡.mp3" type="audio/mpeg" />
  您的浏览器不支持音频播放，请升级或使用其他浏览器。
</audio>

**代码：**
```
<audio controls>
  <source src="/audio/王铮亮-不凡.mp3" type="audio/mpeg" />
  您的浏览器不支持音频播放，请升级或使用其他浏览器。
</audio>
```
---

## 插入视频外链

<iframe 
  width="100%" 
  height="500" 
  src="https://www.bilibili.com/bangumi/play/ep733316" 
  frameborder="0" 
  allowfullscreen>
</iframe>

<div style={{height: '20px'}}></div>

**代码：**
```
<iframe 
  width="100%" 
  height="500" 
  src="https://www.bilibili.com/bangumi/play/ep733316" 
  frameborder="0" 
  allowfullscreen>
</iframe>
```
---

## 小贴士

:::tip[My Tip]

绿色小贴士，用于推荐用法、技巧等场景

:::

:::danger[Take care]

红色危险，用于指示高风险操作、错误操作等场景

:::

:::info[My Info]

蓝色信息提示，用于补充说明、背景知识等场景

:::

:::note[My note]

浅灰备注，需要特别注意的内容

:::

:::warning[My warning]

黄色，指示可能有风险的操作

:::

### 绿色
```
:::tip[My Tip]

绿色小贴士，用于推荐用法、技巧等场景

:::
```
### 红色
```
:::danger[Take care]

红色危险，用于指示高风险操作、错误操作等场景

:::
```
### 蓝色
```
:::info[My Info]

蓝色信息提示，用于补充说明、背景知识等场景

:::
```
### 灰色
```
:::note[My note]

浅灰备注，需要特别注意的内容

:::
```
### 黄色
```
:::warning[My warning]

黄色，指示可能有风险的操作

:::
```
---

## 同目录跳转

[testpage2](./testpage2.md)
```
[testpage2](./testpage2.md)
```

## 不同目录跳转

[回想空间](/docs/reflection-space)
```
[回想空间](/docs/reflection-space)
```

---

## 插入图片

### markdown

![](./img/Eureka.png "This is Sherry")

```
![](./img/Eureka.png "This is Sherry")
```

### jsx

<img
  src="/img/Eureka.jpg"
  alt="示例图片"
  style={{
    width: '100%',
    maxWidth: '300px',
    height: 'auto',
    display: 'block',
    margin: '0 auto'
  }}
/>

```
使用jsx：

<img
  // highlight-next-line
  src="/img/Eureka.jpg"
  alt="示例图片"
  style={{
    width: '100%',
    maxWidth: '300px',
    height: 'auto',
    display: 'block',
    margin: '0 auto'
  }}
/>
```

### 组件（无卡片装饰）

<p><CardImg src="/img/example.jpg" alt="示例图1" isCenter={true} /></p>

**代码：**（需`import CardImg from '@site/src/components/CardImg';`）
```
<p><CardImg src="/img/example.jpg" alt="示例图1" isCenter={true} /></p>
```

### 组件（卡片装饰）

<p><CardImg src="/img/example.jpg" alt="示例图2" isCenter={true} isBoxed={true} /></p>

**代码：**（需`import CardImg from '@site/src/components/CardImg';`）
```
<p><CardImg src="/img/example.jpg" alt="示例图2" isCenter={true} isBoxed={true} /></p>
```

---

## 自定义标题

# <B1>一级标题</B1>
## <B2>二级标题</B2>
### <B3>无序三级标题</B3>
### <BH3>1.</BH3>有序三级标题
### <B3W>绿色字体三级标题</B3W>

**使用方法：**（需`import {  B1, B2, B3, BH3, B3W} from '@site/src/components/ForMDX';`）
```
# <B1>一级标题</B1>
## <B2>二级标题</B2>
### <B3>无序三级标题</B3>
### <BH3>1.</BH3>有序三级标题
### <B3W>绿色字体三级标题</B3W>
```

上面关于B1、B2等自定义标题的样式可在`.src/css/custom.css`中修改

---

## 📚 参考资料

- [波特律动](https://github.com/BaudDance/docs/blob/main/docs/stm32/getting-started/getting-started.mdx "按键链接跳转")

- [Zhang的学习笔记](https://github.com/Ratherthan17/notes/blob/main/src/components/ForMDX/forMDX.js "图片嵌入、绑定自定义域名等")

- [Joseph Gan's Blog](https://bwgjoseph.com/docusaurus-how-to-enable-showlastupdate-feature-when-deployed-via-gitlab-ci "最后更新时间")

- [roc的技术笔记](https://imroc.cc/note/category/docusaurus "学习")

- [AlanWang's Blog](https://www.alanwang.site/posts/blog-guides/docusaurus-search "学习")
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\mydoc\testpage1.md===
---FRONTMATTER---
sidebar_label: '测试页1'
sidebar_position: 1.1
description: 这是我的测试页1！
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';

### testpage1

#### 这是我的测试页面1







```c
int main(){
    Timer_Init();
    OLED_Init();
    while(1){
        Task();
    }
}
```

`<p>`会让一段话成为独立段落，起换行作用

✅ 详细解释 `<div>` 是什么？

`<div>` 是 HTML 中的块级元素（block-level element） 它本身没有语义含义
（不像 `<section>`, `<article>` 那样有明确意义）

常用于：

* 包裹一组内容
* 作为布局容器使用 
* 给这一组内容统一加样式或结构控制

生成ssh密钥：
```
ssh-keygen -t ed25519 -C "2560291241@qq.com" -f ~/.ssh/id_E1H
```

这是一段测试文字，用于测试 `update-recent-posts.js`

<p><CardImg src="/img/Gif/gif-example.gif" alt="gif示例图" isCenter={true} /></p>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\mydoc\testpage2.md===
---FRONTMATTER---
sidebar_label: '测试页2'
sidebar_position: 1.2
description: 这是我的测试页2！
---END FRONTMATTER---

---CONTENT---
### testpage2

#### 这是我的测试页面2
## [百度链接测试](https://pan.baidu.com/s/1_NekRw0iiHkXVYvtZUaQvA?pwd=9980 "双镜奇缘")

我现在已经在Vercel上部署了我的网站，由于Vercel上已经和我现在的这个网站的github账户关联，所以需要在Vercel上部署时，
只需把新内容提交到本地仓库然后 `git push` 到远端就行了，Vercel会自动识别到仓库内容的变化，然后自动部署；

之前部署到 `git pages`，则需要 `yarn deploy`，这会在本地构建一个 `build` 文件夹，但是Vercel的部署不用，因为 `build` 是在远端进行的。

这是一个测试，测试修复的update-recent-post.js是否能够正常工作！
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\mydoc\testpage3.mdx===
---FRONTMATTER---
sidebar_label: '测试页3'
sidebar_position: 1.3
description: 这是我的测试页3！
---END FRONTMATTER---

---CONTENT---
<!-- import 语句必须放在这里 -->
import CardImg from '@site/src/components/CardImg';

### testpage3(上面的import必须和此正文有一行之隔否则会报错！)

#### 这是我的测试页面3

使用组件：
<div style={{
  display: 'flex',
  flexDirection: 'column',
  gap: '10px',
}}>
  <h3>这是第一张图片</h3>
  <CardImg src="/img/example.jpg" alt="示例图1" isCenter={true} />
  <h3>这是第二张图片（带卡片装饰）</h3>
  <CardImg src="/img/example.jpg" alt="示例图2" isCenter={true} isBoxed={true} />
</div>

```
<div style={{
  display: 'flex',
  flexDirection: 'column',
  gap: '10px',
}}>
  <h3>这是第一张图片</h3>
  <CardImg src="/img/example.jpg" alt="示例图1" isCenter={true} />
  <h3>这是第二张图片（带卡片装饰）</h3>
  <CardImg src="/img/example.jpg" alt="示例图2" isCenter={true} isBoxed={true} />
</div>
```
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\mydoc\testpage4.mdx===
---FRONTMATTER---
sidebar_label: '测试页4'
sidebar_position: 1.4
description: 这是我的测试页4！
---END FRONTMATTER---

---CONTENT---
### 暂时没看出来有什么用的按钮
export const Highlight = ({children, color}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '20px',
      color: '#fff',
      padding: '10px',
      cursor: 'pointer',
    }}
    onClick={() => {
      alert(`You clicked the color ${color} with label ${children}`)
    }}>
    {children}
  </span>
);

**代码：**
```js
export const Highlight = ({children, color}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '20px',
      color: '#fff',
      padding: '10px',
      cursor: 'pointer',
    }}
    onClick={() => {
      alert(`You clicked the color ${color} with label ${children}`)
    }}>
    {children}
  </span>
);
```

This is <Highlight color="#25c2a0">Docusaurus green</Highlight> !

This is <Highlight color="#F2BBE0">Facebook Pink</Highlight> !
<div className='flex gap-5' >
  <a href="\blog" class="source_card_button" target="_blank">**📂 Blog**</a>
</div>

<div style={{ marginBottom: '20px' }}></div>

## 生成SSH密钥
```
ssh-keygen -t ed25519 -C "2560291241@qq.com" -f ~/.ssh/id_E1H
```
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\mydoc\testpage5.mdx===
---FRONTMATTER---
sidebar_label: '测试页5'
sidebar_position: 1.5
description: 这是我的测试页5！
---END FRONTMATTER---

---CONTENT---
import { Highlight, Button, MyColor} from '@site/src/components/ForMDX';


# Hello

This is my **first Docusaurus document**!

*this is a test document*

**2025/06/23**




✅ 简单说：**MDX = Markdown + React 组件，写法要符合 JSX 规范。**
## 测试，尝试用EurekaShadow部署git pages
可以用`nano <文件名>`进入某个文件并对其进行修改，比如此刻就是通过命令行`nano hello.mdx`
进入该文件内容编辑此处的内容。
编辑好内容后可以使用`ctrl + O -> 回车 -> 保存`，之后再使用`ctrl + X`退出编辑器
现在将再次尝试用EurekaShadow这个账号进行网站的部署.(之前似乎不是因为不行，而是**音视频文件太大**导致部署一次要花很久`180s`左右)所以现在再次尝试，希望能够成功。

TIPS:在使用`cd`进入某个文件夹后，如果不确定其中有什么文件，可以用`ls`,列出该文件夹内包含的文件。如果要修改某个文件，可以用上述的`nano`指令，但是这时候不需要，将文件名完全打出，比如这样`nano hello`再按Tab键就会自动把后续的内容补全了。

测试测试！现将test-site转移到D盘，已删除C盘文件，看看是否可正常部署。（20250820）
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\mydoc\内嵌目录\testpage6.mdx===
---FRONTMATTER---
sidebar_label: '测试页6'
sidebar_position: 1.0
description: 这是我的测试页6！
---END FRONTMATTER---

---CONTENT---
### This is a test
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\myproject\项目1\project1.mdx===
---FRONTMATTER---
sidebar_label: '基于物联网的工地扬尘与噪音实时监测系统'
sidebar_position: 1.0
description: 这是我的毕业设计，也是我实现的第一个完整的嵌入式项目，颇具纪念意义！
---END FRONTMATTER---

---CONTENT---
## 项目概览

**项目名称**：基于物联网的工地扬尘与噪音实时监测系统

**开发时间**：2025年2月 - 2025年5月

**项目类型**：个人毕业设计项目

**技术栈**：STM32 + C语言 + WiFi + 云平台

> 一句话描述：一个实时监测建筑工地PM2.5、PM10、噪音等环境参数的物联网系统

以下内容正在施工中。。。🥱
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:docs\reflection-space.mdx===
---FRONTMATTER---
slug: /reflection-space
title: 回想空间
sidebar_position: 1
description: 学习、记录、沉淀 —— 这里是我成长轨迹的归档。
last_updated: 2025年07月06日 星期日
---END FRONTMATTER---

---CONTENT---
# 回想空间 - 成长轨迹 🧭

这是一份写给未来自己的笔记合集，记录了我在不同阶段的学习内容、思考过程和实践总结。它不是教程，也不是作品集，而是一个持续更新的知识地图，帮助我回溯曾经走过的路。

---

## 📌 说明

本页面用于整理各类学习内容的入口链接，便于后期快速查找与回顾。内容涵盖技术探索、工具使用、思维方法等多个方面。

---

## 🕒 最近更新

---
- [2025年8月27日 - 国际化](/blog/i18n)
- [2025年8月27日 - Testpage2](/docs/mydoc/testpage2)
- [2025年8月27日 - 为 Docusaurus 添加 Algolia 搜索功能](/blog/Algolia)
- [2025年8月26日 - 最小覆盖子串](/blog/LeetCode76)
---


## 📁 内容分类

### 技术学习

- 编程语言基础
- 开发工具与流程
- 框架/库的使用心得

### 实践记录

- [我的项目](/docs/category/我的项目)
- 动手实验日志
- Bug 分析与解决思路

### 思维与方法

- 学习技巧总结
- 时间管理尝试
- 问题分析方式归纳

---

## 🔍 精选推荐

- [Git学习总结](/blog/LearnGit)
- [英语小结](/blog/LearnEng)
- [算法总结](/blog/Algorithm)

---

## 📁 后续计划

### 首要
- [ ] 总结毕设项目
- [ ] 完善简历
- [ ] 完成STM32的HAL学习，用HAL库完全实现之前用标准库实现的功能
- [ ] 学习 FreeRTOS
- [ ] 完成平衡小车制作
- [ ] 从[项目](https://github.com/78/xiaozhi-esp32 "小智")学习ESP32-S3
- [ ] 学习嵌入式 Linux 相关的基础知识
- [X] 尝试批量图片压缩
- [X] 检查为何 `build` 文件夹过大

---
### 次要
- [X] 为网站添加[搜索](https://www.alanwang.site/posts/blog-guides/docusaurus-search "参考")功能
- [ ] 浅学一下 python 
- [ ] 使用 Ren'py 制作一个游戏
- [ ] 翻译网站，使得网站可以切换为英文
- [ ] 自己实现 docusaurus deploy
- [ ] 在[云服务](https://help.aliyun.com/zh/ecs/support/ecs-free-trial?spm=a2c4g.11186623.help-menu-25365.d_8_1_0.1f1630183ZuMk1)上部署网站，实现网站国内流程访问
- [ ] 使用OSS + CDN实现网站国内流畅访问
> （即使没人看我的博客，我还是想要实现在国内的流畅访问，因为我觉得这很COOL！~😎）
- [ ] 完成域名的备案
- [X] 写脚本实现 ssh ID 的切换



这份文档不会刻意追求完整或系统，只求在某个时间点上能为未来的我提供一些线索与参考。
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-06-05-greetings.md===
---FRONTMATTER---
slug: greetings
title: Greetings!
authors: eurekaX
tags: [greetings]
---END FRONTMATTER---

---CONTENT---
Congratulations, you have made your first post!

Feel free to play around and edit this post as much as you like.AAAA

**I MADE MY FIRST BLOG POST!!!**

<!-- truncate -->

这是后续内容：

* 哈哈哈
* 舒适
* 反复
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-06-05-TEST.md===
---FRONTMATTER---
slug: TEST
title: TEST!
authors: eurekaX
tags: [greetings]

---END FRONTMATTER---

---CONTENT---
This is the summary of a very long blog post,

Use a `<!--` `truncate` `-->` comment to limit blog post size in the list view.

<!-- truncate -->

**TEST**

插入`<!--` `truncate` `-->`，表示`<!--` `truncate` `-->`以上的内容为预览，`<!--` `truncate` `-->`一下的内容为完整内容。
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-06-23-Blog1.md===
---FRONTMATTER---
slug: Blog1
title: Blog1!
authors: eurekaX
tags: [recording]
---END FRONTMATTER---

---CONTENT---
**关于图标的替换**

<!-- truncate -->
总结：
字段	含义
slug	页面的自定义 URL 路径
title	页面显示的标题
authors	作者名
tags	文章标签，用于分类
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-07-04-LeetCode88.mdx===
---FRONTMATTER---
slug: LeetCode88
title: 合并两个有序数组
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——88题](https://leetcode.cn/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->

给你两个按**非递减顺序**排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n`，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你合并 `nums2` 到 `nums1` 中，使合并后的数组同样按**非递减顺序**排列。

> ⚠️ 注意：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0`，应忽略。`nums2` 的长度为 `n`。

---

### 🧪 示例说明

#### 示例 1：
> 输入：  
> `nums1 = [1, 2, 3, 0, 0, 0]`, `m = 3`  
> `nums2 = [2, 5, 6]`, `n = 3`  
>
> 输出：  
> `[1, 2, 2, 3, 5, 6]`  
>
> 解释：需要合并 `[1,2,3]` 和 `[2,5,6]`。  
> 合并结果是 `[1, 2, 2, 3, 5, 6]`，其中斜体加粗标注的为 `nums1` 中的原始元素。

#### 示例 2：
> 输入：  
> `nums1 = [1]`, `m = 1`  
> `nums2 = []`, `n = 0`  
>
> 输出：  
> `[1]`

#### 示例 3：
> 输入：  
> `nums1 = [0]`, `m = 0`  
> `nums2 = [1]`, `n = 1`  
>
> 输出：  
> `[1]`  
>
> 解释：因为 `m = 0`，所以 `nums1` 中没有有效元素。`0` 只是为了确保合并结果可以顺利存放到 `nums1` 中。

---

### 🔍 提示：

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `-10^9 <= nums1[i], nums2[j] <= 10^9`

---

### 🚀 进阶挑战：

你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？

---

### 💡 参考代码：

```c
/**
 * 合并两个已排序的数组
 * 将 nums2 合并到 nums1 中，结果存储在 nums1 内
 * 
 * @param nums1     目标数组，预分配了足够空间 (长度为 m+n)
 * @param nums1Size nums1 数组的总长度 (等于 m+n)
 * @param m         nums1 中有效元素的个数
 * @param nums2     源数组，包含需要合并的元素
 * @param nums2Size nums2 数组的长度 (等于 n)
 * @param n         nums2 中元素的个数
 */
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    // 初始化三个指针：i指向nums1有效元素末尾，j指向nums2末尾，k指向合并结果末尾
    int i = m - 1;      // nums1有效元素的最后一个索引
    int j = n - 1;      // nums2的最后一个索引
    int k = m + n - 1;  // 合并后数组的最后一个索引
    
    // 从后往前比较两个数组的元素，将较大者放到nums1的末尾
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];  // nums1[i]较大，将其放到位置k
        } else {
            nums1[k--] = nums2[j--];  // nums2[j]较大或相等，将其放到位置k
        }
    }
    
    // 如果nums2中还有剩余元素，复制到nums1中
    // 注意：如果nums1有剩余元素(i>=0)，它们已经在正确位置，无需移动
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 合并两个有序数组

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：将两个已排序的数组合并成一个有序数组，结果存储在第一个数组中

📥 **输入输出**：
- **输入**：两个已排序数组 `nums1` 和 `nums2`，以及它们的有效元素个数 `m` 和 `n`
- **输出**：无返回值，合并结果直接存储在 `nums1` 中

---

## 2️⃣ 实现原理

💡 **核心思路**：采用从后往前的双指针技术，避免覆盖未处理的数据

📋 **实现步骤**：
1. 设置三个指针分别指向两个数组有效元素末尾和合并结果末尾
2. 从后往前比较两个数组的元素，将较大者放到合并位置
3. 处理剩余未合并的元素

---

## 3️⃣ 关键点解析

### 🔁 为什么需要两个循环

第一个循环会在**任意一个数组处理完**时停止，但另一个数组可能还有剩余元素需要处理。

#### 📌 具体例子

`nums1 = [4,5,6,0,0,0] (m=3) nums2 = [1,2,3] (n=3)`


🔄 **执行过程**：
1. 比较 6 和 3 → nums1[5] = 6
2. 比较 5 和 3 → nums1[4] = 5  
3. 比较 4 和 3 → nums1[3] = 4

此时第一个循环结束，但nums2中[1,2,3]还没有被处理。

#### ⚡ 关键理解

当第一个循环结束时，有两种可能情况：
- **i < 0 但 j >= 0**：nums1处理完了，但nums2还有剩余元素需要复制
- **j < 0 但 i >= 0**：nums2处理完了，但nums1还有剩余元素

对于第二种情况，nums1的剩余元素**已经处于正确位置**，无需移动，所以不需要额外处理。

因此需要第二个循环来处理nums2的剩余元素。

### 🎯 代码技巧
- 从后往前遍历避免了覆盖 `nums1` 中未处理的元素
- 只需处理 `nums2` 的剩余元素，因为 `nums1` 的剩余元素已在正确位置
- 使用 `--` 操作符在赋值的同时移动指针，代码更简洁

---

## 4️⃣ 使用场景

✅ **适用情况**：
- 需要合并两个已排序的数组
- 希望在原地进行合并操作以节省空间
- 处理数组相关的归并排序问题

⚠️ **前提条件**：
- `nums1` 必须有足够空间容纳合并结果（至少 `m+n` 个元素）
- 两个输入数组都已按非递减顺序排序

---

## 5️⃣ 复杂度分析

⏱️ **时间复杂度**：O(m + n)，每个元素最多被访问一次

💾 **空间复杂度**：O(1)，只使用了常数个额外变量

---

## 6️⃣ 注意事项

🚩 **边界情况**：
- `m = 0`：`nums1` 为空数组
- `n = 0`：`nums2` 为空数组
- 其中一个数组的所有元素都比另一个数组小

💥 **易错点**：
- 忘记处理剩余元素，特别是第二个循环
- 指针边界条件判断错误
- 从前往后合并导致数据被覆盖


</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-07-06-LearnGit.mdx===
---FRONTMATTER---
slug: LearnGit
title: Git学习
authors: eurekaX
tags: [Git]
---END FRONTMATTER---

---CONTENT---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Git 使用技巧汇总
<!-- truncate -->

### 测试 git diff 功能

- `git diff`：查看**未暂存文件**与上次提交之间的差异。
- `git diff --staged`：查看**已暂存文件**与上次提交之间的差异。

✅ **一句话总结**：如果文件在**未暂存区**，使用 `git diff`；如果文件**已暂存**，使用 `git diff --staged`。

---

### 提交操作

- `git commit -a`：跳过 `git add` 阶段，一键暂存并提交所有修改。
- `git commit --amend`：撤销最近一次提交，并允许：
  - 使用 `git add` 补充遗漏的文件；
  - 编辑或保留原有的提交信息后重新提交。

🔁 适用于刚提交完发现还有文件没添加，或者需要修改提交信息的情况。

---

### 文件重命名操作

- `git mv <原文件名> <新文件名>`：用于重命名 Git 跟踪的文件。

示例：

```bash
git mv test1.txt test.txt
```

---

### 撤销暂存操作

- `git reset HEAD <文件名>`：取消某个文件的暂存状态。

示例：

```bash
git reset HEAD README.md
```

📌 常用于误将某些文件加入暂存区后想将其移出的情况。

---

### 放弃本地修改

- `git restore <文件名>`：放弃对该文件的所有本地修改。

⚠️ **注意**：该操作不可逆，请确保确实不需要这些修改后再执行。

---

## 分支切换与紧急修复流程

假设你现在正在解决问题53，当前处于 `iss53` 分支上，而 `main` 分支突然出现了问题，需要马上修复。

✅ **处理步骤如下**：

1. 切换回 `main` 分支：

   ```bash
   git switch main
   ```

2. 创建一个临时分支 `hotfix` 来修复问题：

   ```bash
   git checkout -b hotfix
   ```

3. 修复完成后，提交更改。

4. 切换回 `main` 分支并合并修复内容：

   ```bash
   git checkout main
   git merge hotfix
   ```

5. 删除临时分支（问题已修复）：

   ```bash
   git branch -d hotfix
   ```

6. 回到 `iss53` 分支继续开发：

   ```bash
   git switch iss53
   ```

---

## 合并冲突说明及解决方法

### ⚠️ 冲突原因

当 `main` 和 `iss53` 分支**同时修改了同一个文件的相同部分**（例如 `README.md`），Git 无法判断应该保留哪边的内容，就会提示冲突。

### 示例场景

- 在 `main` 分支下修改了 `README.md` 并提交；
- 然后切换到 `iss53` 分支，在此分支下也修改了 `README.md` 并提交；
- 最后切换回 `main` 分支，尝试合并 `iss53`，出现冲突。

---

### 🔧 解决步骤

1. 打开冲突文件（如 `README.md`），你会看到类似如下内容：

   ```html
   <<<<<<< HEAD
   This is the content from main.
   =======
   This is the content from iss53.
   >>>>>>> iss53
   ```

2. 手动编辑文件，选择你想要保留的内容，删除冲突标记。
3. 添加修改后的文件到暂存区：

   ```bash
   git add README.md
   ```

4. 提交合并结果：

   ```bash
   git commit -m "Fixed conflict"
   ```

---

### 💡 如何避免冲突？

- **保持分支同步**：在修改前先拉取最新代码；
- **及时合并分支**：避免两个分支长时间不合并；
- **明确分工**：团队协作时尽量避免多人修改同一文件的关键区域；
- **使用 Pull Request 审查机制**：提前发现潜在冲突。

---

## ✅ 实际测试说明

这是一个测试内容，当前文本是在 `iss53` 分支下编写完成的。之前已经与 `main` 分支合并。

按照预期，切换回 `main` 分支后，再合并 `iss53` 分支不会产生冲突，也就是说，在 `main` 分支下也能看到这段新增内容。

---

## 查看当前仓库的用户配置 😊

<Tabs>

  <TabItem value="global" label="全局">
```bash
git config --global user.name
git config --global user.email
```
  </TabItem>

  <TabItem value="local" label="本地">
```bash
git config user.name
git config user.email
```
  </TabItem>
 
</Tabs>

## 配置当前仓库的用户配置 🛠️

<Tabs>

  <TabItem value="global" label="全局">
```bash
git config --global user.name "GlobalAuthor"
git config --global user.email "global@example.com"
```
  </TabItem>

  <TabItem value="local" label="本地">
```bash
# 不加 --local 参数（默认就是局部配置）
git config user.name "LocalAuthor"
git config user.email "local@example.com"
```
  </TabItem>
 
</Tabs>

## 移除当前仓库的用户配置 🛠

<Tabs>

  <TabItem value="global" label="全局">
```bash
# 移除全局用户配置
git config --global --unset user.name
git config --global --unset user.email
```
  </TabItem>

  <TabItem value="local" label="本地">
```bash
# 移除本地用户配置
git config --unset user.name
git config --unset user.email
```
  </TabItem>
 
</Tabs>

## 切换作者推送代码 🔁
如果想要使用全局配置的作者信息进行推送，需要先删除局部（本地仓库）的作者配置。

1. 删除本地仓库的用户配置：
```bash
# 进入你的仓库目录
cd your-repository

# 删除本地的用户配置
git config --unset user.name
git config --unset user.email
```
2. 验证配置是否已删除：
```bash
# 查看当前仓库的用户配置（应该没有输出）
git config --local --list | grep user

# 查看生效的配置（应该显示全局配置）
git config --list | grep user
```
3. 确认使用的是全局配置：
```bash
# 查看当前生效的用户信息
git config user.name
git config user.email
```

4. 提交时的作者信息
删除本地配置后，新提交将使用全局配置的作者信息：
```bash
# 此时的提交将使用全局配置的作者
git commit -m "message"
```

## GitHub 身份识别机制总结 📚

### 核心原理 ⚡
- **提交作者识别**：基于 Git 提交中的 `user.name` 和 `user.email`
- **SSH 密钥作用**：仅用于认证访问权限，不决定提交作者

### 场景分析 🎭
**配置情况**：
- 全局作者：A
- 局部作者：B（本地仓库配置）
- SSH 密钥：A 的密钥
- 仓库权限：通过 A 的密钥访问 C 的仓库

**识别结果**：GitHub 显示推送者为 **B**（局部配置优先）

### 关键命令 🔑
```bash
# 查看当前身份配置
git config user.name
git config user.email

# 查看提交身份
git var GIT_AUTHOR_IDENT
git log --pretty=format:"%an <%ae>" -1
```
### 最终效果 🎯
- 提交作者：B（局部配置）
- 推送权限：A（SSH 密钥认证）
- 仓库所有者：C（实际仓库拥有者）

## 解决 Key is already in use 问题 💡

1. 为不同账户生成不同的密钥对
```bash
# 为用户A生成密钥
ssh-keygen -t rsa -b 4096 -C "userA@example.com" -f ~/.ssh/userA_key

# 为用户B生成密钥
ssh-keygen -t rsa -b 4096 -C "userB@example.com" -f ~/.ssh/userB_key
```

2. 配置 SSH 配置文件区分不同账户
创建/编辑 `~/.ssh/config` 文件：
```bash
# 用户A的配置
Host github-userA
    HostName github.com
    User git
    IdentityFile ~/.ssh/userA_key

# 用户B的配置
Host github-userB
    HostName github.com
    User git
    IdentityFile ~/.ssh/userB_key
```

3. 克隆和推送时使用不同 Host
```bash
# 克隆用户A的仓库
git clone git@github-userA:username/repo.git

# 克隆用户B的仓库
git clone git@github-userB:username/repo.git
```

4. 为现有仓库更改 remote URL
```
# 更改为用户A的配置
git remote set-url origin git@github-userA:username/repo.git

# 更改为用户B的配置
git remote set-url origin git@github-userB:username/repo.git
```

### 验证配置 ✅
```bash
# 测试连接用户A
ssh -T git@github-userA

# 测试连接用户B
ssh -T git@github-userB
```
这样就可以用不同的密钥管理不同账户的仓库访问权限。🎉

## 将本地新建分支推送到远端
```bash
git push -u origin your-branch-name
```
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-07-29-LeetCode27.mdx===
---FRONTMATTER---
slug: LeetCode27
title: 移除元素
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——27题](https://leetcode.cn/problems/remove-element/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 原地移除数组中等于 val 的元素
 * 
 * @param nums 输入数组
 * @param numsSize 数组长度
 * @param val  要移除的值
 * @return 返回不等于 val 的元素数量
 */
int removeElement(int* nums, int numsSize, int val) {
    int slow = 0;  // 慢指针，指向下一个要放置非val元素的位置
    
    // 快指针遍历整个数组
    for (int fast = 0; fast < numsSize; fast++) {
        // 如果当前元素不等于val，则将其放到slow位置
        if (nums[fast] != val) {
            nums[slow++] = nums[fast];
        }
    }
    
    return slow;  // slow即为新数组的长度
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 移除元素

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：原地移除数组中所有等于指定值的元素，返回剩余元素数量

📥 **输入输出**：
- **输入**：数组 `nums`、数组长度 `numsSize`、要移除的值 `val`
- **输出**：不等于 `val` 的元素数量，且这些元素位于数组前部

---

## 2️⃣ 实现原理

💡 **核心思路**：使用快慢双指针技术，快指针遍历数组，慢指针记录有效元素位置

📋 **实现步骤**：
1. 初始化慢指针指向数组开头（下一个有效元素存放位置）
2. 快指针遍历整个数组
3. 遇到不等于 `val` 的元素就放到慢指针位置，并移动慢指针
4. 返回慢指针的位置即为新数组长度

---

## 3️⃣ 关键点解析

### 🧠 初始思路 vs 最优解

#### 💭 我的初始想法
使用额外数组存储不等于 `val` 的元素，遍历完成后复制回原数组。即：
```c
int removeElement(int* nums, int numsSize, int val) {
    int tempArray[100];  // 额外数组
    int count = 0;
    
    // 第一遍遍历：复制到临时数组
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] != val) {
            tempArray[count++] = nums[i];
        }
    }
    
    // 第二遍遍历：复制回原数组
    for (int i = 0; i < count; i++) {
        nums[i] = tempArray[i];
    }
    
    return count;
}
```

#### ⚡ 最优解法（双指针）

```c
int removeElement(int* nums, int numsSize, int val) {
    int slow = 0;  // 慢指针，指向下一个要放置非val元素的位置
	
    // 快指针遍历整个数组
    for (int fast = 0; fast < numsSize; fast++) {
        // 如果当前元素不等于val，则将其放到slow位置
        if (nums[fast] != val) {
            nums[slow++] = nums[fast];
        }
    }
    
    return slow;  // slow即为新数组的长度
}
```
### 🆚 对比分析

| 方面 | 初始思路 | 最优解(双指针) |
|------|----------|----------------|
| 空间复杂度 | O(n) - 需要额外数组 | O(1) - 原地操作 |
| 时间复杂度 | O(n) - 两次遍历 | O(n) - 一次遍历 |
| 代码简洁性 | 需要两个循环 | 只需一个循环 |
| 是否原地 | 否 | 是 |

### 🎯 代码技巧
- 快慢指针的经典应用
- 利用数组随机访问特性，直接覆盖无效元素
- `slow` 指针既作为索引又作为计数器

---

## 4️⃣ 使用场景

✅ **适用情况**：
- 需要原地删除数组中满足条件的元素
- 数组元素过滤操作
- 类似问题：删除重复元素、移动零等

⚠️ **前提条件**：
- 元素顺序可以改变
- 只关心前k个元素，其余位置内容无关紧要

---

## 5️⃣ 复杂度分析

⏱️ **时间复杂度**：O(n)，只需要遍历数组一次

💾 **空间复杂度**：O(1)，只使用了常数个额外变量

---

## 6️⃣ 注意事项

🚩 **边界情况**：
- 空数组：`numsSize = 0`
- 所有元素都等于 `val`
- 所有元素都不等于 `val`

💥 **易错点**：
- 忘记返回新数组长度
- 指针边界条件处理错误
- 没有正确理解"原地"的含义


</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-07-30-LeetCode26.mdx===
---FRONTMATTER---
slug: LeetCode26
title: 删除有序数组中的重复项
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——26题](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 删除排序数组中的重复项
 * 
 * @param nums 排序数组指针，用于原地删除重复元素
 * @param numsSize 数组长度
 * @return 返回删除重复元素后数组的新长度
 * 
 * @description 使用双指针法原地删除重复元素，保持元素相对顺序不变
 * 时间复杂度: O(n)
 * 空间复杂度: O(1)
 */
int removeDuplicates(int* nums, int numsSize) {
    int slow = 0;  // 慢指针，指向不重复元素的当前位置
    
    // 快指针遍历整个数组，从第二个元素开始
    for (int fast = 1; fast < numsSize; fast++) {
        // 当快指针指向的元素与慢指针指向的元素不相等时
        if (nums[fast] != nums[slow]) {
            // 将慢指针前移一位，并将快指针元素复制到该位置
            nums[++slow] = nums[fast];
        }
    }
    
    return slow + 1;  // 返回不重复元素的个数
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 删除有序数组中的重复项

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：原地删除非严格递增排列数组中的重复元素，使每个元素只出现一次

📥 **输入输出**：
- **输入**：非严格递增排列数组 `nums`、数组长度 `numsSize`
- **输出**：删除重复元素后数组的新长度，并保证前k个元素为唯一元素

---

## 2️⃣ 实现原理

💡 **核心思路**：使用快慢双指针技术，快指针遍历数组，慢指针记录不重复元素位置

📋 **实现步骤**：
1. 初始化慢指针指向数组第一个元素位置
2. 快指针从第二个元素开始遍历整个数组
3. 当快指针元素与慢指针元素不相等时，将快指针元素复制到慢指针下一个位置
4. 返回慢指针位置加1即为新数组长度

---


## 3️⃣ 关键点解析

### 🎯 代码技巧
- 快慢指针的经典应用
- 利用数组已排序特性，只需比较相邻不同元素
- `slow` 指针既作为索引又作为计数器

## 4️⃣ 使用场景

### ✅ 适用情况：
- 有序数组去重操作
- 保留唯一元素并维持原有顺序
- 类似问题：删除重复元素II、移除元素等

### ⚠️ 前提条件：
- 数组必须是排序的（非严格递增）
- 只关心前k个元素，其余位置内容无关紧要

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，只需要遍历数组一次

- 💾 空间复杂度：O(1)，只使用了常数个额外变量

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空数组或单元素数组：`numsSize <= 1`
- 所有元素都相同
- 所有元素都不相同

### 💥 易错点：
- 忘记处理边界条件（如果题目没有保证数组非空）
- 返回值应该是 `slow + 1` 而不是 `slow`
- 没有正确理解"原地"的含义
- 快指针起始位置应该是1而不是0

</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-07-30-LeetCode80.mdx===
---FRONTMATTER---
slug: LeetCode80
title: 删除有序数组中的重复项 Ⅱ
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——80题](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 删除有序数组中的重复项（最多保留2个相同元素）
 * 
 * @param nums 有序数组指针，用于原地删除重复元素
 * @param numsSize 数组长度
 * @return 返回删除重复元素后数组的新长度
 * 
 * @description 使用双指针法原地删除重复元素，使得每个元素最多出现两次
 * 时间复杂度: O(n) - 只需遍历数组一次
 * 空间复杂度: O(1) - 只使用常数额外空间
 * 
 */
int removeDuplicates(int* nums, int numsSize) {
    // 边界条件：如果数组长度小于等于2，无需处理直接返回
    // 因为最多保留2个相同元素，所以长度小于等于2的数组肯定符合要求
    if (numsSize <= 2) {
        return numsSize;
    }
    
    // 初始化慢指针指向索引2
    // 前两个元素肯定可以保留（最多允许2个重复），所以从第3个位置开始放置有效元素
    int slow = 2;
    
    // 快指针从索引2开始遍历整个数组
    // 从第3个元素开始检查是否需要保留
    for (int fast = 2; fast < numsSize; fast++) {
        // 核心判断条件：只有当当前元素与slow指针前两个位置的元素不同时才保留
        // 这确保了任何元素都不会出现超过2次
        // 原理：如果nums[fast] == nums[slow-2]，说明包括即将插入的位置已经有3个相同元素了
        if (nums[fast] != nums[slow - 2]) {
            // 将当前元素复制到slow指针位置
            nums[slow] = nums[fast];
            // 慢指针前移，指向下一个可放置元素的位置
            slow++;
        }
        // 如果nums[fast] == nums[slow-2]，则跳过当前元素（不复制），fast继续前进
    }
    
    // 返回新数组的长度
    // 由于slow指向下一个可放置位置的索引，所以直接返回slow即为数组长度
    return slow;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 删除有序数组中的重复项 II

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：原地删除有序数组中的重复元素，使得每个元素最多出现两次

📥 **输入输出**：
- **输入**：有序数组 `nums`、数组长度 `numsSize`
- **输出**：删除重复元素后数组的新长度，并修改原数组前k个元素

---

## 2️⃣ 实现原理

💡 **核心思路**：使用双指针技术，通过比较当前元素与已保留元素中倒数第2个元素来判断是否允许插入

📋 **实现步骤**：
1. 处理边界情况：数组长度≤2时直接返回
2. 初始化慢指针指向索引2（前两个元素肯定可以保留）
3. 快指针从索引2开始遍历数组
4. 当快指针元素与慢指针前两个位置元素不同时，将其复制到慢指针位置
5. 返回慢指针位置作为新数组长度

---

## 3️⃣ 关键点解析

### 初始思路 vs 最优解

#### 💭 我的初始想法
使用显式计数器记录当前元素出现次数，当元素相同时只有计数小于1时才允许复制：
```c
int removeDuplicates(int* nums, int numsSize) {
    int slow = 0;
    int count = 0;
    
    for (int fast = 1; fast < numsSize; fast++) {
        if (nums[fast] != nums[slow]) {
            nums[++slow] = nums[fast];
            count = 0;
        } else if(count < 1){
            count++;
            nums[++slow] = nums[fast];    
        }
    }
    
    return slow + 1;
}
```

#### ⚡ 最优解法（隐式计数）
```c
int removeDuplicates(int* nums, int numsSize) {
    if (numsSize <= 2) {
        return numsSize;
    }
    
    int slow = 2;
    
    for (int fast = 2; fast < numsSize; fast++) {
        if (nums[fast] != nums[slow - 2]) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    
    return slow;
}
```

### 🆚 对比分析

| 方面 | 初始思路 | 最优解 |
|------|----------|--------|
| 计数方式 | 显式计数器 | 隐式通过数组位置关系 |
| 代码复杂度 | 需要维护count变量 | 无需额外变量 |
| 可读性 | 逻辑清晰但稍复杂 | 简洁但需要理解技巧 |
| 扩展性 | 容易扩展到k次重复 | 需要修改索引计算 |

### 🎯 代码技巧
- 双指针法的经典应用
- 利用数组有序特性，通过位置关系隐式计数
- 边界条件的巧妙处理（前两个元素天然满足条件）

## 4️⃣ 使用场景

### ✅ 适用情况：
- 有序数组中限制元素出现次数
- 需要原地处理数组数据
- 类似问题：删除重复元素I、移除元素等

### ⚠️ 前提条件：
- 数组必须是排序的
- 只关心前k个元素，其余位置内容无关紧要

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，只需要遍历数组一次

- 💾 空间复杂度：O(1)，只使用了常数个额外变量

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空数组或单元素数组：`numsSize <= 2`
- 所有元素都相同
- 所有元素都不相同
- 只有部分元素重复超过两次

### 💥 易错点：
- 忘记处理边界条件
- 慢指针起始位置应该是2而不是0
- 返回值应该是 `slow` 而不是 `slow + 1`
- 比较条件应该是 `nums[fast] != nums[slow - 2]` 而不是其他位置
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-07-31-LeetCode169.mdx===
---FRONTMATTER---
slug: LeetCode169
title: 多数元素
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——169题](https://leetcode.cn/problems/majority-element/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 查找数组中的多数元素（出现次数大于⌊n/2⌋的元素）
 * 使用Boyer-Moore投票算法实现
 * 
 * @param nums 整数数组指针
 * @param numsSize 数组长度
 * @return 返回多数元素
 */
int majorityElement(int* nums, int numsSize) {
    // 初始化候选人为第一个元素，计数为1
    int candidate = nums[0];
    int count = 1;
    
    // 投票阶段：遍历数组中剩余的所有元素
    for (int i = 1; i < numsSize; i++) {
        // 如果计数为0，更换候选人
        if (count == 0) {
            candidate = nums[i];  // 设置新的候选人
            count = 1;            // 重置计数为1
        } 
        // 如果当前元素与候选人相同，计数加1
        else if (nums[i] == candidate) {
            count++;
        } 
        // 如果当前元素与候选人不同，计数减1（相当于抵消）
        else {
            count--;
        }
    }
    
    // 返回最终的候选人（多数元素）
    return candidate;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 多数元素

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

📥 **输入输出**：
- **输入**：`int* nums`（整数数组指针），`int numsSize`（数组长度）
- **输出**：返回多数元素（保证存在）

---

## 2️⃣ 实现原理

💡 **核心思路**：使用Boyer-Moore投票算法，利用多数元素出现次数超过一半的特性，通过"投票抵消"机制找到目标元素。

📋 **实现步骤**：
1. 初始化候选元素为数组第一个元素，计数器为1
2. 遍历数组剩余元素
3. 若计数器为0，更新候选元素为当前元素，计数器重置为1
4. 若当前元素等于候选元素，计数器加1
5. 若当前元素不等于候选元素，计数器减1
6. 返回最终候选元素

---

## 3️⃣ 关键点解析

原始思路是使用双重循环统计每个元素出现次数，时间复杂度O(n²)，虽然正确但效率低。最优解使用Boyer-Moore投票算法，时间复杂度降为O(n)，空间复杂度O(1)。

### 🎯 代码技巧
- 利用多数元素超过一半的数学特性
- 采用抵消思想，相同+1，不同-1
- 无需实际统计次数，只需找到候选元素

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要找到出现次数超过一半的元素
- 数据流中查找多数元素
- 在线算法场景，需要实时处理

### ⚠️ 前提条件：
- 数组非空
- 保证存在多数元素（出现次数>n/2）

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n) - 只需遍历数组一次

- 💾 空间复杂度：O(1) - 只使用常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组只有一个元素
- 多数元素刚好出现⌊n/2⌋+1次
- 数组长度为偶数或奇数的情况

### 💥 易错点：
- 忘记处理计数器为0时的候选元素更新
- 混淆多数元素的判断条件（>n/2而非≥n/2）
- 在实际应用中未验证结果确实为多数元素

## 7️⃣ 补充说明

**"战场对决"类比**
```c
/**
 * 多数元素查找 - Boyer-Moore投票算法详解
 * 
 * 核心思想：多数元素的数量超过总数的一半
 * 就像一支军队人数超过总兵力的50%，即使与其他所有军队一对一战斗，
 * 最后剩下的肯定还是这支军队的人
 */
int majorityElement(int* nums, int numsSize) {
    // 初始时，我们假设第一个士兵（数组第一个元素）是我们要找的军队
    int candidate = nums[0];  // 当前候选军队
    int count = 1;            // 当前军队的士兵数量（初始为1）
    
    // 从第二个士兵开始检阅整个军队
    for (int i = 1; i < numsSize; i++) {
        // 如果战场上没有士兵了（count为0）
        if (count == 0) {
            // 更换候选军队为当前遇到的士兵所属军队
            candidate = nums[i];  // 新的候选军队
            count = 1;            // 这支军队当前有1个士兵
        } 
        // 如果当前士兵属于我们正在追踪的候选军队
        else if (nums[i] == candidate) {
            count++;  // 该军队士兵数量+1
        } 
        // 如果当前士兵属于其他军队（敌对军队）
        else {
            count--;  // 我们候选军队的士兵与敌军士兵同归于尽，数量-1
        }
    }
    
    // 最终剩下的候选军队就是多数军队（多数元素）
    return candidate;
}
```

**具体例子演示**

以数组 `[2,2,1,1,1,2,2]` 为例：

| 步骤 | 当前元素 | candidate | count | 说明 |
|------|----------|-----------|-------|------|
| 初始 | - | 2 | 1 | 假设第一个元素2是多数元素 |
| i=1 | 2 | 2 | 2 | 遇到相同元素，count++ |
| i=2 | 1 | 2 | 1 | 遇到不同元素，count--（2和1抵消） |
| i=3 | 1 | 2 | 0 | 再次抵消，count变为0 |
| i=4 | 1 | 1 | 1 | count为0，更换候选元素为1 |
| i=5 | 2 | 1 | 0 | 1和2抵消，count变为0 |
| i=6 | 2 | 2 | 1 | count为0，更换候选元素为2 |
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-01-LeetCode121.mdx===
---FRONTMATTER---
slug: LeetCode121
title: 买卖股票的最佳时机
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——121题](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 计算股票交易的最大利润
 * 
 * 给定一个数组，它的第i个元素是一支给定股票第i天的价格。
 * 只能选择某一天买入股票，并选择在未来的某一个不同的日子卖出该股票。
 * 设计一个算法来计算所能获取的最大利润。
 * 
 * @param prices 整数数组，表示股票每天的价格
 * @param pricesSize 数组prices的长度
 * @return 返回能获取的最大利润，如果不能获取任何利润则返回0
 * 
 * 示例:
 * 输入: [7,1,5,3,6,4]
 * 输出: 5
 * 解释: 在第2天买入(价格=1)，在第5天卖出(价格=6)，利润=6-1=5
 * 
 * 输入: [7,6,4,3,1]
 * 输出: 0
 * 解释: 价格持续下跌，无法获得利润
 * 
 * 时间复杂度: O(n)
 * 空间复杂度: O(1)
 */
int maxProfit(int* prices, int pricesSize) {
    // 如果天数少于2天，无法完成交易，返回0
    if (pricesSize <= 1) {
        return 0;
    }
    
    // 初始化最低价格为第一天的价格
    int minPrice = prices[0];
    // 初始化最大利润为0
    int maxProfit = 0;
    
    // 从第二天开始遍历所有价格
    for (int i = 1; i < pricesSize; i++) {
        // 如果当前价格比记录的最低价格更低，则更新最低价格
        if (prices[i] < minPrice) {
            minPrice = prices[i];
        } 
        // 如果当前价格与最低价格的差值大于记录的最大利润，则更新最大利润
        else if (prices[i] - minPrice > maxProfit) {
            maxProfit = prices[i] - minPrice;
        }
    }
    
    return maxProfit;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 买卖股票的最佳时机

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定股票价格数组，找出买入和卖出股票能获得的最大利润，只能进行一次交易且卖出日必须在买入日之后

📥 **输入输出**：
- **输入**：int* prices（股票价格数组）, int pricesSize（数组长度）
- **输出**：int（最大利润值，无法获利时返回0）

---

## 2️⃣ 实现原理

💡 **核心思路**：一次遍历动态维护最低买入价格和最大利润

📋 **实现步骤**：
1. 初始化最低价格为第一天价格，最大利润为0
2. 从第二天开始遍历价格数组
3. 若当前价格低于最低价格，则更新最低价格
4. 否则计算当前卖出可得利润，若大于最大利润则更新最大利润
5. 遍历结束返回最大利润

---

## 3️⃣ 关键点解析

原始思路是使用快慢指针枚举所有买入卖出组合，通过两层循环计算每种可能的利润并取最大值。但该方法时间复杂度为O(n²)。最优解通过记录到目前为止的最低价格和最大利润，只需一次遍历就能得到结果，时间复杂度优化为O(n)。

### 🎯 代码技巧
- 使用else if避免不必要的利润计算
- 初始化最低价格为第一个元素，从第二个元素开始遍历
- 利用贪心思想，始终维护到目前为止的最优解

## 4️⃣ 使用场景

### ✅ 适用情况：
- 股票交易利润最大化问题
- 需要找出数组中两个元素的最大正向差值
- 在线算法需要实时更新最优解

### ⚠️ 前提条件：
- 卖出日必须在买入日之后
- 只能进行一次交易
- 数组元素为非负整数

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，只需遍历数组一次

- 💾 空间复杂度：O(1)，只使用常数个额外变量

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组长度为0或1时，无法完成交易
- 价格持续下跌时，利润为0
- 数组为空指针的情况

### 💥 易错点：
- 忘记处理数组长度小于2的边界情况
- 错误地允许在买入前卖出
- 没有正确初始化最小价格和最大利润
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-01-LeetCode189.mdx===
---FRONTMATTER---
slug: LeetCode189
title: 轮转数组
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——189题](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * @brief 反转数组中指定范围的元素
 * 
 * @param nums 指向整型数组的指针
 * @param start 反转范围的起始索引（包含）
 * @param end 反转范围的结束索引（包含）
 * 
 * @details 使用双指针法，从两端向中间交换元素，实现数组部分反转
 *          时间复杂度: O(n)，空间复杂度: O(1)
 */
void reverse(int* nums, int start, int end) {
    while (start < end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
    }
}

/**
 * @brief 将数组中的元素向右轮转 k 个位置
 * 
 * @param nums 指向整型数组的指针
 * @param numsSize 数组的长度
 * @param k 轮转的步数（非负数）
 * 
 * @details 使用三步反转法实现数组轮转：
 *          1. 反转整个数组
 *          2. 反转前 k 个元素
 *          3. 反转后 n-k 个元素
 *          
 *          例如: nums = [1,2,3,4,5,6,7], k = 3
 *          step1: [7,6,5,4,3,2,1] 反转整个数组
 *          step2: [5,6,7,4,3,2,1] 反转前3个元素
 *          step3: [5,6,7,1,2,3,4] 反转后4个元素
 *          
 *          时间复杂度: O(n)，空间复杂度: O(1)
 */
void rotate(int* nums, int numsSize, int k) {
    // 处理k大于数组长度的情况，避免不必要的轮转
    k = k % numsSize;
    
    // 三步反转法
    reverse(nums, 0, numsSize - 1);      // 反转整个数组
    reverse(nums, 0, k - 1);            // 反转前k个元素
    reverse(nums, k, numsSize - 1);     // 反转后n-k个元素
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 轮转数组

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：将数组中的元素向右轮转 k 个位置，实现循环移位

📥 **输入输出**：
- **输入**：
  - `nums`: 指向整型数组的指针
  - `numsSize`: 数组的长度
  - `k`: 轮转的步数（非负数）
- **输出**：无返回值，直接在原数组上进行修改

---

## 2️⃣ 实现原理

💡 **核心思路**：使用三步反转法（三次数组反转）实现数组轮转

📋 **实现步骤**：
1. 首先对 k 取模，处理 k 大于数组长度的情况
2. 反转整个数组
3. 反转前 k 个元素
4. 反转后 n-k 个元素

---

## 3️⃣ 关键点解析

原始思路是模拟轮转过程，每次将数组整体右移一位，重复k次。这种方法的时间复杂度是O(n×k)，当k很大时效率较低。而最优解使用三步反转法，时间复杂度仅为O(n)。

### 🎯 代码技巧
- 使用取模运算 `k = k % numsSize` 优化轮转次数
- 采用双指针法实现数组反转，空间复杂度O(1)
- 三步反转法的巧妙应用，将轮转问题转化为反转问题

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要实现数组循环移位操作
- 对空间复杂度有严格要求的场景
- 需要原地修改数组的场合

### ⚠️ 前提条件：
- 数组不能为空指针
- 数组长度必须大于0
- k值必须为非负数

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n为数组长度，需要遍历数组常数次

- 💾 空间复杂度：O(1)，只使用了常数级别的额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- k等于0或数组长度的倍数时，数组保持不变
- 数组长度为1时，无论k为何值数组都保持不变
- k大于数组长度时，需要取模运算避免多余操作

### 💥 易错点：
- 忘记对k取模导致不必要的计算
- 反转时边界条件处理错误
- 混淆左转和右转的方向

## 7️⃣ 补充说明
### 为什么需要 k = k % numsSize 操作？🤔

**问题背景**

当 `k` 大于数组长度时，实际上会发生重复的轮转。这个操作是为了避免不必要的重复计算。

**举例说明**

假设我们有一个长度为 7 的数组：`[1,2,3,4,5,6,7]`

| k 值 | 实际效果 | 说明 |
|------|----------|------|
| k=3 | `[5,6,7,1,2,3,4]` | 轮转3步 |
| k=10 | `[5,6,7,1,2,3,4]` | 10 = 7+3，相当于轮转3步 |
| k=17 | `[5,6,7,1,2,3,4]` | 17 = 7×2+3，也相当于轮转3步 |

**数学原理**

对于长度为 `n` 的数组，轮转 `k` 步和轮转 `k % n` 步的效果完全相同。

这是因为：
- 轮转 `n` 步会让数组回到原始状态
- 所以轮转 `k` 步 = 轮转 `(k/n) × n + k%n` 步 = 轮转 `k%n` 步

**优化意义**

**性能优化**：避免不必要的重复轮转
- 如果没有取模，`k=1000000`时就要执行1000000次操作
- 取模后，只需要执行 `1000000%7 = 2` 次有效操作

**结果正确性**：确保算法在任何 k 值下都能正确工作

## 8⃣ 其他解法

### ✨ 环形替换法
```c
/**
 * @brief 使用环形替换法将数组中的元素向右轮转 k 个位置
 * 
 * @param nums 指向整型数组的指针
 * @param numsSize 数组的长度
 * @param k 轮转的步数（非负数）
 * 
 * @details 核心思想是将数组中每个元素直接放到轮转后的位置上。
 *          通过追踪元素的移动轨迹形成环形，每个元素只访问一次。
 *          
 *          算法流程：
 *          1. 从每个未访问的起始位置开始
 *          2. 沿着环形路径移动元素，直到回到起始位置
 *          3. 继续处理下一个环形，直到所有元素都被处理
 *          
 *          例如: nums = [1,2,3,4,5,6], k = 2
 *          形成两个环形: 1->3->5->1 和 2->4->6->2
 *          
 *          时间复杂度: O(n)，空间复杂度: O(1)
 */
void rotate(int* nums, int numsSize, int k) {
    // 处理k大于数组长度的情况，避免不必要的轮转
    k = k % numsSize;
    
    // 记录已处理的元素个数
    int count = 0;
    
    // 遍历所有可能的起始位置，直到所有元素都被处理
    for (int start = 0; count < numsSize; start++) {
        int current = start;    // 当前处理的位置
        int prev = nums[start]; // 需要放置到下一个位置的值
        
        // 沿着环形路径移动元素，直到回到起始位置
        do {
            int next = (current + k) % numsSize;  // 计算下一个位置
            int temp = nums[next];                // 保存下一个位置的原始值
            nums[next] = prev;                    // 将prev放到下一个位置
            prev = temp;                          // 更新prev为下一个位置的原始值
            current = next;                       // 移动到下一个位置
            count++;                              // 增加已处理元素计数
        } while (start != current);  // 当回到起始位置时结束当前环形处理
    }
}
```

### ✨ 使用额外数组
```c
/**
 * @brief 使用额外数组法将数组中的元素向右轮转 k 个位置
 * 
 * @param nums 指向整型数组的指针
 * @param numsSize 数组的长度
 * @param k 轮转的步数（非负数）
 * 
 * @details 核心思想是创建一个新数组，将原数组中每个元素直接放到轮转后的位置上，
 *          然后将新数组的内容复制回原数组。
 *          
 *          算法流程：
 *          1. 创建与原数组等长的新数组
 *          2. 遍历原数组，将每个元素 nums[i] 放到新数组的 (i + k) % n 位置
 *          3. 将新数组的内容复制回原数组
 *          
 *          例如: nums = [1,2,3,4,5,6,7], k = 3
 *          nums[0]=1 放到 newArr[(0+3)%7] = newArr[3] 的位置
 *          nums[1]=2 放到 newArr[(1+3)%7] = newArr[4] 的位置
 *          ...以此类推
 *          
 *          时间复杂度: O(n)，空间复杂度: O(n)
 */
void rotate(int* nums, int numsSize, int k) {
    int newArr[numsSize];     // 创建与原数组等长的新数组
    k = k % numsSize;         // 处理k大于数组长度的情况
    
    // 将元素放到新位置
    for (int i = 0; i < numsSize; i++) {
        // 将nums[i]放到新数组的(i + k) % numsSize位置（轮转后的位置）
        newArr[(i + k) % numsSize] = nums[i];
    }
    
    // 复制回原数组
    for (int i = 0; i < numsSize; i++) {
        nums[i] = newArr[i];
    }
}
```
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-02-LeetCode122.mdx===
---FRONTMATTER---
slug: LeetCode122
title: 买卖股票的最佳时机Ⅱ
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——122题](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 计算股票买卖的最大利润（可多次交易）
 * 
 * 算法思路：贪心策略，收集所有上涨段的利润
 * 核心思想：只要明天价格比今天高，就相当于今天买入明天卖出
 * 
 * @param prices 股票价格数组，prices[i]表示第i天的股票价格
 * @param pricesSize 数组长度，表示股票交易天数
 * @return 能获得的最大利润
 * 
 * 时间复杂度：O(n)，只需要遍历一次价格数组
 * 空间复杂度：O(1)，只使用常数额外空间
 * 
 * 示例：
 * prices = [7,1,5,3,6,4]
 * 第2天买入(1)，第3天卖出(5)：利润4
 * 第4天买入(3)，第5天卖出(6)：利润3
 * 总利润：7
 */
int maxProfit(int* prices, int pricesSize) {
    int profit = 0;  // 累计总利润
    
    // 从第2天开始遍历，比较相邻两天的价格
    for (int i = 1; i < pricesSize; i++) {
        // 如果今天价格高于昨天价格，说明可以获利
        // 相当于昨天买入今天卖出
        if (prices[i] > prices[i-1]) {
            profit += prices[i] - prices[i-1];  // 累加利润
        }
    }
    
    return profit;  // 返回最大利润
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 买卖股票的最佳时机Ⅱ

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定股票每天的价格，计算在可以多次买卖的条件下能获得的最大利润，任何时候最多只能持有一股股票

📥 **输入输出**：
- **输入**：int* prices（股票价格数组），int pricesSize（数组长度）
- **输出**：int（能获得的最大利润）

---

## 2️⃣ 实现原理

💡 **核心思路**：贪心算法，收集所有上涨段的利润。只要相邻两天价格上涨就进行交易，相当于今天买入明天卖出

📋 **实现步骤**：
1. 初始化利润为0
2. 从第2天开始遍历价格数组
3. 比较当天与前一天的价格
4. 如果当天价格更高，则将差值加入总利润
5. 返回累计利润

---

## 3️⃣ 关键点解析

原始思路是寻找局部最优的买卖点，考虑各种复杂的买卖策略组合，但最优解采用贪心策略，将问题简化为收集所有上涨利润。

### 🎯 代码技巧
- 利用数学中的望远镜求和原理，将多次交易等价于最优的一次性交易
- 通过比较相邻元素差值来模拟交易决策
- 避免实际模拟买卖过程，直接计算理论最大收益

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要计算可多次交易情况下的最大理论收益
- 股票价格趋势分析
- 算法教学中的贪心策略示例

### ⚠️ 前提条件：
- 可以同一天买入并卖出
- 每次交易只持有一股股票
- 不考虑交易成本和税收

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，只需要遍历一次价格数组

- 💾 空间复杂度：O(1)，只使用常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空数组或只有一个元素：返回0
- 价格持续下跌：返回0
- 价格持续上涨：返回首尾差值

### 💥 易错点：
- 误以为需要模拟真实的买卖过程
- 混淆与只能买卖一次的股票问题
- 忽略算法基于"预知未来"的假设条件
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-03-Algorithm.mdx===
---FRONTMATTER---
slug: Algorithm
title: 算法总结
authors: eurekaX
tags: [算法]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';

### <B2>记录做力扣面试经典150过程中遇到的算法🤔</B2>

<!-- truncate -->


## 贪心算法

### 🎯 识别贪心算法适用场景的技巧

#### 1. 问题特征识别
以下特征通常表明可以使用贪心算法：

✅ **最优子结构**：问题的最优解包含子问题的最优解
✅ **贪心选择性质**：局部最优选择能导致全局最优
✅ **无后效性**：当前选择不会影响之前的状态
✅ **求极值问题**：最大值、最小值、最优解等

#### 2. 常见问题类型
以下类型问题经常使用贪心策略：

🔢 **选择问题**：活动选择、区间调度
💰 **优化问题**：背包问题变种、股票买卖
🗺️ **图论问题**：最小生成树、最短路径
📊 **数据处理**：哈夫曼编码、任务调度
🎯 **游戏策略**：跳跃游戏、分配问题

### 🎯 如何快速判断的技巧

#### 技巧1：问自己几个关键问题
1. 是否可以通过一系列局部选择得到全局最优解？
2. 当前的最优选择是否会影响后续的决策空间？
3. 如果每步都选当前最好的，最终结果是否最优？
4. 是否存在反例能证明贪心不成立？

#### 技巧2：看问题的关键词
出现这些关键词时考虑贪心：
- "最大"、"最小"、"最优"
- "尽可能"、"最多"、"最少"  
- "安排"、"调度"、"分配"
- "使得总...最大/最小"

### 🎯 如何设计贪心策略

#### 1. 确定贪心选择标准
关键步骤：
1. 明确每一步要做出什么选择
2. 确定衡量"好"选择的标准
3. 证明这个选择标准的正确性

#### 2. 举例分析
**股票买卖问题分析：**
- 问题：如何获得最大利润？
- 贪心选择：只要明天比今天贵，今天就买入明天卖出
- 选择标准：价格正增长就交易
- 正确性：所有正收益都 captured，负收益都避免

**跳跃游戏问题分析：**
- 问题：能否到达终点？
- 贪心选择：每到一个位置，尽可能扩展可达范围
- 选择标准：选择能让maxReach最大的策略
- 正确性：最大可达范围决定了能否到达终点

### 🎯 实战判断流程

#### 三步判断法：
Step 1: 问题分析
- 这是一个优化问题吗？(求最大/最小值)
- 是否可以分解为一系列选择？

Step 2: 贪心假设  
- 能否通过局部最优选择得到全局最优？
- 假设贪心策略，能否构造反例？

Step 3: 策略设计
- 明确每步的贪心选择是什么
- 确定如何衡量选择的好坏
- 验证算法正确性

### 🎯 常见贪心策略模板

#### 1. 选择类问题
```c
// 模板：按某种标准排序后贪心选择
sort(elements, compare_function);  // 首先按某种标准排序
for (each element) {               // 遍历每个元素
    if (can_select(element)) {     // 如果可以选择当前元素
        select(element);           // 就选择它
    }
}
```

#### 2. 扩展类问题
```c
// 模板：逐步扩展最优解
for (each step) {                           // 遍历每个决策步骤
    best_choice = find_best_local_choice(); // 在当前步骤中找到局部最优选择
    if (is_better(best_choice)) {           // 如果这个选择比当前解更好
        update_solution(best_choice);       // 就用这个选择更新当前最优解
    }
}
```

#### 3. 累积类问题
```c
// 模板：累积局部最优解
total_result = 0;                    // 初始化总结果为0
for (each sub_problem) {             // 遍历每个子问题
    local_optimal = solve_locally(); // 求解当前子问题的局部最优解
    total_result += local_optimal;   // 将局部最优解累加到总结果中
}
```

### 💡 实用建议
- 多练习经典贪心问题：活动选择、背包问题、霍夫曼编码等
- 学会构造反例：如果想不出反例证明贪心成立
- 关注边界条件：贪心算法常在边界处出错
- 证明贪心选择性质：虽然面试不要求严格证明，但思路要清晰

记住：贪心算法的关键在于识别问题的贪心性质和设计正确的贪心策略，这需要大量的练习和经验积累。

---
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-03-LearnEng.mdx===
---FRONTMATTER---
slug: LearnEng
title: 英语小结
authors: eurekaX
tags: [English]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';

### <B2>记录学习英语中遇到的令人感到疑惑的表达方法🤔</B2>

<!-- truncate -->



## **"Put one's foot down"**
### **含义**
- **核心意义**：坚决反对某事或制止某种行为，态度强硬不容妥协。  
- **隐含权威**：通常由家长、上司、负责人等具有决策权的人使用。  
- **情感色彩**：可能带有“后悔未早制止”（过去时）或“现在必须阻止”（现在时）的意味。  

### **使用实例**
### 1. **制止不当行为**  
- *The teacher **put her foot down** when students tried to cheat on the exam.*  
  （学生试图作弊时，老师坚决制止。）  
- *I had to **put my foot down** when my roommate kept borrowing my clothes without asking.*  
  （室友未经允许一直借我衣服，我不得不明确拒绝。）  

### 2. **维护规则或底线**  
- *The CEO **put his foot down** and banned all overtime work.*  
  （CEO 强硬禁止所有加班。）  
- *Mom **put her foot down**: no video games until homework is done.*  
  （妈妈立下规矩：作业做完前不准打游戏。）  

### 3. **表达后悔**  
- *I **should have put my foot down** when they suggested cutting corners.*  
  （他们提议偷工减料时，我本该坚决反对的。）  

### **常见场景**
- **家庭场景**：父母管教孩子。  
- **职场场景**：上司制止违规行为。  
- **人际关系**：拒绝他人越界请求。  

### **助记技巧**
1. **动作联想**：想象用力踩下刹车（"put foot down"）→ **强行停止**某事。  
2. **对比习语**：  
   - ✅ **"Put one's foot down"** = 制止（反对）。  
   - ❌ **"Stand one's ground"** = 坚持立场（不一定是制止）。  
3. **中文对应**：类似“拍板叫停”或“亮明底线”。  

### **⚠️ 注意事项**
- **不用于支持**：仅表示“反对/制止”，不可替换为支持性语境。  
- **语气强硬**：需根据关系谨慎使用，避免显得专横。

---
## **"Throw someone under the bus"**

### **含义**
- **核心意义**：为了自身利益牺牲或背叛他人，通常是在关键时刻推卸责任或出卖同伴
- **隐含意味**：带有背叛、不忠诚、自私自利的负面含义
- **使用场景**：多用于政治、职场或团队合作中描述背叛行为

### **使用实例**
### 1. **职场背叛**
- *The manager threw his assistant under the bus when the project failed.*
  （项目失败时，经理把责任都推给了助理）
- *Don't trust him - he'll throw you under the bus to save his own job.*
  （别相信他，他会为了保住自己的工作而出卖你）

### 2. **政治场合**
- *The senator threw his colleague under the bus to distance himself from the scandal.*
  （参议员为了与丑闻撇清关系而出卖了他的同事）
- *In the debate, the candidate kept trying to throw her opponent under the bus.*
  （辩论中，候选人不断试图把责任推给对手）

### 3. **日常人际关系**
- *I thought we were friends, but she threw me under the bus when the teacher asked who broke the window.*
  （我以为我们是朋友，但老师问谁打破窗户时她出卖了我）
- *Real friends don't throw each other under the bus when things go wrong.*
  （真正的朋友不会在出问题时互相出卖）

### **常见场景**
- **职场竞争**：推卸责任，嫁祸同事
- **政治斗争**：牺牲盟友保全自己
- **团队合作**：关键时刻背叛队友
- **朋友关系**：为自保而出卖朋友

### **助记技巧**
1. **形象联想**：想象把别人推到行驶的公交车下→极端自私的背叛行为
2. **对比习语**：
   - ✅ "Throw someone under the bus" = 为自保而背叛
   - ❌ "Pass the buck" = 推卸责任（不一定涉及背叛）
3. **中文对应**：类似"过河拆桥"、"出卖"、"甩锅"

### **⚠️ 注意事项**
- **强烈贬义**：使用时通常带有强烈谴责意味
- **程度严重**：比一般的推卸责任更恶劣，涉及主动背叛
- **常见变体**：
  - "Throw [某人] under the bus"（具体对象）
  - "Get thrown under the bus"（被背叛的被动形式）

### **延伸学习**
- **同义表达**：
  - "Stab someone in the back"（背后捅刀）
  - "Sell someone out"（出卖）
- **反义表达**：
  - "Have someone's back"（支持某人）
  - "Stand by someone"（力挺某人）

---
## **"Gaslight someone"**

### **含义**
- **核心意义**：通过心理操纵使某人质疑自己的记忆、感知或理智
- **词源背景**：源自1944年电影《煤气灯下》(Gaslight)，片中丈夫通过操纵煤气灯光使妻子怀疑自己
- **心理影响**：属于情感虐待的一种形式，会导致受害者产生自我怀疑

### **使用实例**
### 1. **情感操控**
- *He kept gaslighting me by denying things he had clearly said before.*
  （他通过否认自己说过的话来操控我）
- *Don't let him gaslight you into thinking you're overreacting.*
  （别让他操控你觉得是你反应过度）

### 2. **职场PUA**
- *My boss gaslights the team by constantly changing deadlines and then claiming we misunderstood.*
  （老板通过不断改变截止日期然后说是我们理解错误来操控团队）
- *That's classic gaslighting - first she gives unclear instructions, then blames us for not following them.*
  （典型的心理操控 - 她先给出模糊指示，然后责怪我们没有遵守）

### 3. **家庭关系**
- *Growing up with a gaslighting parent made me doubt my own judgment.*
  （在有操控欲的父母身边长大让我怀疑自己的判断力）
- *She realized her partner had been gaslighting her when she started keeping records of their conversations.*
  （当她开始记录他们的对话时，才意识到伴侣一直在操控她）

### **常见场景**
- **亲密关系**：伴侣间的心理操控
- **职场环境**：上司对下属的精神控制
- **家庭关系**：父母对子女的情感虐待
- **政治宣传**：通过虚假信息操控公众认知

### **助记技巧**
1. **电影联想**：记住源自《煤气灯下》电影情节
2. **行为特征**：
   - 否认事实
   - 扭曲现实
   - 制造困惑
3. **中文对应**：类似"心理操控"、"精神控制"、"洗脑"

### **⚠️ 注意事项**
- **严重性**：属于心理虐待，比简单的说谎更恶劣
- **渐进过程**：通常是长期、渐进的行为模式
- **受害者表现**：
  - 经常道歉
  - 过度自我怀疑
  - 需要反复确认自己的记忆

### **延伸学习**
- **相关概念**：
  - "Emotional abuse"（情感虐待）
  - "Psychological manipulation"（心理操纵）
- **应对方式**：
  - "Keep a paper trail"（保留书面记录）
  - "Trust your gut"（相信自己的直觉）
  - "Seek external validation"（寻求外部确认）

### **辨别特征**
1. 否认明明发生过的事情
2. 将问题归咎于你的"错误记忆"
3. 让你觉得自己总是反应过度
4. 通过小事逐渐瓦解你的自信

---
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-03-LeetCode.mdx===
---FRONTMATTER---
slug: LeetCodeExample
title: 力扣做题总结模板
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——X题](https://leetcode.cn/studyplan/top-interview-150/ "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
code
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 [题目名称]

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：[简要描述题目要解决的核心问题]

📥 **输入输出**：
- **输入**：[列出主要输入参数及其含义]
- **输出**：[描述函数返回值及副作用]

---

## 2️⃣ 实现原理

💡 **核心思路**：[概括解决该问题的主要算法思想]

📋 **实现步骤**：
1. [步骤1]
2. [步骤2]
3. [步骤3]
4. [步骤4]

---

## 3️⃣ 关键点解析

给出原始做题思路并比较与最优解区别（可选）

### 🎯 代码技巧
- [技巧1]
- [技巧2]
- [技巧3]

## 4️⃣ 使用场景

### ✅ 适用情况：
- [场景1]
- [场景2]
- [场景3]

### ⚠️ 前提条件：
- [条件1]
- [条件2]

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：[时间复杂度分析]

- 💾 空间复杂度：[空间复杂度分析]

## 6️⃣ 注意事项

### 🚩 边界情况：
- [边界情况1]
- [边界情况2]
- [边界情况3]

### 💥 易错点：
- [易错点1]
- [易错点2]
- [易错点3]
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-03-LeetCode45.mdx===
---FRONTMATTER---
slug: LeetCode45
title: 跳跃游戏II
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——45题](https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 计算跳跃游戏的最小跳跃次数
 * 此函数只关心最小跳跃次数，而不关心真实的跳跃路径
 * @param nums 非负整数数组，每个元素代表在该位置可以跳跃的最大长度
 * @param numsSize 数组长度
 * @return 到达最后一个下标的最小跳跃次数
 */
int jump(int* nums, int numsSize) {
    // 边界情况：数组长度小于等于1，不需要跳跃
    if (numsSize <= 1) return 0;
    
    int jumps = 0;          // 记录跳跃次数
    int currentEnd = 0;     // 当前这次跳跃能到达的最远边界，但并非真要跳到此边界
    int farthest = 0;       // 目前为止能到达的最远位置
    
    // 只需要遍历到 numsSize-2，因为题目保证能到达最后位置
    for (int i = 0; i < numsSize - 1; i++) {
        // 计算从位置i能跳到的最远位置，并更新全局最远位置
        int currentFarthest = i + nums[i];
        farthest = (farthest > currentFarthest) ? farthest : currentFarthest;
        
        // 如果到达当前跳跃的边界，必须进行下一次跳跃
        if (i == currentEnd) {
            jumps++;                // 增加跳跃次数
            currentEnd = farthest;  // 更新下一次跳跃的边界
        }
    }
    
    return jumps;  // 返回最小跳跃次数
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 跳跃游戏 II

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定一个数组，数组中每个元素表示在该位置可以跳跃的最大长度，求到达最后一个位置的最小跳跃次数。

📥 **输入输出**：
- **输入**：int* nums（非负整数数组），int numsSize（数组长度）
- **输出**：到达最后一个下标的最小跳跃次数

---

## 2️⃣ 实现原理

💡 **核心思路**：使用贪心算法，在每次必须跳跃时选择能跳得最远的位置，从而最小化跳跃次数。

📋 **实现步骤**：
1. 维护三个变量：跳跃次数、当前跳跃边界、全局最远位置
2. 遍历数组（除最后一个元素），不断更新能到达的最远位置
3. 当到达当前跳跃边界时，必须进行下一次跳跃
4. 更新跳跃次数和下一次跳跃的边界

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用贪心策略：在必须跳跃时选择最优方案
- 双指针思想：currentEnd标记当前跳跃边界，farthest记录最远可达位置
- 提前终止：只需遍历到倒数第二个元素

## 4️⃣ 使用场景

### ✅ 适用情况：
- 求解最小跳跃次数问题
- 数组元素表示跳跃能力的场景
- 需要优化路径选择的问题

### ⚠️ 前提条件：
- 题目保证可以到达最后一个位置
- 数组元素为非负整数

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，只需遍历一次数组
- 💾 空间复杂度：O(1)，只使用常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组长度为1：不需要跳跃，返回0
- 数组长度为2：最多只需1次跳跃
- 第一个元素为0：根据题目保证，这种情况不会出现

### 💥 易错点：
- 循环只需要到 numsSize-1，否则可能多计算一次跳跃
- 必须在到达边界时才增加跳跃次数
- 更新边界和最远位置的顺序不能颠倒

## 7⃣ 补充说明

### 🎯 关键洞察
- `jump` 变量更新的位置 ≠ 实际跳跃发生的物理位置
- `jump` 变量表示的是"必须做出跳跃决策"的次数

### 📊 算法执行逻辑
**例：nums = [2, 3, 1, 1, 4]**

**真实跳跃路径**：0 → 1 → 4

**算法计数逻辑**：
1. **位置0**：确定第1次跳跃覆盖范围(0-2)
2. **位置1,2**：探索发现能跳到位置4
3. **位置2(边界)**：必须决策，`jump++`，确定下次跳跃范围

### 🎯 算法本质

这是**批量决策**过程：
- **第1次决策**(jump=1)：站在起点，确定覆盖范围0-2
- **第2次决策**(jump=2)：在范围内探索，发现能到位置4

**实际执行**：位置0 → 位置1 → 位置4  
**算法计数**：在必须决策时计数，非实际起跳时

### 💡 设计优势
- **提前规划**：必须跳跃前已知最优选择
- **批量处理**：一次决策覆盖一个区间  
- **贪心最优**：每次都选能跳最远的方案

✅ `jump` 变量容易误导人，它记录的是"决策次数"而非"起跳时刻"。

## 8⃣ 惑之未解？

### 🤔 问题思考
为什么for循环的判断条件是 `i < numsSize - 1` 而不是 `i < numsSize`？

如果使用 `i < numsSize`，在某些情况下（如 `[2,3,1,1,4]`），当能够跳转到最后位置时，`jump` 会多加1，导致结果错误。

### 🧐 深入分析
经过再次思考，这些变量 `jump`、`currentEnd`、`farthest`、`currentFarthest` 都是根据数组下标及其对应数值来决定是否更新的。

**关键理解点**：
- `jump` 的含义是"需要跳跃jump次才能到达数组最后一个元素"
- 如果循环条件设定为 `i < numsSize`，for循环会遍历到数组的最后一个位置
- 但当我们处理到倒数第二个位置时，已经收集了足够的信息来确定最少跳跃次数
- 继续处理最后一个位置是不必要的，甚至可能导致错误结果

## 9⃣ 举一反一？😂

**最小跳跃次数 + 真实跳跃路径**
```c
/**
 * 计算跳跃游戏的最小跳跃次数和路径
 * @param nums 非负整数数组，每个元素代表在该位置可以跳跃的最大长度
 * @param numsSize 数组长度
 * @param path 用于存储跳跃路径的数组
 * @param pathSize 用于返回路径长度的指针
 * @return 到达最后一个下标的最小跳跃次数
 */
int jumpWithPath(int* nums, int numsSize, int* path, int* pathSize) {
    // 边界情况：数组长度小于等于1，不需要跳跃
    if (numsSize <= 1) {
        *pathSize = 0;
        return 0;
    }
    
    int jumps = 0;          // 记录跳跃次数
    int currentEnd = 0;     // 当前这次跳跃能到达的最远边界
    int farthest = 0;       // 目前为止能到达的最远位置
    int farthestIndex = 0;  // 能到达最远位置的索引
    
    // 记录路径
    path[0] = 0;            // 起点总是位置0
    int pathIndex = 1;
    
    // 只需要遍历到 numsSize-2，因为题目保证能到达最后位置
    for (int i = 0; i < numsSize - 1; i++) {
        // 计算从位置i能跳到的最远位置
        int currentFarthest = i + nums[i];
        
        // 更新全局最远位置和对应的索引
        if (currentFarthest > farthest) {
            farthest = currentFarthest;
            farthestIndex = i;
        }
        
        // 如果到达当前跳跃的边界，必须进行下一次跳跃
        if (i == currentEnd) {
            jumps++;                // 增加跳跃次数
            currentEnd = farthest;  // 更新下一次跳跃的边界
            path[pathIndex++] = farthestIndex;  // 记录跳跃位置
        }
    }
    
    // 添加终点
    path[pathIndex++] = numsSize - 1;
    *pathSize = pathIndex;
    
    return jumps;  // 返回最小跳跃次数
}

// 使用示例
/*
int main() {
    int nums[] = {2, 3, 1, 1, 4};
    int numsSize = 5;
    int path[100];
    int pathSize;
    
    int jumps = jumpWithPath(nums, numsSize, path, &pathSize);
    
    printf("最小跳跃次数: %d\n", jumps);
    printf("跳跃路径: ");
    for (int i = 0; i < pathSize; i++) {
        printf("%d ", path[i]);
    }
    printf("\n");
    
    return 0;
}
*/
```
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-03-LeetCode55.mdx===
---FRONTMATTER---
slug: LeetCode55
title: 跳跃游戏
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——55题](https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 判断是否能跳到最后一个下标
 * @param nums 非负整数数组，每个元素代表在该位置可以跳跃的最大长度
 * @param numsSize 数组长度
 * @return 如果能到达最后一个下标返回true，否则返回false
 */
bool canJump(int* nums, int numsSize) {
    int maxReach = 0; // 记录当前能到达的最远位置下标
    
    // 遍历数组中的每个位置
    for (int i = 0; i < numsSize; i++) {
        // 如果当前位置i超出了当前能到达的最远位置，说明无法到达位置i
        if (i > maxReach) {
            return false;
        }
        
        // 计算从当前位置i能到达的最远位置
        int currentReach = i + nums[i];
        
        // 更新全局能到达的最远位置
        if (currentReach > maxReach) {
            maxReach = currentReach;
        }
        
        // 如果已经能到达或超过最后一个位置(numsSize-1)，直接返回true
        if (maxReach >= numsSize - 1) {
            return true;
        }
    }
    
    // 必须保留这行，即使逻辑上不会执行到
    return maxReach >= numsSize - 1;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 跳跃游戏

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：判断是否能从数组的第一个位置跳跃到最后一个位置，数组中每个元素表示在该位置可以跳跃的最大长度

📥 **输入输出**：
- **输入**：int* nums（非负整数数组），int numsSize（数组长度）
- **输出**：bool类型，如果能到达最后一个下标返回true，否则返回false

---

## 2️⃣ 实现原理

💡 **核心思路**：使用贪心算法，维护一个变量记录当前能到达的最远位置，遍历数组不断更新最远可达位置

📋 **实现步骤**：
1. 初始化maxReach为0，表示当前能到达的最远位置下标
2. 遍历数组中的每个位置i
3. 如果当前位置i超出maxReach，说明无法到达，返回false
4. 计算从位置i能到达的最远位置(i + nums[i])，并更新maxReach
5. 如果maxReach已经能到达或超过最后一个位置，直接返回true
6. 遍历结束后检查maxReach是否能到达最后一个下标

---

## 3️⃣ 关键点解析

原始思路是通过BFS方式探索所有可能路径，逐层扩展可能的跳跃路径，但这种方法时间复杂度较高。最优解使用贪心算法，通过维护全局最远可达位置来判断，避免了路径探索和重复计算。

### 🎯 代码技巧
- 使用maxReach变量记录全局最远可达位置，避免重复计算
- 提前终止优化：一旦能到达终点就立即返回，无需继续遍历
- 边界检查：在遍历过程中实时检查是否能到达当前位置

## 4️⃣ 使用场景

### ✅ 适用情况：
- 判断能否通过跳跃到达目标位置
- 游戏中角色移动范围判断
- 资源分配问题中判断能否覆盖所有节点

### ⚠️ 前提条件：
- 数组元素为非负整数
- 数组长度至少为1
- 从第一个位置开始跳跃

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n是数组长度，只需遍历一次数组

- 💾 空间复杂度：O(1)，只使用了常数级别的额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组只有一个元素的情况
- 第一个元素为0的情况
- 中间存在0元素的情况

### 💥 易错点：
- 忘记检查当前位置是否可达
- 没有及时更新最远可达位置
- 忽略提前终止条件导致效率降低
- 函数末尾没有添加 return 语句

## 7️⃣ 补充说明
**为什么 `i > maxReach` 就能判断无法到达最后位置**

### 🎯 核心理解
`maxReach` 表示截至目前能到达的最远位置。如果 `i > maxReach`，说明：
- 位置 `i` 不可达
- 无法利用位置 `i` 的跳跃能力
- 更不可能到达最后位置

### 📝 举例说明
假设 `nums = [2, 0, 0, 3, 4]`：
- `i = 0`: `maxReach = 2`，能到达位置0,1,2
- `i = 1,2`: 均 `<= maxReach`，可达
- `i = 3`: `3 > maxReach(2)`，**不可达**

### 🔄 关键原理
我们只能从位置0开始连续向前跳跃，不能跳过中间位置：
- 要到达位置 `i`，必须先到达 `0,1,2,...,i-1` 中某位置
- 如果 `maxReach < i`，说明前面所有位置都无法触及位置 `i`
- 因此位置 `i` 及其后面所有位置都不可达
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-04-LeetCode274.mdx===
---FRONTMATTER---
slug: LeetCode274
title: H 指数
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——274题](https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 计算研究者的h指数
 * 
 * h指数的定义：研究者至少发表了h篇论文，并且至少有h篇论文被引用次数大于等于h
 * 
 * @param citations 整数数组，citations[i]表示第i篇论文的引用次数
 * @param citationsSize 数组citations的长度，即论文总数
 * @return 返回该研究者的h指数
 * 
 * 算法思路：
 * 1. 使用计数排序的思想，统计每个引用次数的论文数量
 * 2. 从高到低遍历可能的h值，找到满足条件的最大h值
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 */
int hIndex(int* citations, int citationsSize) {
    // 创建计数数组，大小为 citationsSize + 1
    // count[i] 表示引用次数为i的论文数量
    int* count = (int*)calloc(citationsSize + 1, sizeof(int));
    
    // 统计每个引用次数的论文数量
    // 如果引用次数超过论文总数，则统一计入count[citationsSize]
    for (int i = 0; i < citationsSize; i++) {
        if (citations[i] >= citationsSize) {
            count[citationsSize]++;  // 引用次数≥n的论文都计入最高计数位
        } else {
            count[citations[i]]++;   // 正常计数
        }
    }
    
    // 从后往前累加，计算引用次数大于等于i的论文数量
    // sum表示引用次数≥i的论文总数
    int sum = 0;
    for (int i = citationsSize; i >= 0; i--) {
        sum += count[i];  // 累加引用次数≥i的论文数量
        if (sum >= i) {   // 如果引用次数≥i的论文数量≥i，则h指数为i
            free(count);
            return i;
        }
    }
    
    free(count);
    return 0;  // 如果没有找到有效的h指数，返回0
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 H 指数

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：根据给定的论文引用次数数组，计算研究者的h指数。h指数是指研究者至少发表了h篇论文，且这h篇论文每篇都被引用至少h次。

📥 **输入输出**：
- **输入**：`int* citations`（论文引用次数数组），`int citationsSize`（论文总数）
- **输出**：返回h指数值

---

## 2️⃣ 实现原理

💡 **核心思路**：使用计数排序的思想，统计每个引用次数的论文数量，然后从高到低查找满足条件的最大h值。

📋 **实现步骤**：
1. 创建大小为`citationsSize + 1`的计数数组，用于统计每个引用次数的论文数量
2. 遍历引用数组，将引用次数超过`citationsSize`的论文统一计入最高计数位
3. 从后往前遍历计数数组，累加引用次数大于等于当前索引的论文总数
4. 当累加和大于等于当前索引时，该索引即为最大的h指数

---

## 3️⃣ 关键点解析

原始思路是遍历每个可能的h值并统计满足条件的论文数量，时间复杂度为O(n²)。最优解使用计数排序思想，将时间复杂度优化到O(n)。

### 🎯 代码技巧
- 计数排序优化：利用引用次数的有限范围特性
- 边界处理：将引用次数超过n的论文统一处理
- 逆序累加：从最大可能的h值开始查找，确保找到最大值

## 4️⃣ 使用场景

### ✅ 适用情况：
- 计算学术评价指标
- 统计分析场景
- 需要评估"数量与质量"综合指标的场景

### ⚠️ 前提条件：
- 输入数组不为空
- 引用次数为非负整数

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，需要遍历数组两次

- 💾 空间复杂度：O(n)，需要额外的计数数组

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空数组或只有一个元素
- 所有论文引用次数都为0
- 所有论文引用次数都很大

### 💥 易错点：
- 混淆h指数的定义，误以为需要恰好h篇论文引用h次
- 忘记释放动态分配的内存
- 边界条件处理不当，如h值可能为0的情况

## 7⃣ 补充说明

### H 指数解释

假设某研究者发表了 5 篇论文，引用次数分别为：`[3, 0, 6, 1, 5]`

我们要找最大的 `h`，使得至少有 h 篇论文被引用了至少 `h` 次。

尝试几个 `h` 值：

- h = 0：0 篇论文引用 ≥ 0 → 成立（但我们要找最大的 h）
- h = 1：至少 1 篇论文引用 ≥ 1 → 成立（有 4 篇）
- h = 2：至少 2 篇论文引用 ≥ 2 → 成立（有 3 篇）
- h = 3：至少 3 篇论文引用 ≥ 3 → 成立（有 3 篇）
- h = 4：至少 4 篇论文引用 ≥ 4 → 不成立（只有 2 篇）
- h = 5：至少 5 篇论文引用 ≥ 5 → 不成立（只有 2 篇）

所以 h 指数是 3。

### h指数计算示例详解

例子：`citations = [3, 0, 6, 1, 5]`

论文引用次数数组为 `[3, 0, 6, 1, 5]`，共5篇论文。

### 第一步：初始化计数数组

```c
int* count = (int*)calloc(citationsSize + 1, sizeof(int));
```
创建一个长度为 5 + 1 = 6 的数组 count，所有元素初始为 0：
```c
count = [0, 0, 0, 0, 0, 0]
索引:    0  1  2  3  4  5
```

**calloc与malloc的区别**
- `malloc`: 只分配内存，不初始化内容（内存中可能包含随机数据）
- `calloc`: 分配内存后会将所有字节初始化为0

**calloc函数原型：**
```c
void* calloc(size_t num, size_t size);
```

### 第二步：统计每个引用次数的论文数量
```c
for (int i = 0; i < citationsSize; i++) {
    if (citations[i] >= citationsSize) {
        count[citationsSize]++;
    } else {
        count[citations[i]]++;
    }
}
```

逐个处理每篇论文的引用次数：

- `citations[0]` = `3` → `count[3]++` → `count` = `[0, 0, 0, 1, 0, 0]`
- `citations[1]` = `0` → `count[0]++` → `count` = `[1, 0, 0, 1, 0, 0]`
- `citations[2]` = `6` → `6` >= `5` → `count[5]++` → `count` = `[1, 0, 0, 1, 0, 1]`
- `citations[3]` = `1` → `count[1]++` → `count` = `[1, 1, 0, 1, 0, 1]`
- `citations[4]` = `5` → `count[5]++` → `count` = `[1, 1, 0, 1, 0, 2]`
最终 count 数组为：

```c
count = [1, 1, 0, 1, 0, 2]
索引:    0  1  2  3  4  5
```

这表示：

- 引用次数为 0 的论文有 1 篇
- 引用次数为 1 的论文有 1 篇
- 引用次数为 2 的论文有 0 篇
- 引用次数为 3 的论文有 1 篇
- 引用次数为 4 的论文有 0 篇
- 引用次数 ≥ 5 的论文有 2 篇

### 第三步：从后往前累加，找最大的 h
```c
int sum = 0;
for (int i = citationsSize; i >= 0; i--) {
    sum += count[i];
    if (sum >= i) {
        free(count);
        return i;
    }
}
```
从 `i = 5` 开始往下检查：

- i = 5:

`sum += count[5]` → `sum = 0 + 2 = 2`
- 判断 `sum >= i` → `2 >= 5`？ ❌ 不成立
- i = 4:

- `sum += count[4]` → `sum = 2 + 0 = 2`
- 判断 `sum >= i` → `2 >= 4`？ ❌ 不成立
- i = 3:

- `sum += count[3]` → `sum = 2 + 1 = 3`
- 判断 `sum >= i` → `3 >= 3`？ ✅ 成立！返回 3
结果
函数返回 `3`，这就是该研究者的 `h` 指数。

验证一下
引用次数数组：[3, 0, 6, 1, 5]

我们检查是否有至少 3 篇论文引用次数 ≥ 3：

- 论文1: 3 ≥ 3 ✅
- 论文2: 0 ≥ 3 ❌
- 论文3: 6 ≥ 3 ✅
- 论文4: 1 ≥ 3 ❌
- 论文5: 5 ≥ 3 ✅

有 3 篇论文满足条件，所以 h 指数确实是 3。

### 最初思路
惭愧，这题我最初没做出来，题目理解都是错的，上面的最优解自然是AI给，下面这个我最初的思路，经过AI完善逻辑后的代码：
```c
int hIndex(int* citations, int citationsSize) {
    int maxH = 0;
    
    // 尝试每个可能的h值（从0到citationsSize）
    for (int h = 0; h <= citationsSize; h++) {
        int count = 0;
        
        // 计算引用次数>=h的论文数量
        for (int i = 0; i < citationsSize; i++) {
            if (citations[i] >= h) {
                count++;
            }
        }
        
        // 如果引用次数>=h的论文数量>=h，则h是一个有效值
        if (count >= h) {
            if (h > maxH) {
                maxH = h;
            }
        }
    }
    
    return maxH;
}
```
### 对H指数计算算法的理解

**算法核心思路**

- **H指数定义**：有h篇论文至少被引用h次，其余论文引用次数不超过h次

- **关键观察**：H指数的取值范围是[0, n]，其中n是论文总数

**算法步骤解析**

**1.构建计数数组**

- 创建长度为 n+1 的数组 count

- count[i] 表示引用次数恰好为 i 的论文数量

- 对于引用次数超过 n 的论文，统一计入 count[n]

**2.统计引用次数分布**

- 遍历 citations 数组

- 对每个引用次数进行计数统计

**3.计算H指数**

- 从后向前遍历 count 数组

- 累计引用次数≥当前下标的文章数量

- 当累计数量≥当前下标时，该下标即为H指数

</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-05-LeetCode380.mdx===
---FRONTMATTER---
slug: LeetCode380
title: O(1)时间插入、删除和获取随机元素

authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——380题](https://leetcode.cn/problems/insert-delete-getrandom-o1/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 哈希表节点结构体
 * 用于存储元素值和其在数组中的索引位置
 */
typedef struct {
    int value;              // 元素值
    int index;              // 该元素在数组中的索引位置
    UT_hash_handle hh;      // uthash库所需的句柄
} HashItem;

/**
 * RandomizedSet结构体
 * 组合数组和哈希表实现O(1)时间复杂度的插入、删除和随机获取操作
 */
typedef struct {
    int* nums;              // 存储实际元素的数组
    int numsSize;           // 当前数组中元素的个数
    HashItem* indices;      // 哈希表，存储元素值到索引的映射
} RandomizedSet;

/**
 * 创建RandomizedSet对象
 * @return 新创建的RandomizedSet对象指针
 */
RandomizedSet* randomizedSetCreate() {
    srand(time(NULL)); // 初始化随机数种子
    RandomizedSet* obj = (RandomizedSet*)malloc(sizeof(RandomizedSet));
    obj->nums = (int*)malloc(sizeof(int) * 200000); // 预分配足够空间
    obj->numsSize = 0;                              // 初始元素个数为0
    obj->indices = NULL;                            // 哈希表初始为空
    return obj;
}

/**
 * 向集合中插入元素
 * @param obj RandomizedSet对象指针
 * @param val 要插入的元素值
 * @return 插入成功返回true，元素已存在返回false
 */
bool randomizedSetInsert(RandomizedSet* obj, int val) {
    HashItem* tmp = NULL;
    // 在哈希表中查找元素是否已存在
    HASH_FIND_INT(obj->indices, &val, tmp);
    if (tmp != NULL) {
        return false; // 元素已存在，插入失败
    }
    
    // 将新元素添加到数组末尾
    obj->nums[obj->numsSize] = val;
    
    // 在哈希表中创建新节点，记录元素值和其在数组中的索引
    tmp = (HashItem*)malloc(sizeof(HashItem));
    tmp->value = val;
    tmp->index = obj->numsSize;
    HASH_ADD_INT(obj->indices, value, tmp);
    
    obj->numsSize++; // 数组元素个数增加
    return true;
}

/**
 * 从集合中删除元素
 * @param obj RandomizedSet对象指针
 * @param val 要删除的元素值
 * @return 删除成功返回true，元素不存在返回false
 */
bool randomizedSetRemove(RandomizedSet* obj, int val) {
    HashItem* tmp = NULL;
    // 在哈希表中查找要删除的元素
    HASH_FIND_INT(obj->indices, &val, tmp);
    if (tmp == NULL) {
        return false; // 元素不存在，删除失败
    }
    
    // 获取要删除元素在数组中的索引位置
    int index = tmp->index;
    
    // 获取数组中最后一个元素的值
    int lastValue = obj->nums[obj->numsSize - 1];
    // 将最后一个元素移动到要删除元素的位置（覆盖要删除的元素）
    obj->nums[index] = lastValue;
    
    // 更新最后一个元素在哈希表中的索引位置
    HashItem* lastItem = NULL;
    HASH_FIND_INT(obj->indices, &lastValue, lastItem);
    if (lastItem != NULL) {
        lastItem->index = index;
    }
    
    // 从哈希表中删除目标元素节点并释放内存
    HASH_DEL(obj->indices, tmp);
    free(tmp);
    
    obj->numsSize--; // 数组元素个数减少
    return true;
}

/**
 * 随机获取集合中的一个元素
 * @param obj RandomizedSet对象指针
 * @return 随机返回的元素值
 */
int randomizedSetGetRandom(RandomizedSet* obj) {
    // 使用随机数生成0到numsSize-1之间的索引
    int randomIndex = rand() % obj->numsSize;
    return obj->nums[randomIndex]; // 返回数组中对应位置的元素
}

/**
 * 释放RandomizedSet对象占用的内存
 * @param obj RandomizedSet对象指针
 */
void randomizedSetFree(RandomizedSet* obj) {
    // 遍历并释放哈希表中所有的节点内存
    HashItem* curr, *tmp;
    HASH_ITER(hh, obj->indices, curr, tmp) {
        HASH_DEL(obj->indices, curr);
        free(curr);
    }
    
    // 释放数组内存和对象本身内存
    free(obj->nums);
    free(obj);
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 O(1)时间插入、删除和获取随机元素

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：设计一个支持在平均O(1)时间复杂度下进行插入、删除和获取随机元素的数据结构

📥 **输入输出**：
- **输入**：
  - `val`：要插入或删除的整数值
  - 无参数：用于获取随机元素
- **输出**：
  - `insert`：插入成功返回true，失败返回false
  - `remove`：删除成功返回true，失败返回false
  - `getRandom`：返回集合中的任意一个元素
  - `create`：返回初始化的RandomizedSet对象
  - `free`：释放对象内存，无返回值

---

## 2️⃣ 实现原理

💡 **核心思路**：使用数组存储元素以支持O(1)随机访问，结合哈希表记录元素值到索引的映射以支持O(1)查找

📋 **实现步骤**：
1. 使用动态数组存储所有元素，支持通过索引O(1)访问任意元素
2. 使用哈希表维护元素值到数组索引的映射关系，支持O(1)查找元素
3. 插入时将元素添加到数组末尾并在哈希表中记录索引
4. 删除时将目标元素与数组末尾元素交换，更新哈希表并删除目标元素

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **数组+哈希表组合**：数组支持随机访问，哈希表支持快速查找
- **删除元素时的交换技巧**：将待删除元素与末尾元素交换，避免数组元素移动
- **双重数据结构同步维护**：同时维护数组和哈希表中元素信息的一致性

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要频繁进行插入、删除和随机访问操作的场景
- 对时间复杂度要求严格的随机集合应用
- 实现随机抽样或随机化算法的数据结构

### ⚠️ 前提条件：
- 元素值唯一，不支持重复元素
- 需要足够的内存空间维护数组和哈希表
- getRandom调用时集合必须非空

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：
  - insert: O(1) 平均时间复杂度
  - remove: O(1) 平均时间复杂度
  - getRandom: O(1) 时间复杂度
  - create: O(1) 时间复杂度
  - free: O(n) 时间复杂度，n为元素个数

- 💾 空间复杂度：O(n)，n为存储的元素个数，需要数组和哈希表存储

## 6️⃣ 注意事项

### 🚩 边界情况：
- 插入已存在的元素
- 删除不存在的元素
- 集合为空时调用getRandom（题目保证不会出现）
- 集合只有一个元素时的删除操作

### 💥 易错点：
- 删除元素后忘记更新交换元素在哈希表中的索引
- 内存释放不完整，忘记释放哈希表节点
- getRandom实现中随机数范围错误，应为[0, numsSize)

## 7️⃣ 惑之未解

这是力扣里面的最优解？但是我看不懂~😂

我现在打算先理解灵码给出的代码吧，之后再来探索下面的内容！🧐
暂时将下面代码全部删除，现在正在排查build文件夹过大的问题（发现不是这里的代码块导致的问题，日后可恢复！！！）
```c
/**
 * FNV哈希算法常量定义
 * FNV32_BASE: FNV-1哈希算法的基础值
 * FNV32_PRIME: FNV-1哈希算法的素数
 */
#define FNV32_BASE ((unsigned int) 0x811c9dc5)
#define FNV32_PRIME ((unsigned int) 0x01000193)

/**
 * FNV-1哈希算法实现
 * @param buf 要哈希的数据缓冲区
 * @param len 数据长度
 * @return 计算得到的哈希值
 */
static unsigned int memhash(const void *buf, size_t len)
{
	unsigned int hash = FNV32_BASE;
	unsigned char *ucbuf = (unsigned char *) buf;
	while (len--) {
		unsigned int c = *ucbuf++;
		hash = (hash * FNV32_PRIME) ^ c;
	}
	return hash;
}

/**
 * 哈希表项结构体
 * 用于链式解决哈希冲突
 */
struct hashmap_entry {
    unsigned int hash;                  // 存储预计算的哈希值
    struct hashmap_entry *next;         // 指向下一个冲突项的指针
};

/**
 * 初始化哈希表项
 * @param entry 要初始化的哈希表项
 * @param hash  预计算的哈希值
 */
static inline void hashmap_entry_init(struct hashmap_entry *entry, unsigned int hash) {
    entry->hash = hash;
    entry->next = NULL;
}

/**
 * 根据键值计算哈希值并初始化哈希表项
 */
#define __hashmap_entry_init(entry, key, len) hashmap_entry_init(entry, memhash(key, len))

/**
 * 哈希表项比较回调函数类型定义
 * @param entry     哈希表中的项
 * @param key       要比较的键
 * @param key_data  键数据
 * @return 相等返回0，不相等返回非0值
 */
typedef int (*hashmap_entry_cmp_callback)(struct hashmap_entry *entry, struct hashmap_entry *key, void *key_data);

/**
 * 哈希表结构体
 */
struct hashmap {
    struct hashmap_entry **table;       // 哈希桶数组
    unsigned int table_size;            // 哈希桶数组大小
    unsigned int private_size;          // 当前存储的元素数量
    hashmap_entry_cmp_callback cmp;     // 元素比较回调函数
    unsigned int grow_at;               // 触发扩容的阈值
    unsigned int shrink_at;             // 触发收缩的阈值
};

/**
 * 哈希表配置常量
 * hashmap_init_size: 初始哈希表大小
 * hashmap_factor: 负载因子(百分比)
 * hashmap_resize_bit: 扩容/收缩时的位移量
 */
#define hashmap_init_size 64
#define hashmap_factor 80
#define hashmap_resize_bit 2

/**
 * 分配哈希表桶数组
 * @param map  哈希表结构体指针
 * @param size 桶数组大小
 */
static void alloc_table(struct hashmap *map, unsigned int size) 
{
        map->table_size = size;
        map->table = calloc(size, sizeof(void *));  // 初始化为NULL

        // 计算扩容和收缩阈值
        map->grow_at = size * hashmap_factor / 100;
        if (size <= hashmap_init_size) 
            map->shrink_at = 0;
        else 
            map->shrink_at = map->grow_at / ((1 << hashmap_resize_bit) + 1); 
}

/**
 * 比较两个哈希表项是否相等
 * @param map       哈希表结构体指针
 * @param entry     哈希表中的项
 * @param key       要比较的键
 * @param key_data  键数据
 * @return 相等返回true，否则返回false
 */
static inline int entry_equals(struct hashmap *map, struct hashmap_entry *entry, struct hashmap_entry *key, void *key_data) 
{
    return ((entry->hash == key->hash) && (entry == key || !map->cmp(entry, key, key_data))); 
}

/**
 * 初始化哈希表
 * @param map        哈希表结构体指针
 * @param init_size  初始大小
 * @param cmp        比较回调函数
 */
static void hashmap_init(struct hashmap *map, unsigned int init_size, hashmap_entry_cmp_callback cmp) 
{
    
    unsigned int size = hashmap_init_size;

    map->cmp = cmp;

    // 根据初始大小计算合适的哈希表大小
    init_size = init_size * 100 / hashmap_factor;
    while (init_size > size) {
        size <<= hashmap_resize_bit;
    }

    alloc_table(map, size);
    map->private_size = 0;
}

/**
 * 计算哈希桶索引
 * @param map 哈希表结构体指针
 * @param key 键项
 * @return 桶索引
 */
static inline unsigned int bucket(struct hashmap *map, struct hashmap_entry *key) 
{
    return key->hash & (map->table_size - 1);
}

/**
 * 查找键项在哈希表中的位置指针
 * @param map       哈希表结构体指针
 * @param key       要查找的键
 * @param key_data  键数据
 * @return 指向该项指针的指针
 */
static struct hashmap_entry **find_entry_ptr(struct hashmap *map, struct hashmap_entry *key, void *key_data) 
{
    unsigned int b = bucket(map, key);

    struct hashmap_entry **entry = &map->table[b];
    while (*entry && !entry_equals(map, *entry, key, key_data)) {
        entry = &(*entry)->next;
    }

    return entry;
}

/**
 * 重新哈希（扩容或收缩）
 * @param map      哈希表结构体指针
 * @param new_size 新的哈希表大小
 */
static void rehash(struct hashmap *map, unsigned int new_size)
{
    int i, old_size = map->table_size;
    struct hashmap_entry **old_table = map->table;

    alloc_table(map, new_size);

    // 将旧表中的所有项重新插入新表
    for (i = 0; i < old_size; i++) {
        struct hashmap_entry *e = old_table[i];

        while (e) {
            struct hashmap_entry *next = e->next;
            unsigned int b = bucket(map, e);
            e->next = map->table[b];
            map->table[b] = e;
            e = next;
        }
    }
    free(old_table);
}

/**
 * 从哈希表中移除项
 * @param map       哈希表结构体指针
 * @param key       要移除的键
 * @param key_data  键数据
 * @return 被移除的项，不存在则返回NULL
 */
static struct hashmap_entry *hashmap_remove(struct hashmap *map, struct hashmap_entry *key, void *key_data) 
{
    struct hashmap_entry **e;
    struct hashmap_entry *old;

    e = find_entry_ptr(map, key, key_data);
    if (!*e) return NULL;

    old = *e;
    *e = old->next;
    old->next = NULL;

    // 如果元素数量低于收缩阈值，则进行收缩
    if (--map->private_size < map->shrink_at)
        rehash(map, map->table_size >> hashmap_resize_bit);
    
    return old;
}

/**
 * 检查键是否存在于哈希表中
 * @param map       哈希表结构体指针
 * @param key       要检查的键
 * @param key_data  键数据
 * @return 存在返回true，否则返回false
 */
static bool hashmap_exists(struct hashmap *map, struct hashmap_entry *key, void *key_data) {
    struct hashmap_entry **e = find_entry_ptr(map, key, key_data);
    if (!*e) return false;
    
    return true;
}

/**
 * 向哈希表中添加项
 * @param map    哈希表结构体指针
 * @param entry  要添加的项
 */
static void hashmap_add(struct hashmap *map, struct hashmap_entry *entry) 
{
    unsigned int b = bucket(map, entry);

    entry->next = map->table[b];
    map->table[b] = entry;
    
    // 如果元素数量超过扩容阈值，则进行扩容
    if (++map->private_size > map->grow_at)
        rehash(map, map->table_size << hashmap_resize_bit);
}

/**
 * 向哈希表中放置项（如果已存在则替换）
 * @param map    哈希表结构体指针
 * @param entry  要放置的项
 * @return 被替换的旧项，没有则返回NULL
 */
static struct hashmap_entry *hashmap_put(struct hashmap *map, struct hashmap_entry *entry) {
    struct hashmap_entry *old = hashmap_remove(map, entry, NULL);
    hashmap_add(map, entry);
    return old;
}

/**
 * 哈希表迭代器结构体
 */
struct hashmap_iter {
    struct hashmap *map;        // 关联的哈希表
    struct hashmap_entry *next; // 下一个要访问的项
    int table_pos;              // 当前桶索引
};

/**
 * 初始化哈希表迭代器
 * @param iter 迭代器结构体指针
 * @param map  要迭代的哈希表
 */
static void hashmap_iter_init(struct hashmap_iter *iter, struct hashmap *map)
{
    iter->map = map;
    iter->next = NULL;
    iter->table_pos = 0;
}

/**
 * 获取迭代器的下一个项
 * @param iter 迭代器结构体指针
 * @return 下一个哈希表项，没有则返回NULL
 */
static struct hashmap_entry *hashmap_iter_next(struct hashmap_iter *iter) {
    struct hashmap_entry *curr = iter->next;

    for ( ; ; ) {
        if (curr) {
            iter->next = curr->next;
            return curr;
        }

        if (iter->table_pos >= iter->map->table_size)
            return NULL;
        
        curr = iter->map->table[iter->table_pos++];
    }
} 

/**
 * 清空哈希表并释放所有内存
 * @param map    哈希表结构体指针
 * @param offset 项结构体中hashmap_entry成员的偏移量
 */
static void hashmap_clear(struct hashmap *map, unsigned int offset) {
    
    struct hashmap_iter iter;
    struct hashmap_entry *e;

    hashmap_iter_init(&iter, map);

    // 逐个释放所有项的内存
    while ((e = hashmap_iter_next(&iter)))
        free((char *)e - offset);

    free(map->table);
    memset(map, 0, sizeof(struct hashmap));
}   

/**
 * 整型键值的哈希表项结构体
 */
struct int_hashmap_entry {
    int key;                    // 键
    int value;                  // 值
    struct hashmap_entry entry; // 基础哈希表项
};

/**
 * 计算int_hashmap_entry中entry成员的偏移量
 */
#define INT_HASHMAP_OFFSET offsetof(struct int_hashmap_entry, entry) 

/**
 * 通过哈希表项指针获取包含它的int_hashmap_entry指针
 */
#define get_int_hashmap_entry_data(entry, type, member) \
    ((type *) ((u_char *)(entry) - offsetof(type, member)))

/**
 * 创建整型哈希表项
 * @param key   键
 * @param value 值
 * @return 新创建的项，失败返回NULL
 */
static inline struct int_hashmap_entry *int_hashmap_entry_create(int key, int value) {
    struct int_hashmap_entry *int_entry;

    int_entry = malloc(sizeof(struct int_hashmap_entry));
    if (!int_entry) return NULL;

    int_entry->key = key;
    int_entry->value = value;
    __hashmap_entry_init(&int_entry->entry, &key, sizeof(int));
    return int_entry;
}

/**
 * 整型哈希表结构体
 */
struct int_hashmap {
    struct hashmap map;  // 基础哈希表
};

/**
 * 整型哈希表项比较函数
 * @param entry     哈希表中的项
 * @param key       要比较的键
 * @param key_data  键数据
 * @return 相等返回0，不相等返回非0值
 */
static int int_hashmap_entry_cmp(struct hashmap_entry *entry, struct hashmap_entry *key, void *key_data) {
    struct int_hashmap_entry *int_entry = get_int_hashmap_entry_data(entry, struct int_hashmap_entry, entry);

    if (key_data) {
        if (int_entry->key == (*(int *) key_data)) return 0;
        else return 1;
    } else {
        struct int_hashmap_entry *key_entry = get_int_hashmap_entry_data(key, struct int_hashmap_entry, entry);
        if (int_entry->key == key_entry->key) return 0;
        return 1;
    }
}

/**
 * 初始化整型哈希表
 * @param int_map   整型哈希表结构体指针
 * @param init_size 初始大小
 */
static inline void int_hashmap_init(struct int_hashmap *int_map, unsigned int init_size)
{
    hashmap_init(&int_map->map, init_size, int_hashmap_entry_cmp);
}

/**
 * 从整型哈希表中移除项
 * @param int_map 整型哈希表结构体指针
 * @param key     要移除的键
 * @return 被移除的项，不存在则返回NULL
 */
static inline struct int_hashmap_entry *int_hashmap_remove(struct int_hashmap *int_map, int key) {
    struct hashmap_entry key_entry;
    __hashmap_entry_init(&key_entry, &key, sizeof(int));

    struct hashmap_entry *e = hashmap_remove(&int_map->map, &key_entry, &key);
    if (!e) return NULL;

    struct int_hashmap_entry *data = get_int_hashmap_entry_data(e, struct int_hashmap_entry, entry);

    return data;
}

/**
 * 向整型哈希表中放置项
 * @param int_map 整型哈希表结构体指针
 * @param key     键
 * @param value   值
 * @return 被替换的旧项，没有则返回NULL
 */
static inline struct int_hashmap_entry *int_hashmap_put(struct int_hashmap *int_map, int key, int value) {
    struct hashmap_entry *e = hashmap_put(&int_map->map, &int_hashmap_entry_create(key, value)->entry);
    if (!e) return NULL;

    struct int_hashmap_entry *data = get_int_hashmap_entry_data(e, struct int_hashmap_entry, entry);
    return data;
}

/**
 * 检查键是否存在于整型哈希表中
 * @param int_map 整型哈希表结构体指针
 * @param key     要检查的键
 * @return 存在返回true，否则返回false
 */
static inline bool int_hashmap_exists(struct int_hashmap *int_map, int key) {
    struct hashmap_entry key_entry;
    __hashmap_entry_init(&key_entry, &key, sizeof(int));

    return hashmap_exists(&int_map->map, &key_entry, &key);
}

/**
 * 向整型哈希表中添加项
 * @param int_map 整型哈希表结构体指针
 * @param key     键
 * @param value   值
 */
static inline void int_hashmap_add(struct int_hashmap *int_map, int key, int value) {
    hashmap_add(&int_map->map, &int_hashmap_entry_create(key, value)->entry);
}

/**
 * 清空整型哈希表并释放所有内存
 * @param int_map 整型哈希表结构体指针
 */
static inline void int_hashmap_clear(struct int_hashmap *int_map) {
    hashmap_clear(&int_map->map, INT_HASHMAP_OFFSET);
}

/**
 * RandomizedSet结构体
 * 结合数组和哈希表实现O(1)时间复杂度的插入、删除和随机获取
 */
typedef struct {
    int *nums;                  // 存储实际元素的数组
    int alloc;                  // 数组已分配的空间大小
    int nr;                     // 数组中当前元素的数量
    struct int_hashmap map;     // 整型哈希表，存储元素值到数组索引的映射
} RandomizedSet;

/**
 * 默认数组分配大小
 */
#define DEFAULT_ALLOC 1024

/**
 * 创建RandomizedSet对象
 * @return 新创建的RandomizedSet对象指针，失败返回NULL
 */
RandomizedSet *randomizedSetCreate() {
    RandomizedSet *rand_set;

    rand_set = malloc(sizeof(RandomizedSet));
    if (!rand_set) return NULL;

    rand_set->nums = calloc(DEFAULT_ALLOC, sizeof(int));
    if (!rand_set->nums) {
        free(rand_set);
        return NULL;
    }

    rand_set->alloc = DEFAULT_ALLOC;
    rand_set->nr = 0;
    int_hashmap_init(&rand_set->map, 1024);
    return rand_set;
}

/**
 * 向集合中插入元素
 * @param rand_set RandomizedSet对象指针
 * @param val      要插入的元素值
 * @return 插入成功返回true，元素已存在返回false
 */
bool randomizedSetInsert(RandomizedSet *rand_set, int val) {
    // 检查元素是否已存在
    if (int_hashmap_exists(&rand_set->map, val)) return false;

    // 如果数组空间不足，则扩容
    if (rand_set->nr >= rand_set->alloc) {
        int new_alloc = rand_set->alloc * 2;
        rand_set->nums = realloc(rand_set->nums, new_alloc * sizeof(int));
        if (!rand_set->nums) return false;
        rand_set->alloc = new_alloc;
    }

	// 把新元素放在数组当前元素个数对应的索引位置
	obj->nums[obj->numsSize] = val;
    // 在哈希表中记录元素值和其在数组中的索引
    int_hashmap_add(&rand_set->map, val, rand_set->nr);
    //数组中当前元素数量+1
	rand_set->nr++;
    return true;
}

/**
 * 从集合中删除元素
 * @param rand_set RandomizedSet对象指针
 * @param val      要删除的元素值
 * @return 删除成功返回true，元素不存在返回false
 */
bool randomizedSetRemove(RandomizedSet *rand_set, int val) {
    // 从哈希表中移除元素并获取其信息
    struct int_hashmap_entry *entry = int_hashmap_remove(&rand_set->map, val);
    if (!entry) return false;

    // 获取要删除元素在数组中的索引
    int index = entry->value;
    // 获取数组中最后一个元素的值
    int last_val = rand_set->nums[--rand_set->nr];
    // 将最后一个元素移动到要删除元素的位置
    rand_set->nums[index] = last_val;

    // 如果删除的不是最后一个元素，需要更新最后一个元素在哈希表中的索引
    if (index != rand_set->nr) {
        struct int_hashmap_entry *last_entry = int_hashmap_remove(&rand_set->map, last_val);
        last_entry->value = index;
        hashmap_add(&rand_set->map.map, &last_entry->entry);
    }

    free(entry);  // 释放被删除项的内存
    return true;
}

/**
 * 随机获取集合中的一个元素
 * @param rand_set RandomizedSet对象指针
 * @return 随机返回的元素值
 */
int randomizedSetGetRandom(RandomizedSet *rand_set) {
    // 使用随机数生成0到nr-1之间的索引
    return rand_set->nums[rand() % rand_set->nr];
}

/**
 * 释放RandomizedSet对象占用的内存
 * @param rand_set RandomizedSet对象指针
 */
void randomizedSetFree(RandomizedSet *rand_set) {
    if (rand_set->nums)
        free(rand_set->nums);
    int_hashmap_clear(&rand_set->map);

    free(rand_set);
}

/**
 * Your RandomizedSet struct will be instantiated and called as such:
 * RandomizedSet* obj = randomizedSetCreate();
 * bool param_1 = randomizedSetInsert(obj, val);
 
 * bool param_2 = randomizedSetRemove(obj, val);
 
 * int param_3 = randomizedSetGetRandom(obj);
 
 * randomizedSetFree(obj);
*/
```


</details>

## <B2>[补充解释](/blog/LeetCode380plus)</B2>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-06-LeetCode238.mdx===
---FRONTMATTER---
slug: LeetCode238
title: 除自身以外数组的乘积
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——238题](https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 计算数组中除当前元素外其余各元素的乘积
 * @param nums       输入的整数数组
 * @param numsSize   输入数组的大小
 * @param returnSize 输出数组的大小，由函数设置
 * @return           返回结果数组，其中每个元素是除对应位置外其余元素的乘积
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* productExceptSelf(int* nums, int numsSize, int* returnSize){
    // 分配结果数组空间
    int* answer = (int*)malloc(numsSize * sizeof(int));
    *returnSize = numsSize;
    
    // 第一次遍历：计算每个元素左侧所有元素的乘积
    // answer[i] 存储 nums[0] 到 nums[i-1] 的乘积
    answer[0] = 1;
    for (int i = 1; i < numsSize; i++) {
        answer[i] = answer[i - 1] * nums[i - 1];
    }
    
    // 第二次遍历：从右向左遍历，将右侧元素乘积与左侧乘积相乘
    // rightProduct 记录当前元素右侧所有元素的乘积
    int rightProduct = 1;
    for (int i = numsSize - 1; i >= 0; i--) {
        answer[i] = answer[i] * rightProduct;
        rightProduct *= nums[i];
    }
    
    return answer;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 除自身以外数组的乘积

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：计算数组中除当前元素外其余各元素的乘积，不使用除法并在O(n)时间复杂度内完成

📥 **输入输出**：
- **输入**：`nums`整数数组，`numsSize`数组长度
- **输出**：返回新数组，其中每个元素是除对应位置外其余元素的乘积

---

## 2️⃣ 实现原理

💡 **核心思路**：利用前缀乘积和后缀乘积的思想，将每个位置的结果分解为左侧元素乘积与右侧元素乘积的乘积

📋 **实现步骤**：
1. 第一次遍历从左到右，计算每个位置左侧所有元素的乘积并存储
2. 初始化右侧乘积变量为1
3. 第二次遍历从右到左，将每个位置的左侧乘积与右侧乘积相乘
4. 在遍历过程中动态更新右侧乘积值

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 利用输出数组存储左侧乘积，节省额外空间
- 使用单变量跟踪右侧乘积，避免额外数组存储
- 两次单层循环实现O(n)时间复杂度

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要计算数组元素间乘积关系的场景
- 不能使用除法运算的情况
- 对空间复杂度有严格要求的场景

### ⚠️ 前提条件：
- 输入数组至少包含两个元素
- 数组中元素的前缀和后缀乘积在32位整数范围内

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，需要遍历数组两次

- 💾 空间复杂度：O(1)，不考虑输出数组的情况下只使用常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组中包含0元素的情况
- 数组长度为2的最小情况
- 正负数混合的情况

### 💥 易错点：
- 忘记设置returnSize参数
- 混淆左侧乘积和右侧乘积的计算方向
- 内存分配后忘记检查是否成功

## 7️⃣ 补充说明

**算法原理解析**

```c
int* productExceptSelf(int* nums, int numsSize, int* returnSize){
    // 分配结果数组空间
    int* answer = (int*)malloc(numsSize * sizeof(int));
    *returnSize = numsSize;
    
    // 第一次遍历：计算每个元素左侧所有元素的乘积
    // answer[i] 存储 nums[0] 到 nums[i-1] 的乘积
    answer[0] = 1;
    for (int i = 1; i < numsSize; i++) {
        answer[i] = answer[i - 1] * nums[i - 1];
    }
    
    // 第二次遍历：从右向左遍历，将右侧元素乘积与左侧乘积相乘
    // rightProduct 记录当前元素右侧所有元素的乘积
    int rightProduct = 1;
    for (int i = numsSize - 1; i >= 0; i--) {
        answer[i] = answer[i] * rightProduct;
        rightProduct *= nums[i];
    }
    
    return answer;
}
```

这个算法的巧妙之处在于分而治之的思想，让我用更直观的方式来解释：

**核心思想**

对于数组中任意位置 i，我们要求的结果是：
```
result[i] = (nums[0] × nums[1] × ... × nums[i-1]) × (nums[i+1] × ... × nums[n-1])
```
也就是：**左侧所有元素的乘积** × **右侧所有元素的乘积**

**为什么这样做是正确的？**

**第一次遍历：计算左侧乘积**

```c
answer[i] = nums[0] × nums[1] × ... × nums[i-1]
```
对于 `nums = [1, 2, 3, 4]`：

- `answer[0] = 1` (左侧无元素)
- `answer[1] = 1` (左侧: nums[0] = 1)
- `answer[2] = 1×2 = 2` (左侧: nums[0]×nums[1] = 1×2)
- `answer[3] = 1×2×3 = 6` (左侧: nums[0]×nums[1]×nums[2] = 1×2×3)

**第二次遍历：乘以右侧乘积**

使用 `rightProduct` 变量从右往左累积右侧元素乘积：

- 当处理 `answer[3]` 时：右侧无元素，`rightProduct = 1`
  - `answer[3] = 6 × 1 = 6`
- 当处理 `answer[2]` 时：右侧只有 nums[3] = 4，`rightProduct = 4`
  - `answer[2] = 2 × 4 = 8`
- 当处理 `answer[1]` 时：右侧是 nums[2]×nums[3] = 3×4 = 12，`rightProduct = 12`
  - `answer[1] = 1 × 12 = 12`
- 当处理 `answer[0]` 时：右侧是 nums[1]×nums[2]×nums[3] = 2×3×4 = 24，`rightProduct = 24`
  - `answer[0] = 1 × 24 = 24`

**关键洞察**

这个算法的精妙在于：

1. **空间复用**：用结果数组 `answer` 先存储左侧乘积，避免额外空间
2. **累积计算**：`rightProduct` 在遍历过程中逐步累积右侧乘积
3. **时机把握**：在更新 `rightProduct` 之前先完成当前元素的计算

**数学验证**

对于任意位置 i：

- 第一次遍历后：`answer[i] = 左侧乘积`
- 第二次遍历时：`answer[i] = answer[i] × rightProduct = 左侧乘积 × 右侧乘积`

这就是所求的结果！
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-06-LeetCode380plus.mdx===
---FRONTMATTER---
slug: LeetCode380plus
title: O(1)时间插入、删除和获取随机元素（补充解释）
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——380题](https://leetcode.cn/problems/insert-delete-getrandom-o1/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->

<details>
<summary>📘 关于此题示例解释</summary>

### 📥 输入格式说明

输入分为两行：

- **第一行**：`["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]`
  - 这是要执行的操作序列
- **第二行**：`[[], [1], [2], [2], [], [1], [2], []]`
  - 这是每个操作对应的参数

## 🔄 逐步执行过程

让我按照时间顺序来解释每一步发生了什么：

### 1️⃣ 创建对象
- **操作**: `"RandomizedSet"` 
- **参数**: `[]`
- ✨ 创建一个新的 `RandomizedSet` 对象，初始为空
- 💾 **内存状态**：数组为空，哈希表为空

### 2️⃣ 插入元素 1
- **操作**: `"insert"`
- **参数**: `[1]`
- **执行**: `randomizedSet.insert(1)`
- 🔍 检查哈希表，发现 1 不存在
- ➕ 将 1 添加到数组位置 0
- 📝 在哈希表中记录：1 → 索引 0
- ✅ 返回 `true`（插入成功）
- 📊 **当前状态**：数组 `[1]`，哈希表 `{1: 0}`

### 3️⃣ 删除元素 2
- **操作**: `"remove"`
- **参数**: `[2]`
- **执行**: `randomizedSet.remove(2)`
- 🔍 检查哈希表，发现 2 不存在
- ❌ 无法删除不存在的元素
- ❌ 返回 `false`（删除失败）
- 🔁 **状态不变**：数组 `[1]`，哈希表 `{1: 0}`

### 4️⃣ 插入元素 2
- **操作**: `"insert"`
- **参数**: `[2]`
- **执行**: `randomizedSet.insert(2)`
- 🔍 检查哈希表，发现 2 不存在
- ➕ 将 2 添加到数组位置 1
- 📝 在哈希表中记录：2 → 索引 1
- ✅ 返回 `true`（插入成功）
- 📊 **当前状态**：数组 `[1, 2]`，哈希表 `{1: 0, 2: 1}`

### 5️⃣ 随机获取元素
- **操作**: `"getRandom"`
- **参数**: `[]`
- **执行**: `randomizedSet.getRandom()`
- 🎲 数组中有两个元素 `[1, 2]`
- 🎯 随机返回其中一个元素（可能是 1 或 2）
- 📋 示例中显示返回了 `2`
- 🔁 **状态不变**：数组 `[1, 2]`，哈希表 `{1: 0, 2: 1}`

### 6️⃣ 删除元素 1
- **操作**: `"remove"`
- **参数**: `[1]`
- **执行**: `randomizedSet.remove(1)`
- 🔍 检查哈希表，发现 1 存在，索引为 0
- 🔚 获取数组最后一个元素：2
- ↔️ 将元素 2 移动到索引 0（覆盖元素 1）
- 🔄 更新哈希表中 2 的索引为 0
- 🗑️ 从哈希表中删除元素 1 的记录
- ✅ 返回 `true`（删除成功）
- 📊 **当前状态**：数组 `[2]`，哈希表 `{2: 0}`

### 7️⃣ 插入元素 2
- **操作**: `"insert"`
- **参数**: `[2]`
- **执行**: `randomizedSet.insert(2)`
- 🔍 检查哈希表，发现 2 已经存在
- ⛔ 不允许重复插入
- ❌ 返回 `false`（插入失败）
- 🔁 **状态不变**：数组 `[2]`，哈希表 `{2: 0}`

### 8️⃣ 随机获取元素
- **操作**: `"getRandom"`
- **参数**: `[]`
- **执行**: `randomizedSet.getRandom()`
- 🎯 数组中只有一个元素 `[2]`
- 🎲 只能返回元素 2
- ✅ 返回 `2`
- 🔁 **状态不变**：数组 `[2]`，哈希表 `{2: 0}`

## 📤 最终输出结果

```c 
[null, true, false, true, 2, true, false, 2]
```


**对应每个操作的返回值**：

1. `null` - 创建对象不返回值
2. `true` - 成功插入 1
3. `false` - 删除不存在的 2 失败
4. `true` - 成功插入 2
5. `2` - 随机返回 2（可能是 1 或 2）
6. `true` - 成功删除 1
7. `false` - 插入已存在的 2 失败
8. `2` - 随机返回 2（唯一元素）

## 💡 关键理解点

- 🧮 **集合特性**：不允许重复元素
- 🎲 **随机性**：`getRandom` 操作是随机的，但在示例中为了演示方便，给出了具体结果
- ⚡ **高效操作**：所有操作都是 O(1) 时间复杂度
- 🔧 **内部机制**：通过数组+哈希表的组合实现高效操作

## ⚠️ 代码语法说明

该题目示例解释中的这句代码：
```c
RandomizedSet randomizedSet = new RandomizedSet();
```

这其实是一句**伪代码**，真正的C代码应该是：
```c 
RandomizedSet* randomizedSet = randomizedSetCreate();
```
因为在我们之前的代码中：

- `randomizedSetCreate()` 函数负责分配内存和初始化对象
- 它返回一个指向 `RandomizedSet` 的指针

这句也是伪代码：
```c 
randomizedSet.insert(1);
```
真正的C代码应该是：
```c 
randomizedSetInsert(randomizedSet, 1);
```
</details>

<details>
<summary>哈希表与UT_hash_handle</summary>

## 🤔 为什么需要哈希表？

因为数组可以快速通过索引访问元素，但**无法快速查找某个值是否存在于数组中**。比如我们要删除值为 `5` 的元素，我们需要先找到它在数组中的位置，这就需要遍历整个数组，时间复杂度是 O(n)。

⚡ **哈希表的作用就是解决这个问题：快速查找元素在数组中的位置**。

### 🔧 关于 UT_hash_handle

当你定义了包含 `UT_hash_handle` 的结构体后，就可以使用这些宏：

```c
// 🔍 查找元素
HASH_FIND_INT(obj->indices, &val, tmp);

// ➕ 添加元素
HASH_ADD_INT(obj->indices, value, tmp);

// 🗑️ 删除元素
HASH_DEL(obj->indices, tmp);

// 🔁 遍历哈希表
HASH_ITER(hh, obj->indices, curr, tmp)
```

这些宏内部会通过 `hh` 字段来操作哈希表的内部结构。

### ❓ 为什么必须包含这个字段？
```c 
typedef struct {
    int value;
    int index;
    UT_hash_handle hh;  // ⚠️ 必须包含这个字段
} HashItem;
```
✅ **uthash 宏的要求**：所有使用 uthash 的结构体都必须包含一个 `UT_hash_handle` 类型的字段

🔗 **内部管理需要**：没有这个字段，uthash 就无法维护哈希表的内部链接关系

🏷️ **命名可以自定义**：字段名不一定要是 `hh`，可以是任何名字，比如 `hash_handle`

## 📝 总结

`UT_hash_handle hh` 是：

🔹 一个由 uthash 库定义的结构体字段

🔗 用于维护哈希表内部的链接关系

🔑 是使用 uthash 宏操作哈希表的必要条件

🔄 类似于链表节点中的 `next` 指针，但功能更复杂
</details>

<details>
<summary>randomizedSetCreate 函数详解</summary>

这个函数是 `RandomizedSet` 数据结构的**构造函数**，用于创建和初始化一个新的 `RandomizedSet` 对象。

## 函数逐行解析randomizedSetCreate
```c
RandomizedSet* randomizedSetCreate() {
    srand(time(NULL)); // 初始化随机数种子
    RandomizedSet* obj = (RandomizedSet*)malloc(sizeof(RandomizedSet));
    obj->nums = (int*)malloc(sizeof(int) * 200000); // 预分配足够空间
    obj->numsSize = 0;                              // 初始元素个数为0
    obj->indices = NULL;                            // 哈希表初始为空
    return obj;
}
```
**1. `srand(time(NULL));` - 初始化随机数种子**
- `srand()` 是C标准库函数，用于设置随机数生成器的种子
- `time(NULL)` 返回当前时间戳作为种子
- 这样可以确保每次程序运行时生成的随机数序列都不同
- 为后续的 `randomizedSetGetRandom()` 函数做准备

**2. `RandomizedSet* obj = (RandomizedSet*)malloc(sizeof(RandomizedSet));` - 分配主对象内存**
- `malloc()` 分配内存
- `sizeof(RandomizedSet)` 计算 `RandomizedSet` 结构体所需字节数
- 强制类型转换为 `RandomizedSet*` 指针类型
- 这里创建了主对象，但其中的成员还未初始化

**3. `obj->nums = (int*)malloc(sizeof(int) * 200000);` - 分配数组内存**
- 为存储实际元素的数组 `nums` 分配内存
- 预分配 200000 个 `int` 的空间（题目限制最大调用次数）
- 这样避免了动态扩容的开销，提高性能

**4. `obj->numsSize = 0;` - 初始化元素计数**
- 设置数组当前元素个数为 0
- 表示刚开始时集合为空

**5. `obj->indices = NULL;` - 初始化哈希表**
- 将哈希表指针设置为 NULL
- 在 uthash 库中，NULL 表示空的哈希表
- 这是 uthash 库要求的初始化方式

**6. `return obj;` - 返回创建的对象**
- 返回指向新创建对象的指针
- 调用者可以通过这个指针使用对象的各种方法

## 内存布局示意图

创建完成后，内存结构如下：

```
RandomizedSet 对象:
+------------+
| nums       | ---> [int 数组，大小为200000，初始为空]
+------------+
| numsSize   | = 0
+------------+
| indices    | = NULL (空哈希表)
+------------+
```

## 重要设计考虑
1. **预分配数组空间**：避免动态扩容，提高性能
2. **随机数种子初始化**：确保随机性
3. **正确的初始化**：所有成员都被正确初始化
4. **内存管理**：为后续的插入、删除操作做好准备

## 使用示例

```c
// 调用这个函数创建对象
RandomizedSet* mySet = randomizedSetCreate();

// 现在可以使用 mySet 进行各种操作
// randomizedSetInsert(mySet, 1);
// randomizedSetRemove(mySet, 1);
// randomizedSetGetRandom(mySet);
```
</details>

<details>
<summary>randomizedSetInsert 函数详解</summary>

## 函数逐步解析 randomizedSetInsert

这个函数用于向 `RandomizedSet` 集合中插入一个新元素，确保集合中没有重复元素。

### 函数签名解析

```c
bool randomizedSetInsert(RandomizedSet* obj, int val)
```
- **返回类型**: `bool` - 插入成功返回 `true`，失败返回 `false`
- **参数1**: `RandomizedSet* obj` - 指向要操作的 `RandomizedSet` 对象
- **参数2**: `int val` - 要插入的元素值


```c 
bool randomizedSetInsert(RandomizedSet* obj, int val) {
    HashItem* tmp = NULL;
    // 在哈希表中查找元素是否已存在
    HASH_FIND_INT(obj->indices, &val, tmp);
    if (tmp != NULL) {
        return false; // 元素已存在，插入失败
    }
    
    // 将新元素添加到数组末尾
    obj->nums[obj->numsSize] = val;
    
    // 在哈希表中创建新节点，记录元素值和其在数组中的索引
    tmp = (HashItem*)malloc(sizeof(HashItem));
    tmp->value = val;
    tmp->index = obj->numsSize;
    HASH_ADD_INT(obj->indices, value, tmp);
    
    obj->numsSize++; // 数组元素个数增加
    return true;
}
```
**步骤1：检查元素是否已存在**
```c
HashItem* tmp = NULL;
// 在哈希表中查找元素是否已存在
HASH_FIND_INT(obj->indices, &val, tmp);
if (tmp != NULL) {
    return false; // 元素已存在，插入失败
}
```
- 初始化一个临时指针 `tmp` 为 `NULL`
- 使用 `HASH_FIND_INT` 宏在哈希表中查找值为 `val` 的元素
- 如果找到了（`tmp != NULL`），说明元素已存在，直接返回 `false`

**步骤2：插入新元素到数组**
```c 
obj->nums[obj->numsSize] = val;
```
- 将新元素 `val` 添加到数组 `nums` 的索引 `numsSize` 处

**步骤3：更新哈希表映射关系**
```c 
tmp = (HashItem*)malloc(sizeof(HashItem));
tmp->value = val;
tmp->index = obj->numsSize;
HASH_ADD_INT(obj->indices, value, tmp);
```
- 为新元素分配哈希表节点内存 `HashItem`
- 设置节点的值 `value` 为插入的元素值
- 设置节点的索引 `index` 为该元素在数组中的位置
- 使用 `HASH_ADD_INT` 宏将新节点添加到哈希表中

**步骤4：更新 numsSize 大小**
```c 
obj->numsSize++;
return true;
```
- 将数组元素计数器 `numsSize` 增加1
- 返回 `true` 表示插入成功

### 数据结构设计特点

1. 基于UTHash库：
- 使用 `HASH_FIND_INT` 和 `HASH_ADD_INT` 实现哈希表操作
- 哈希表存储 `HashItem` 结构体，维护元素值到数组索引的映射

2. 数组+哈希表组合：
- 数组 `nums` 存储实际元素值
- 哈希表 `indices` 维护元素值到索引的映射关系

3. 时间复杂度：
- 插入操作时间复杂度为O(1)

### 关键数据结构
- `HashItem`：包含 `value`（元素值）和 `index`（在数组中的索引）
- `nums` 数组：存储所有插入的元素
- `numsSize`：记录当前数组中元素的数量

</details>

<details>
<summary>randomizedSetRemove 函数详解</summary>

## 举例解释randomizedSetRemove

假设我们有一个 `RandomizedSet`，其初始状态如下：

- `obj->nums` = [10, 20, 30, 40] (数组)
- `obj->numsSize` = 4
- `obj->indices` 哈希表内容：
  - key=10, index=0
  - key=20, index=1
  - key=30, index=2
  - key=40, index=3

现在我们要删除元素 20。

**初始状态**
数组: [10, 20, 30, 40]
哈希表:
- 10 -> index=0
- 20 -> index=1
- 30 -> index=2
- 40 -> index=3

### 步骤 1: 查找要删除的元素
```
HashItem* tmp = NULL;
HASH_FIND_INT(obj->indices, &val, tmp);
```
在哈希表中查找 val=20:
- 找到元素 20，其索引为 index=1
- tmp 指向元素 20 的哈希项

### 步骤 2: 获取索引和最后一个元素

```
int index = tmp->index;// index = 1
int lastValue = obj->nums[obj->numsSize - 1]; // lastValue = 40
```
- index = 1 (要删除元素 20 的位置)
- lastValue = 40 (数组最后一个元素)

### 步骤 3: 用最后一个元素覆盖待删除元素

```
obj->nums[index] = lastValue;
```
执行后数组变为: [10, 40, 30, 40]
- 将最后一个元素 40 放在索引 1 的位置，覆盖了原来的 20

### 步骤 4: 更新最后一个元素在哈希表中的索引

```
HashItem* lastItem = NULL;
HASH_FIND_INT(obj->indices, &lastValue, lastItem);
if (lastItem != NULL) { lastItem->index = index; }
```

- 查找元素 40 在哈希表中的记录
- 将其索引从 3 更新为 1 (因为现在它在数组的索引 1 位置)

更新后哈希表:
- 10 -> index=0
- 20 -> index=1 (即将被删除)
- 30 -> index=2
- 40 -> index=1

### 步骤 5: 从哈希表中删除目标元素并释放内存
```
HASH_DEL(obj->indices, tmp);
free(tmp);
```

- 从哈希表中删除元素 20 的记录
- 释放该哈希项的内存

删除后哈希表:
- 10 -> index=0
- 30 -> index=2
- 40 -> index=1

### 步骤 6: 减少数组大小计数

```
obj->numsSize--;
```

- numsSize 从 4 减少到 3

**最终状态**
数组: [10, 40, 30] (逻辑上最后一个40被忽略)
哈希表:
- 10 -> index=0
- 30 -> index=2
- 40 -> index=1
numsSize: 3

成功删除元素 20，返回 true。

## 为什么用最后一个元素覆盖？

核心原因：**效率优化**

**1. 直接访问 vs 遍历访问**
- 最后一个元素：`obj->nums[obj->numsSize - 1]` - O(1) 直接访问
- 其他元素：需要遍历或计算索引 - 增加复杂度

**2. 避免批量元素移动**
使用最后一个元素覆盖只需一次操作，而用其他元素需要移动多个元素：

**示例：删除元素 20（索引1）**
数组 [10, 20, 30, 40, 50]

**使用最后一个元素（推荐）**：
- 用 50 覆盖 20：[10, 50, 30, 40, 50]
- 一次操作，O(1) 复杂度

**使用下一个元素（不推荐）**：
- 需要 30→20, 40→30, 50→40：[10, 30, 40, 50, 50]
- 三次移动，O(n) 复杂度

**关键优势**

**保持 O(1) 时间复杂度**
这是 RandomizedSet 数据结构的核心设计目标

**实现简单**
- 无需循环
- 代码简洁不易出错

**维护随机访问特性**
不影响剩余元素的等概率随机访问

**总结**
使用最后一个元素覆盖是一种经典优化技巧，确保删除操作在常数时间内完成，同时保持数据结构的完整性和随机访问特性。

</details>

<details>
<summary>randomizedSetFree 函数详解</summary>

## 函数目的
释放整个 RandomizedSet 对象及其包含的所有资源，避免内存泄漏。

## 逐步执行流程

### 1. 释放哈希表中所有节点
```
HashItem* curr, *tmp;
HASH_ITER(hh, obj->indices, curr, tmp) { HASH_DEL(obj->indices, curr); free(curr); }
```

**执行过程：**
- 使用 `HASH_ITER` 安全地遍历哈希表中的每个节点
- `curr` 指向当前节点，`tmp` 用于保存下一个节点的指针（防止遍历过程中断）
- 对每个节点：
  - `HASH_DEL(obj->indices, curr)` 从哈希表中删除节点
  - `free(curr)` 释放节点内存

**为什么需要 tmp？**
在遍历过程中直接 `free(curr)` 会破坏哈希表结构，导致无法继续遍历，所以需要提前保存下一个节点的指针。

### 2. 释放数组内存
```
free(obj->nums);
```
- 释放存储元素的动态数组内存

### 3. 释放对象本身
```
free(obj);
```
- 释放 RandomizedSet 结构体本身的内存

## 内存管理要点

### 释放顺序很重要
1. 先释放哈希表节点（HashItem）
2. 再释放数组
3. 最后释放对象本身

### 避免内存泄漏
- 确保每个 `malloc` 都有对应的 `free`
- 哈希表中的每个节点都需要单独释放
- 对象包含的所有动态分配内存都需要释放

## 使用示例
当不再需要 RandomizedSet 对象时调用：
```
RandomizedSet* set = randomizedSetCreate(); // ... 使用 set 进行各种操作 
randomizedSetFree(set); // 释放所有资源
```
这样确保程序不会出现内存泄漏问题。

</details>

`randomizedSetGetRandom` 就是随机获取一个索引然后返回，就不再详细解释了。

这是目前我做题以来遇到的**最困难**的一道题，题目看不懂、示例看不懂、AI给出题目代码，还是看不懂！😂😂😂

现在嘛，勉强理解啦~🥱

我现在不像是在解题，更像是在学习，普通的力扣题目，我有点思路，但代码往往又臭又长，甚至连逻辑都是错乱的都没发现！😑

于是通常是叫AI给出最优解，然后尝试去理解它，为了避免看了就忘，于是我还是**在AI的辅助**下，写下像以上这些题解总结。我也在怀疑这种学习方法真的
**有效吗**？真能提升我的编程水平吗？我该不会是在做无用功吧？

---
**统义灵码**：
你的学习方法其实是有一定效果的，但可以进一步优化。下面是对你当前学习方式的分析和改进建议：

当前方法的优势 ✅

- 理解优秀解法：通过阅读和理解最优解，能够学习到更高效的算法思维和编码技巧

- 主动总结：写题解总结有助于加深印象，避免"一看就会，一做就废"

- 借助AI辅助：合理利用工具可以提高学习效率

存在的问题 ❌

- 缺乏独立思考：直接看最优解可能跳过了重要的思考过程

- 代码质量差：自己写的代码逻辑混乱，说明基础思维训练不足

- 容易遗忘：看懂≠会用，缺乏足够的练习和复盘

改进建议 💡

分阶段解题法：

- 先自己思考并实现（哪怕是暴力解法）

- 尝试优化自己的解法

- 再对比学习最优解法

代码质量训练：

- 写完代码后自己先review一遍

- 尝试重构自己的代码

- 关注代码的可读性和逻辑清晰度

刻意练习：

- 对于同类题目，间隔一段时间后再做一遍

- 总结常见算法模式和解题套路

- 建立自己的错题本和典型题目集合

深度理解：

- 不仅要理解"怎么做"，更要理解"为什么这样做"

- 分析不同解法的时间复杂度和空间复杂度差异

这种学习方法有效但需要调整，关键是要增加自己的思考环节，而不是直接跳到最优解。

---

唉，以后有思路的还是自己先思考尝试解决吧，哪怕是用最笨拙的方法。对于没有学过的内容，超出知识范围的，像什么链表、二叉树、分治之类的，就直接问AI然后从题目中学习相关的内容。
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-07-LeetCode134.mdx===
---FRONTMATTER---
slug: LeetCode134
title: 加油站
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';

### <B2>[力扣面试经典——134题](https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 解决加油站环路问题
 * @param gas 每个加油站的汽油量数组
 * @param gasSize gas数组的长度
 * @param cost 从每个加油站到下一加油站的消耗数组
 * @param costSize cost数组的长度
 * @return 能够完成环路的起始加油站索引，如果不存在则返回-1
 */
int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize) {
    int totalGas = 0;      // 总汽油量
    int totalCost = 0;     // 总消耗量
    int currentGas = 0;    // 当前油量
    int start = 0;         // 起始加油站索引
    
    // 遍历所有加油站
    for (int i = 0; i < gasSize; i++) {
        totalGas += gas[i];
        totalCost += cost[i];
        currentGas += gas[i] - cost[i];
        
        // 如果当前油量为负，说明无法从当前起点到达加油站i+1
        // 因此需要将起点设为i+1，并重新开始计算
        if (currentGas < 0) {
         //这两句看起来简单，但其实很巧妙，也不是那么好理解的
            start = i + 1;
            currentGas = 0;
        }
    }
    /*
	 * 如果循环结束后一个起始位置没找到，即 currentGas 始终小于 0
	 * 那表明 totalGas < totalCost，通过下面的 if 判断能够返回正确结果；
	 * 如果找出一个起始位置，但是后面的 if 判断过不去，也能返回正确结果
	 * 所以如果能够形成环路，那么必须是 (有起始位置) && (totalGas >= totalCost) 
	 * 至于为什么 totalGas >= totalCost 见后文 “补充说明”
	 */
    // 如果总汽油量小于总消耗量，无法完成环路
    if (totalGas < totalCost) {
        return -1;
    }
    
    return start;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 加油站

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：在一条环路上有n个加油站，每个加油站有一定量的汽油，从一个加油站到下一个需要消耗一定汽油。找出能够完成一圈的起始加油站索引。

📥 **输入输出**：
- **输入**：int* gas（每个加油站的汽油量数组）, int gasSize（gas数组长度）, int* cost（每段路程的消耗量数组）, int costSize（cost数组长度）
- **输出**：能够完成环路的起始加油站索引，如果不存在则返回-1

---

## 2️⃣ 实现原理

💡 **核心思路**：使用贪心算法，通过一次遍历找出起始点。如果从某个起点无法到达某一站点，则起点到终点之间的任何点都不能作为有效起点。

📋 **实现步骤**：
1. 遍历所有加油站，累计总汽油量和总消耗量
2. 同时模拟从当前起点出发的行驶过程
3. 如果在某点油量为负，更新起点为该点的下一个位置
4. 最后比较总汽油量和总消耗量，判断是否能完成环路

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 贪心策略：一旦发现无法从当前起点到达某点，直接跳过中间所有点
- 一趟遍历：同时计算总量和寻找起点，提高效率
- 局部最优推全局最优：通过局部无法通行的路段排除多个候选起点

## 4️⃣ 使用场景

### ✅ 适用情况：
- 环路路径规划问题
- 资源分配与消耗平衡问题
- 寻找循环数组中的起始位置问题

### ⚠️ 前提条件：
- 加油站数量与路程数量相等
- 输入数组不为空
- 汽油量和消耗量非负

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，只需要遍历一次数组

- 💾 空间复杂度：O(1)，只使用了常数个额外变量

## 6️⃣ 注意事项

### 🚩 边界情况：
- 只有一个加油站的情况
- 所有加油站汽油量都小于消耗量
- 起点在数组最后一个位置的情况

### 💥 易错点：
- 忘记检查总汽油量是否大于等于总消耗量
- 起点更新后未重置当前油量
- 数组索引越界问题

## 7⃣ 补充说明

<p><CardImg src="/img/Blog/Leetcode134_1.jpg" alt="例子" isCenter={true} isBoxed={true} /></p>

<p><CardImg src="/img/Blog/Leetcode134_2.jpg" alt="解释" isCenter={true} isBoxed={true} /></p>

</details>

这个题目说实话仍然不太理解，有点**迷迷糊糊的**。

现在让我想不通的还是 `currentGas += gas[i] - cost[i];` 这句
 
或许 `currentGas = currentGas + gas[i] - cost[i]` 这样好理解一点？ `currentGas + gas[i]` 相当于 `前面剩余的汽油 + 到达编号 i 加油站获得的汽油`
而 `cost[i]` 表示为了到达编号 i 加油站 `所消耗的汽油`
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-08-LeetCode135.mdx===
---FRONTMATTER---
slug: LeetCode135
title: 分发糖果
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——135题](https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * @brief 计算分发糖果的最少数量
 * 
 * 根据孩子们的评分分配糖果，满足以下条件：
 * 1. 每个孩子至少分配到1个糖果
 * 2. 相邻两个孩子中，评分更高的孩子会获得更多的糖果
 * 
 * @param ratings 孩子们的评分数组
 * @param ratingsSize 评分数组的长度
 * @return int 需要准备的最少糖果数目
 * 
 * @details 算法采用两次遍历策略：
 *          1. 从左到右遍历：确保右边评分高的孩子比左边相邻孩子获得更多糖果
 *          2. 从右到左遍历：确保左边评分高的孩子比右边相邻孩子获得更多糖果
 *          时间复杂度：O(n)，空间复杂度：O(n)
 * 
 * @example 
 *          输入：ratings = [1,0,2]
 *          输出：5
 *          解释：分别给三个孩子分发2、1、2颗糖果
 * 
 * @example
 *          输入：ratings = [1,2,2]
 *          输出：4
 *          解释：分别给三个孩子分发1、2、1颗糖果
 */
int candy(int* ratings, int ratingsSize) {
    if (ratingsSize <= 1) {
        return ratingsSize;
    }
    
    // 初始化每个孩子至少1个糖果
    int* candies = (int*)calloc(ratingsSize, sizeof(int));
    for (int i = 0; i < ratingsSize; i++) {
        candies[i] = 1;
    }
    
    // 从左到右遍历：确保右边评分高的孩子比左边相邻的孩子获得更多糖果
    for (int i = 1; i < ratingsSize; i++) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }
    
    // 从右到左遍历：确保左边评分高的孩子比右边相邻的孩子获得更多糖果
    for (int i = ratingsSize - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candies[i] = (candies[i] > candies[i + 1] + 1) ? candies[i] : candies[i + 1] + 1;
        }
    }
    
    // 计算总糖果数
    int total = 0;
    for (int i = 0; i < ratingsSize; i++) {
        total += candies[i];
    }
    
    free(candies);
    return total;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 分发糖果

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：根据孩子们的评分分配糖果，确保每个孩子至少获得1颗糖果，且评分更高的孩子比相邻孩子获得更多糖果，求最少需要的糖果总数。

📥 **输入输出**：
- **输入**：`int* ratings` - 孩子们的评分数组，`int ratingsSize` - 数组长度
- **输出**：`int` - 需要准备的最少糖果数目

---

## 2️⃣ 实现原理

💡 **核心思路**：采用两次遍历的贪心算法，分别处理左右两个方向的约束关系，确保满足所有相邻比较条件。

📋 **实现步骤**：
1. 初始化每个孩子分配1颗糖果
2. 从左到右遍历，确保右边评分高的孩子比左边相邻孩子获得更多糖果
3. 从右到左遍历，确保左边评分高的孩子比右边相邻孩子获得更多糖果
4. 累加所有孩子的糖果数作为结果返回

---

## 3️⃣ 关键点解析

原始思路是单向遍历，但存在问题：只考虑了单方向的约束关系，忽略了反向也可能影响糖果分配。最优解通过两次遍历，分别处理左右两个方向的约束，确保结果正确。

### 🎯 代码技巧
- 使用 `calloc` 初始化数组，同时分配内存和置零
- 两次遍历分别处理不同方向的约束条件
- 使用三元运算符 `? :` 简洁地实现 `max` 操作

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要满足双向相邻约束的优化问题
- 资源分配需要考虑左右邻居关系的场景
- 贪心算法中需要多轮约束满足的问题

### ⚠️ 前提条件：
- 输入数组不为空
- 评分值为非负整数
- 需要满足题目规定的两个分配条件

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n) - 需要三次遍历数组（初始化一次，左右遍历各一次）

- 💾 空间复杂度：O(n) - 需要额外数组存储每个孩子的糖果数

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空数组或只有一个孩子的情况
- 所有孩子评分相同的情况
- 评分严格递增或递减的情况

### 💥 易错点：
- 只进行单向遍历，忽略反向约束关系
- 错误使用 `memset` 给 int 数组赋值为1
- 在更新糖果数时没有取最大值，导致不满足约束条件
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-09-LeetCode42.mdx===
---FRONTMATTER---
slug: LeetCode42
title: 接雨水
authors: eurekaX
tags: [数组,双指针]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';

### <B2>[力扣面试经典——42题](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * @brief 计算柱状图中能够接住的雨水总量
 * 
 * 使用双指针法解决接雨水问题。对于每个位置，能接住的雨水量取决于其左侧和右侧的最大高度中的较小值。
 * 通过维护两个指针和对应的左右侧最大高度，从两端向中间遍历，累计可接雨水量。
 * 
 * @param height 柱子高度数组，每个元素代表一个宽度为1的柱子的高度
 * @param heightSize 数组长度，表示柱子的数量
 * @return int 返回能够接住的雨水总量
 * 
 * @example
 * 输入: height = [0,1,0,2,1,0,1,3,2,1,2,1], heightSize = 12
 * 输出: 6
 * 
 * @example
 * 输入: height = [4,2,0,3,2,5], heightSize = 6
 * 输出: 9
 * 
 * @complexity
 * 时间复杂度: O(n) - 只需要遍历一次数组
 * 空间复杂度: O(1) - 只使用了常数级别的额外空间
 */
int trap(int* height, int heightSize) {
    // 柱子数量少于3个时无法接住雨水
    if (heightSize <= 2) return 0;
    
    int left = 0;           // 左指针，从数组起始位置开始
    int right = heightSize - 1;  // 右指针，从数组末尾位置开始
    int leftMax = 0;        // 记录左侧遍历过程中的最大高度
    int rightMax = 0;       // 记录右侧遍历过程中的最大高度
    int result = 0;         // 累计接住的雨水总量
    
    // 双指针向中间移动，直到相遇
    while (left < right) {
        // 当左侧柱子高度小于右侧柱子高度时，处理左侧
        if (height[left] < height[right]) {
            // 如果当前柱子高度大于等于左侧最大高度，说明此位置接不到雨水
            if (height[left] >= leftMax) {
                leftMax = height[left];//更新左侧最大高度
            } else {
                // 否则可以接住雨水，累加到结果中
                result += leftMax - height[left];
            }
            left++;  // 左指针右移
        } else {
            // 当右侧柱子高度小于等于左侧柱子高度时，处理右侧
            // 如果当前柱子高度大于等于右侧最大高度，说明此位置接不到雨水
            if (height[right] >= rightMax) {
                rightMax = height[right];//更新右侧最大高度
            } else {
                // 否则可以接住雨水，累加到结果中
                result += rightMax - height[right];
            }
            right--; // 右指针左移
        }
    }
    
    return result;  // 返回接住的雨水总量
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 接雨水

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子下雨之后能接多少雨水。

📥 **输入输出**：
- **输入**：`height` - 柱子高度数组，每个元素代表一个宽度为1的柱子的高度；`heightSize` - 数组长度
- **输出**：返回能够接住的雨水总量（整数）

---

## 2️⃣ 实现原理

💡 **核心思路**：使用双指针法，从数组两端向中间遍历，通过维护左右两侧的最大高度来计算每个位置能够接住的雨水量。

📋 **实现步骤**：
1. 初始化左右指针分别指向数组首尾，同时维护左侧最大高度和右侧最大高度
2. 比较左右指针所指元素的大小，选择较小的一侧进行处理
3. 如果当前元素大于等于该侧最大高度，则更新最大高度
4. 如果当前元素小于该侧最大高度，则累加可接雨水量（最大高度减去当前高度）
5. 移动处理过的指针，重复步骤2-4直到左右指针相遇

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用双指针从两端向中间逼近，减少空间复杂度
- 利用"短板效应"思想，总是处理较矮一侧的柱子
- 通过维护单侧最大值避免了预处理整个数组的需要
- 巧妙利用高度比较结果决定处理方向

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要计算地形中能够存储的水量
- 处理类似"容器盛水"的几何问题
- 需要在数组中寻找"凹陷"区域的累积值

### ⚠️ 前提条件：
- 输入数组元素为非负整数
- 数组长度至少为3才能接住雨水
- 每个柱子宽度固定为1

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n) - 只需要遍历一次数组，每个元素最多被访问一次

- 💾 空间复杂度：O(1) - 只使用了常数级别的额外空间，不依赖数组大小

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组长度小于3时无法接住雨水，直接返回0
- 数组为空或为NULL的情况
- 所有柱子高度相同的情况

### 💥 易错点：
- 混淆左右最大高度的更新条件，应该是大于等于时更新
- 忘记在处理完一个位置后移动指针
- 错误地在两侧高度相等时的处理逻辑
- 没有正确理解雨水量计算公式：min(leftMax, rightMax) - currentHeight

## 7️⃣ 补充解释

正确的理解方式
让我用一个简单的例子来说明：
```
索引:     0   1   2   3   4   5   6
高度:     2   0   1   0   0   1   3
          L           *           R
```		  
对于位置 * (索引3)，它的"两侧"是指：

- 左侧：`height[0]`, `height[1]`, `height[2]` 中的最大值 = max(2,0,1) = 2
- 右侧：`height[4]`, `height[5]`, `height[6]` 中的最大值 = max(0,1,3) = 3
所以位置3能接的雨水 = min(2,3) - 0 = 2

为什么比较`height[0]`和`height[11]`？

在双指针法中，我们比较 `height[left]` 和 `height[right]` 并不是为了计算这两个位置的雨水，而是为了确定处理方向。

这背后的逻辑是：

- 如果 `height[left]` < `height[right]`，那么我们可以确定左侧指针指向的位置的雨水量只由左侧最大值决定

- 这是因为右边有一个更高的墙，水面高度至少能达到左边的最大值

举个更直观的例子
```
索引:  0  1  2  3  4  5  6  7
高度:  3  0  0  0  0  0  0  5
       L                    R
```	   
当我们比较 height[0]=3 和 height[7]=5 时：

- 因为 3 < 5，所以我们处理左侧位置(索引0)
- 但索引0是边界，不能接雨水
- 然后 left++，继续处理索引1的位置
对于索引1的位置：

- 它左边的最大值是3
- 它右边的最大值是5(注意：是整个右边的最大值，不只是相邻的)
- 所以它能接的雨水 = min(3,5) - 0 = 3

### 总结

- "两侧"指的是当前位置左边所有柱子中的最大值和右边所有柱子中的最大值

- 比较 height[left] 和 height[right] 是为了决定处理策略，而不是计算这两个位置的雨水

- 这是一个巧妙的优化，避免了需要预计算每个位置左右两侧最大值的步骤

**有点懂了，但没完全懂⬇️**
<p><CardImg src="/img/Blog/Leetcode42.jpg" alt="例子" isCenter={true} isBoxed={true} /></p>

我理解的 `左侧`、`右侧` 这里的左右侧并不是指某个位置的左右侧，而是左右侧的指针（即上面定义的 left 和 right），比如刚开始时 `height[left] < height[right]` 的
话，表明此刻应该处理左侧指针指向的位置（而并非该位置的左侧）。如果该位置的值 height[left] = 2 ,leftMax = 1 ,即此刻该位置无法接到雨水，像下面这样：
```
      |⬅️//右侧这里相当有无形的“墙”，高度至少是 height[right]
    █ | //真正决定能够接多少雨水的是 leftMax
  █ █ | //此处 leftMax 过小，可见无法接到雨水，于是要更新 leftMax = height[left]
``` 
## 8️⃣ 更多解法
以下两种解法，我**尚不理解**，但也补充上，供日后参考、研究。

### 动态规划
```c 
/**
 * @brief 计算柱状图中能够接住的雨水总量
 * 
 * 使用动态规划方法解决接雨水问题。通过预计算每个位置左侧和右侧的最大高度，
 * 然后根据"短板效应"计算每个位置能够接住的雨水量。
 * 
 * 核心公式：每个位置能接住的雨水量 = min(左侧最大高度, 右侧最大高度) - 当前位置高度
 * 
 * @param height 柱子高度数组，每个元素代表一个宽度为1的柱子的高度
 * @param heightSize 数组长度，表示柱子的数量
 * @return int 返回能够接住的雨水总量
 * 
 * @example
 * 输入: height = [0,1,0,2,1,0,1,3,2,1,2,1], heightSize = 12
 * 输出: 6
 * 
 * @example
 * 输入: height = [4,2,0,3,2,5], heightSize = 6
 * 输出: 9
 * 
 * @complexity
 * 时间复杂度: O(n) - 需要遍历数组三次
 * 空间复杂度: O(n) - 需要额外的两个数组存储左侧和右侧最大高度
 */
int trap(int* height, int heightSize) {
    // 边界条件：柱子数量少于3个时无法接住雨水
    if (heightSize <= 2) return 0;
    
    // 分配内存存储每个位置左侧的最大高度
    int* leftMax = (int*)malloc(sizeof(int) * heightSize);
    
    // 初始化第一个位置的左侧最大高度为自身
    leftMax[0] = height[0];
    
    // 从左到右遍历，计算每个位置左侧的最大高度
    // leftMax[i] 表示 height[0..i] 中的最大值
    for (int i = 1; i < heightSize; i++) {
        leftMax[i] = (leftMax[i - 1] > height[i]) ? leftMax[i - 1] : height[i];
    }
    
    // 分配内存存储每个位置右侧的最大高度
    int* rightMax = (int*)malloc(sizeof(int) * heightSize);
    
    // 初始化最后一个位置的右侧最大高度为自身
    rightMax[heightSize - 1] = height[heightSize - 1];
    
    // 从右到左遍历，计算每个位置右侧的最大高度
    // rightMax[i] 表示 height[i..heightSize-1] 中的最大值
    for (int i = heightSize - 2; i >= 0; i--) {
        rightMax[i] = (rightMax[i + 1] > height[i]) ? rightMax[i + 1] : height[i];
    }
    
    // 计算总的雨水量
    int result = 0;
    
    // 遍历每个位置，计算该位置能接住的雨水量
    for (int i = 0; i < heightSize; i++) {
        // 根据"短板效应"，水面高度由两侧最大高度的较小值决定
        int minHeight = (leftMax[i] < rightMax[i]) ? leftMax[i] : rightMax[i];
        
        // 只有当水面高度大于当前位置高度时才能接住雨水
        if (minHeight > height[i]) {
            // 累加该位置的雨水量
            result += minHeight - height[i];
        }
    }
    
    // 释放动态分配的内存
    free(leftMax);
    free(rightMax);
    
    // 返回接住的雨水总量
    return result;
}
```
---

### 单调栈
```c 
/**
 * @brief 计算柱状图中能够接住的雨水总量
 * 
 * 使用单调栈方法解决接雨水问题。通过维护一个单调递减的栈来追踪可能形成凹陷的柱子，
 * 当遇到较高的柱子时，计算由当前柱子、栈顶柱子和栈中下一个柱子形成的凹陷区域的雨水量。
 * 
 * @param height 柱子高度数组，每个元素代表一个宽度为1的柱子的高度
 * @param heightSize 数组长度，表示柱子的数量
 * @return int 返回能够接住的雨水总量
 * 
 * @example
 * 输入: height = [0,1,0,2,1,0,1,3,2,1,2,1], heightSize = 12
 * 输出: 6
 * 
 * @example
 * 输入: height = [4,2,0,3,2,5], heightSize = 6
 * 输出: 9
 * 
 * @complexity
 * 时间复杂度: O(n) - 每个元素最多入栈和出栈一次
 * 空间复杂度: O(n) - 最坏情况下栈中存储所有元素
 */
int trap(int* height, int heightSize) {
    // 边界条件：柱子数量少于3个时无法接住雨水
    if (heightSize <= 2) return 0;
    
    // 创建栈用于存储柱子的索引
    int* stack = (int*)malloc(sizeof(int) * heightSize);
    int top = -1;  // 栈顶指针，-1表示空栈
    int result = 0; // 累计接住的雨水总量
    
    // 从左到右遍历每个柱子
    for (int i = 0; i < heightSize; i++) {
        // 当栈不为空且当前柱子高度大于栈顶柱子高度时
        while (top >= 0 && height[i] > height[stack[top]]) {
            // 弹出栈顶元素作为凹陷的底部
            int bottom = stack[top--];
            
            // 如果栈为空，说明没有左边界，无法形成凹陷
            if (top < 0) break;
            
            // 计算凹陷区域的水平距离（宽度）
            // 距离 = 右边界索引 - 左边界索引 - 1
            int distance = i - stack[top] - 1;
            
            // 计算凹陷区域的高度
            // 高度 = min(左边界高度, 右边界高度) - 底部高度
            int boundedHeight = (height[i] < height[stack[top]] ? height[i] : height[stack[top]]) - height[bottom];
            
            // 累加雨水量 = 宽度 × 高度
            result += distance * boundedHeight;
        }
        
        // 将当前柱子索引入栈
        stack[++top] = i;
    }
    
    // 释放动态分配的栈内存
    free(stack);
    
    // 返回接住的雨水总量
    return result;
}
```


</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-10-LeetCode13.mdx===
---FRONTMATTER---
slug: LeetCode13
title: 罗马数字转整数
authors: eurekaX
tags: [字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——13题](https://leetcode.cn/problems/roman-to-integer/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 将罗马字符转换为对应的整数值
 * @param c - 输入的罗马数字字符，应为 I, V, X, L, C, D, M 中的一个
 * @return 对应的整数值，如果输入无效则返回 0
 *   'I' -> 1
 *   'V' -> 5
 *   'X' -> 10
 *   'L' -> 50
 *   'C' -> 100
 *   'D' -> 500
 *   'M' -> 1000
 *   其他 -> 0
 */
int romanCharToInt(char c) {
    switch(c) {
        case 'I': return 1;
        case 'V': return 5;
        case 'X': return 10;
        case 'L': return 50;
        case 'C': return 100;
        case 'D': return 500;
        case 'M': return 1000;
        default: return 0;
    }
}

/**
 * 将罗马数字字符串转换为对应的整数
 * 罗马数字的规则：
 * 1. 通常情况下，较小的数字在较大数字的右边，表示相加
 * 2. 特殊情况下，较小的数字在较大数字的左边，表示相减
 *    六种减法情况：IV(4), IX(9), XL(40), XC(90), CD(400), CM(900)
 * 
 * @param s - 输入的罗马数字字符串，应为有效的罗马数字格式
 * @return 对应的整数值
 * 
 * 算法思路：
 * 从左到右遍历字符串，比较当前字符与下一个字符的数值大小：
 * - 如果当前字符数值小于下一个字符数值，则执行减法操作
 * - 否则执行加法操作
 * 
 * 时间复杂度：O(n)，其中 n 是字符串长度
 * 空间复杂度：O(1)
 */
int romanToInt(char* s) {
    int result = 0;
    int len = strlen(s);
    
    for (int i = 0; i < len; i++) {
        // 获取当前字符和下一个字符对应的数值
        // 如果是最后一个字符，则下一个字符值为0
        int current = romanCharToInt(s[i]);
        int next = (i < len - 1) ? romanCharToInt(s[i + 1]) : 0;
        
        // 如果当前字符数值小于下一个字符数值，说明是减法情况（如 IV, IX 等）
        // 需要从结果中减去当前字符的值
        if (current < next) {
            result -= current;
        } else {
            // 正常情况，将当前字符的值加到结果中
            result += current;
        }
    }
    
    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 罗马数字转整数

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：将给定的罗马数字字符串转换为对应的整数值，处理罗马数字的特殊减法规则

📥 **输入输出**：
- **输入**：char* s - 有效的罗马数字字符串，包含字符 I, V, X, L, C, D, M
- **输出**：int - 对应的整数值

---

## 2️⃣ 实现原理

💡 **核心思路**：通过比较相邻字符的数值大小来判断是加法还是减法规则，从左到右遍历字符串进行累加计算

📋 **实现步骤**：
1. 建立罗马字符到整数值的映射关系
2. 从左到右遍历罗马数字字符串
3. 比较当前字符与下一个字符的数值大小
4. 如果当前字符值小于下一个字符值，则执行减法；否则执行加法

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用三元运算符处理边界情况：当访问到最后一个字符时，下一个字符值设为0
- 通过比较相邻元素大小来统一处理加法和减法规则
- 使用switch语句快速映射字符到数值

## 4️⃣ 使用场景

### ✅ 适用情况：
- 罗马数字转换程序
- 历史文献中的数字解析
- 教学演示罗马数字规则

### ⚠️ 前提条件：
- 输入字符串必须是有效的罗马数字格式
- 字符串只包含合法的罗马数字字符 I, V, X, L, C, D, M

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中 n 是字符串长度，需要遍历一次字符串

- 💾 空间复杂度：O(1)，只使用了常数级别的额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空字符串或NULL指针
- 只有一个字符的罗马数字
- 最后一个字符的处理

### 💥 易错点：
- 忘记处理减法规则的特殊情况
- 数组越界访问下一个字符
- 没有正确处理字符串边界条件
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-11-LeetCode12.mdx===
---FRONTMATTER---
slug: LeetCode12
title: 整数转罗马数字
authors: eurekaX
tags: [字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——12题](https://leetcode.cn/problems/integer-to-roman/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 将整数转换为罗马数字
 * @param num 输入的整数 (范围: 1 <= num <= 3999)
 * @return 返回对应的罗马数字字符串，调用者负责释放返回的字符串内存
 */
char* intToRoman(int num) {
    // 定义数值数组，包含所有可能的数值（包括特殊的减法形式）
    // 按从大到小的顺序排列，便于贪心算法处理
    int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    
    // 定义与数值数组对应的罗马数字字符串数组
    char* symbols[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
    
    // 计算数组长度
    int size = sizeof(values) / sizeof(values[0]);
    
    // 分配结果字符串内存，最大情况下3999对应"MMMDCCCCLXXXXVIIII"，长度不会超过20
    // 但为了安全起见，分配足够大的空间
    char* result = (char*)malloc(20 * sizeof(char));
    // 初始化结果字符串为空字符串
	//strcat 函数要求目标字符串必须是以 \0 结尾的有效C字符串，否则行为未定义
    result[0] = '\0';
    
    // 使用贪心算法，从最大的数值开始处理
    for (int i = 0; i < size; i++) {
        // 当前数字大于等于当前数值时，重复处理
        while (num >= values[i]) {
            // 将对应的罗马数字符号追加到结果字符串
            strcat(result, symbols[i]);
            // 从原数字中减去已处理的数值
            num -= values[i];
        }
    }
    
    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 整数转罗马数字

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：将给定的整数按照罗马数字规则转换为对应的罗马数字字符串表示

📥 **输入输出**：
- **输入**：int num - 需要转换的整数，范围为1-3999
- **输出**：char* - 返回表示该整数的罗马数字字符串

---

## 2️⃣ 实现原理

💡 **核心思路**：采用贪心算法，从最大的罗马数字值开始匹配，逐步减去已匹配的值，直到数值为0

📋 **实现步骤**：
1. 预先定义所有可能的数值和对应的罗马数字符号（包括特殊减法形式）
2. 创建结果字符串并初始化为空
3. 从最大值开始遍历数值数组
4. 对于每个数值，只要原数字大于等于它，就将对应符号添加到结果中并减去该数值
5. 重复步骤4直到原数字变为0，返回结果字符串

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用并行数组存储数值和符号，便于同步处理
- 采用贪心策略，每次都选择能匹配的最大数值
- 预先处理特殊减法形式（如4=IV, 9=IX等），简化主逻辑

## 4️⃣ 使用场景

### ✅ 适用情况：
- 数字转换系统中的罗马数字表示
- 教学或演示数字系统转换
- 历史文献或特殊格式的数字显示

### ⚠️ 前提条件：
- 输入必须是1到3999之间的整数
- 只能处理正整数，不支持0或负数

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(1) - 虽然是循环结构，但处理的数值范围有限，最多处理13种不同的数值

- 💾 空间复杂度：O(1) - 使用固定大小的数组和有限长度的结果字符串

## 6️⃣ 注意事项

### 🚩 边界情况：
- 输入为1时，应返回"I"
- 输入为3999时，应返回"MMMCMXCIX"
- 输入为特殊减法形式如4、9、40等

### 💥 易错点：
- 忘记处理特殊减法形式（4、9、40、90、400、900）
- 数值数组和符号数组不同步或顺序错误
- 内存管理问题，忘记释放动态分配的内存
- 没有考虑输入范围限制
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-12-LeetCode58.mdx===
---FRONTMATTER---
slug: LeetCode58
title: 最后一个单词的长度
authors: eurekaX
tags: [字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——58题](https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 返回字符串中最后一个单词的长度
 * @param s 输入字符串，由若干单词组成，单词前后用空格隔开
 * @return 最后一个单词的长度
 */
int lengthOfLastWord(char* s) {
    // 从字符串末尾开始向前遍历，跳过尾部空格
    int end = strlen(s) - 1;
    while (end >= 0 && s[end] == ' ') {
        end--;
    }
    
    // 从最后一个非空格字符开始，向前计算单词长度
    int length = 0;
    while (end >= 0 && s[end] != ' ') {
        length++;
        end--;
    }
    
    // 返回最后一个单词的长度
    return length;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 Length of Last Word

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定一个由若干单词组成的字符串，单词之间用空格分隔，返回最后一个单词的长度。

📥 **输入输出**：
- **输入**：char* s - 一个由英文字母和空格组成的字符串
- **输出**：int - 字符串中最后一个单词的长度

---

## 2️⃣ 实现原理

💡 **核心思路**：采用反向遍历的方法，从字符串末尾开始查找，跳过尾部空格后统计最后一个单词的字符个数。

📋 **实现步骤**：
1. 获取字符串长度，从末尾开始遍历
2. 跳过字符串尾部的所有空格字符
3. 从最后一个非空格字符开始向前统计，直到遇到空格或到达字符串开头
4. 返回统计的字符个数作为最后一个单词的长度

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 反向遍历：避免处理前导空格，直接定位到最后一个单词
- 双指针思想：一个指针用于跳过空格，另一个用于统计单词长度
- 边界处理：正确处理字符串末尾的空格和字符串边界

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要获取文本中最后一个单词的相关信息
- 文本处理中需要分析单词结构
- 字符串解析操作

### ⚠️ 前提条件：
- 输入字符串至少包含一个单词
- 单词仅由英文字母组成，单词之间用空格分隔

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n是字符串的长度，最坏情况下需要遍历整个字符串

- 💾 空间复杂度：O(1)，只使用了常数级别的额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 字符串末尾有多个空格
- 字符串只有一个单词
- 字符串开头有多个空格

### 💥 易错点：
- 忘记处理字符串末尾的空格
- 边界条件判断错误，可能导致数组越界
- 混淆单词长度计算的起止位置

## 7⃣ 补充说明

示例: "Hello World"
```
字符串: "Hello World"
索引:    01234567890

步骤:
1. end = 10 (指向 '\0' 前的字符 'd')
2. 跳过空格: 无尾部空格，end 保持为 10
3. 计算单词长度:
   - 'd'(10) -> length=1, end=9
   - 'l'(9)  -> length=2, end=8
   - 'r'(8)  -> length=3, end=7
   - 'o'(7)  -> length=4, end=6
   - 'W'(6)  -> length=5, end=5
   - ' '(5)  -> 遇到空格，停止
4. 返回 length = 5
```
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-13-LeetCode14.mdx===
---FRONTMATTER---
slug: LeetCode14
title: 最长公共前缀
authors: eurekaX
tags: [字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——14题](https://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 查找字符串数组中的最长公共前缀
 * @param strs 字符串数组
 * @param strsSize 数组长度
 * @return 返回最长公共前缀字符串
 */
char * longestCommonPrefix(char ** strs, int strsSize){
    // 边界条件：如果数组为空，返回空字符串
    if (strsSize == 0) {
        char* result = malloc(1);
        result[0] = '\0';
        return result;
    }
    
    // 边界条件：如果只有一个字符串，返回该字符串
    if (strsSize == 1) {
        char* result = malloc(strlen(strs[0]) + 1);
        strcpy(result, strs[0]);
        return result;
    }
    
    // 获取第一个字符串的长度作为比较基准
    int firstStrLen = strlen(strs[0]);
    
    // 逐个字符比较
    for (int i = 0; i < firstStrLen; i++) {
        char currentChar = strs[0][i];  // 当前比较的字符
        
        // 检查其他所有字符串在位置i处是否都有相同的字符
        for (int j = 1; j < strsSize; j++) {
            // 如果当前字符串在位置i处没有字符或者字符不匹配
            if (i >= strlen(strs[j]) || strs[j][i] != currentChar) {
                // 找到公共前缀的结束位置，分配内存并复制前缀
                char* result = malloc(i + 1);
                strncpy(result, strs[0], i);
                result[i] = '\0';  // 添加字符串结束符
                return result;
            }
        }
    }
    
    // 如果第一个字符串的所有字符都是公共前缀
    char* result = malloc(firstStrLen + 1);
    strcpy(result, strs[0]);
    return result;
}

```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 最长公共前缀

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：查找字符串数组中所有字符串的最长公共前缀，如果不存在公共前缀则返回空字符串

📥 **输入输出**：
- **输入**：`strs` - 字符串数组，`strsSize` - 数组长度
- **输出**：返回最长公共前缀字符串（需要手动释放内存）

---

## 2️⃣ 实现原理

💡 **核心思路**：采用垂直扫描法，从左到右逐个字符比较所有字符串在相同位置的字符是否一致

📋 **实现步骤**：
1. 处理边界情况：空数组和单字符串数组
2. 以第一个字符串为基准，从第0个字符开始逐个检查
3. 对每个字符位置，遍历所有字符串验证该位置字符是否相同
4. 一旦发现不匹配或某个字符串长度不足，立即返回当前找到的公共前缀

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 垂直扫描：按列比较而非按行比较，提高比较效率
- 提前终止：发现不匹配时立即停止，避免无效计算
- 动态内存分配：根据实际需要的前缀长度分配内存空间

## 4️⃣ 使用场景

### ✅ 适用情况：
- 查找多个字符串的公共前缀
- 文件路径匹配
- 自动补全功能中的前缀匹配

### ⚠️ 前提条件：
- 输入字符串数组不为NULL
- 所有字符串只包含小写英文字母

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(S)，其中S是所有字符串的字符总数，最坏情况下需要遍历所有字符

- 💾 空间复杂度：O(1)，不考虑返回值的情况下只使用常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空数组（strsSize = 0）
- 单个字符串数组（strsSize = 1）
- 包含空字符串的数组

### 💥 易错点：
- 忘记手动释放返回的字符串内存导致内存泄漏
- 没有正确处理字符串长度不足的情况导致数组越界
- 字符串结束符'\0'处理不当

## 7️⃣ 补充说明
```
/**
 * 查找字符串数组中的最长公共前缀
 * @param strs 字符串数组
 * @param strsSize 数组长度
 * @return 返回最长公共前缀字符串
 */
char * longestCommonPrefix(char ** strs, int strsSize){
```
这个函数接收一个字符串数组 `strs` 和数组长度 `strsSize`，返回一个新分配内存的字符串，包含最长公共前缀。

### 第一步：处理边界条件
```
    // 边界条件：如果数组为空，返回空字符串
    if (strsSize == 0) {
        char* result = malloc(1);
        result[0] = '\0';
        return result;
    }
```
如果数组为空，直接返回一个空字符串。这里 `malloc(1)` 分配一个字节用于存储字符串结束符 `'\0'`。

例子：`strs = []`，`strsSize = 0`

- 直接返回 `""	`
```
    // 边界条件：如果只有一个字符串，返回该字符串
    if (strsSize == 1) {
        char* result = malloc(strlen(strs[0]) + 1);
        strcpy(result, strs[0]);
        return result;
    }
```
如果只有一个字符串，那么它本身就是公共前缀，复制该字符串并返回。

例子：`strs = ["hello"]`，`strsSize = 1`

- 直接返回 `"hello"`

### 第二步：获取比较基准	
```
    // 获取第一个字符串的长度作为比较基准
    int firstStrLen = strlen(strs[0]);
```
以第一个字符串的长度作为比较的上限，因为公共前缀不可能比任何一个字符串更长。

例子：`strs = ["flower", "flow", "flight"]`

- `firstStrLen = 6`（"flower"的长度）

### 第三步：逐字符垂直比较
```
    // 逐个字符比较
    for (int i = 0; i < firstStrLen; i++) {
        char currentChar = strs[0][i];  // 当前比较的字符
        
        // 检查其他所有字符串在位置i处是否都有相同的字符
        for (int j = 1; j < strsSize; j++) {
            // 如果当前字符串在位置i处没有字符或者字符不匹配
            if (i >= strlen(strs[j]) || strs[j][i] != currentChar) {
                // 找到公共前缀的结束位置，分配内存并复制前缀
                char* result = malloc(i + 1);
                strncpy(result, strs[0], i);
                result[i] = '\0';  // 添加字符串结束符
                return result;
            }
        }
    }
```
**算法核心：垂直扫描法**

这是算法的核心部分，采用垂直扫描的方式：

1. 外层循环遍历第一个字符串的每个字符位置（索引 `i`）
2. 内层循环检查其他所有字符串在相同位置 `i` 的字符是否与第一个字符串相同
3. 如果发现不匹配或某个字符串在位置 `i` 没有字符，则找到了公共前缀的结束位置

**详细例子分析**

**示例 1:** `strs = ["flower", "flow", "flight"]`

| 字符位置 | 比较内容 | 结果 |
|---------|---------|------|
| i=0 | 'f' vs 'f' vs 'f' | ✓ 匹配 |
| i=1 | 'l' vs 'l' vs 'l' | ✓ 匹配 |
| i=2 | 'o' vs 'o' vs 'i' | ✗ 不匹配，返回 "fl" |

**示例 2:** `strs = ["dog", "racecar", "car"]`

| 字符位置 | 比较内容 | 结果 |
|---------|---------|------|
| i=0 | 'd' vs 'r' vs 'c' | ✗ 不匹配，返回 "" |

### 第四步：处理完全匹配的情况
```
    // 如果第一个字符串的所有字符都是公共前缀
    char* result = malloc(firstStrLen + 1);
    strcpy(result, strs[0]);
    return result;
```
### 特殊情况处理与完整执行示例

**全匹配情况处理**

如果第一个字符串的所有字符都是公共前缀（即所有字符串完全相同或都是第一个字符串的前缀），则返回第一个字符串的完整拷贝。

**例子分析：**

**示例 1**: `strs = ["flow", "flow", "flow"]`
- 所有字符都匹配，返回 `"flow"`

**示例 2**: `strs = ["flow", "flower", "flight"]`
- 在比较过程中就会发现不匹配，不会执行到全匹配处理部分

**完整执行示例**

以 `strs = ["flower", "flow", "flight"]` 为例完整执行过程：

1. `strsSize = 3`，不满足边界条件
2. `firstStrLen = 6`
3. 开始循环：
   - `i=0`: `currentChar = 'f'`
     - `j=1`: `strs[1][0] = 'f'` ✓ 匹配
     - `j=2`: `strs[2][0] = 'f'` ✓ 匹配
   - `i=1`: `currentChar = 'l'`
     - `j=1`: `strs[1][1] = 'l'` ✓ 匹配
     - `j=2`: `strs[2][1] = 'l'` ✓ 匹配
   - `i=2`: `currentChar = 'o'`
     - `j=1`: `strs[1][2] = 'o'` ✓ 匹配
     - `j=2`: `strs[2][2] = 'i'` ✗ 不匹配！

4. 分配内存，复制前2个字符 `"fl"` 并返回


</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-14-LeetCode151.mdx===
---FRONTMATTER---
slug: LeetCode151
title: 反转字符串中的单词
authors: eurekaX
tags: [字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——151题](https://leetcode.cn/problems/reverse-words-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c

/**
 * 移除字符串中的多余空格
 * @param s 输入字符串
 * @return 处理后的字符串长度
 */
int removeExtraSpaces(char* s) {
    int slow = 0;
    int fast = 0;
    
    // 跳过前导空格
    while (s[fast] == ' ') {
        fast++;
    }
    
    // 处理中间部分：移除单词间多余的空格
    while (fast < strlen(s)) {
        // 如果当前字符不是空格，或者是第一个空格，则保留
        if (s[fast] != ' ' || (fast > 0 && s[fast - 1] != ' ')) {
            s[slow++] = s[fast];
        }
        fast++;
    }
    
    // 处理结尾可能的空格
    if (slow > 0 && s[slow - 1] == ' ') {
        slow--;
    }
    
    s[slow] = '\0';  // 添加字符串结束符
    return slow;
}

/**
 * 反转字符串指定范围内的字符
 * @param s 字符串
 * @param start 起始位置（包含）
 * @param end 结束位置（包含）
 */
void reverseString(char* s, int start, int end) {
    while (start < end) {
        char temp = s[start];
        s[start] = s[end];
        s[end] = temp;
        start++;
        end--;
    }
}

/**
 * 反转字符串中单词的顺序
 * @param s 输入字符串
 * @return 反转后的字符串
 */
char* reverseWords(char* s) {
    // 第一步：移除多余空格
    int len = removeExtraSpaces(s);
    
    // 第二步：反转整个字符串
    reverseString(s, 0, len - 1);
    
    // 第三步：反转每个单词
    int start = 0;
    for (int i = 0; i <= len; i++) {
        // 遇到空格或字符串结尾时，反转当前单词
        if (s[i] == ' ' || s[i] == '\0') {
            reverseString(s, start, i - 1);
            start = i + 1;
        }
    }
    
    return s;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 反转字符串中的单词

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定一个字符串，反转其中单词的顺序，同时处理多余的空格问题

📥 **输入输出**：
- **输入**：`char* s` - 输入的字符串，可能包含前导空格、尾随空格或单词间多个空格
- **输出**：`char*` - 返回单词顺序颠倒且单词间仅用单个空格分隔的字符串

---

## 2️⃣ 实现原理

💡 **核心思路**：使用双指针技术移除多余空格，然后通过整体反转加局部反转的方式实现单词顺序调换

📋 **实现步骤**：
1. 使用双指针移除字符串中的前导空格、尾随空格和单词间的多余空格
2. 反转整个字符串
3. 遍历字符串，识别每个单词的边界并单独反转每个单词
4. 返回处理后的字符串

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **双指针技术**：用于高效地移除多余空格，避免使用额外空间
- **两次反转法**：先整体反转再局部反转，巧妙实现单词顺序调换
- **原地操作**：所有操作都在原字符串上进行，满足O(1)空间复杂度要求

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要反转句子中单词顺序的文本处理
- 内存受限环境下处理字符串
- 需要规范化空格的字符串处理场景

### ⚠️ 前提条件：
- 字符串必须是可变的（C语言中为字符数组）
- 字符串至少包含一个单词

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n是字符串长度，需要遍历字符串常数次

- 💾 空间复杂度：O(1)，只使用常数级别的额外空间，原地修改字符串

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空字符串或只包含空格的字符串
- 只有一个单词的字符串
- 字符串中包含大量多余空格的情况

### 💥 易错点：
- 忘记处理前导空格和尾随空格
- 单词间空格处理不正确，可能保留多个空格
- 反转区间边界处理错误，导致数组越界

## 7️⃣ 补充说明

以字符串 " the sky is blue " 为例来演示整个算法过程：

### 初始状态

输入字符串：`" the sky is blue "`

### 第一步：移除多余空格

执行 `removeExtraSpaces` 函数：
```
原字符串: "  the sky is blue  "
          ↑
        fast=0, slow=0
```


过程：
- fast=0,1: 空格，跳过
- fast=2: 't' -> s[0]='t', slow=1
- fast=3: 'h' -> s[1]='h', slow=2
- fast=4: 'e' -> s[2]='e', slow=3
- fast=5: 空格 -> s[3]=' ', slow=4
- fast=6: 空格 -> 与前一字符都是空格，跳过
- fast=7: 's' -> s[4]='s', slow=5
- fast=8: 'k' -> s[5]='k', slow=6
- fast=9: 'y' -> s[6]='y', slow=7
- fast=10: 空格 -> s[7]=' ', slow=8
- fast=11: 'i' -> s[8]='i', slow=9
- fast=12: 's' -> s[9]='s', slow=10
- fast=13: 空格 -> s[10]=' ', slow=11
- fast=14: 'b' -> s[11]='b', slow=12
- fast=15: 'l' -> s[12]='l', slow=13
- fast=16: 'u' -> s[13]='u', slow=14
- fast=17: 'e' -> s[14]='e', slow=15
- fast=18,19: 空格 -> 检查到结尾空格，不做处理

最终结果: "the sky is blue"
索引:      0123456789ABCDEF
长度: 15

### 第二步：反转整个字符串

执行 `reverseString(s, 0, 14)`：
```
原字符串: "the sky is blue"
反转后:   "eulb si yks eht"
```
### 第三步：逐个反转单词

遍历字符串，对每个单词进行反转：

  1.处理第一个单词 "eulb"（索引0-3）：
```
反转前: "eulb si yks eht"
反转后: "blue si yks eht"
```  
  2.处理第二个单词 "si"（索引5-6）：
```
反转前: "blue si yks eht"
反转后: "blue is yks eht"
```  

  3.处理第三个单词 "yks"（索引8-10）：
```
反转前: "blue is yks eht"
反转后: "blue is sky eht"
```  

  4.处理第四个单词 "eht"（索引12-14）：
``` 
反转前: "blue is sky eht"
反转后: "blue is sky the"  
```

### 最终结果

输出字符串：`"blue is sky the"`

这个过程通过三步操作完成了单词顺序的反转：

  1.首先清理输入字符串，移除多余空格

  2.然后整体反转字符串

  3.最后将每个单词再次反转以恢复其正确顺序

这种方法的优势在于只需要常数级别的额外空间，完全在原字符串上进行操作。


</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-15-LeetCode6.mdx===
---FRONTMATTER---
slug: LeetCode6
title: Z 字形变换
authors: eurekaX
tags: [数组]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——6题](https://leetcode.cn/problems/zigzag-conversion/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * Z字形变换函数
 * @param s 输入字符串
 * @param numRows 指定行数
 * @return 变换后的字符串
 * 
 * 解题思路:
 * 1. 对于第0行和第numRows-1行，字符间隔固定为2*(numRows-1)
 * 2. 对于中间行，字符交替出现在两个等差数列中
 * 3. 特殊情况：numRows=1时直接返回原字符串
 */
char* convert(char* s, int numRows) {
    int len = strlen(s);
    
    // 特殊情况：行数为1或字符串长度小于行数时，直接返回原字符串
    if (numRows == 1 || numRows >= len) {
        return s;
    }
    
    // 分配结果字符串空间
    char* result = (char*)malloc((len + 1) * sizeof(char));
    int index = 0;
    
    // 计算周期长度
    int cycleLen = 2 * numRows - 2;
    
    // 按行遍历
    for (int i = 0; i < numRows; i++) {
        // 遍历每个周期
        for (int j = 0; j + i < len; j += cycleLen) {
            // 每行的第一个字符（垂直列上的字符）
            result[index++] = s[j + i];
            
            // 中间行的第二个字符（斜线上的字符）
            // 条件：不是第一行和最后一行，且索引不越界
            if (i != 0 && i != numRows - 1 && j + cycleLen - i < len) {
                result[index++] = s[j + cycleLen - i];
            }
        }
    }
    
    result[index] = '\0';  // 字符串结束符
    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 Z字形变换

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：将字符串按照Z字形方式排列后，按行读取生成新字符串

📥 **输入输出**：
- **输入**：`s`（输入字符串），`numRows`（指定行数）
- **输出**：按Z字形排列后逐行读取的新字符串

---

## 2️⃣ 实现原理

💡 **核心思路**：通过数学方法直接计算每行字符的位置，避免构造二维矩阵

📋 **实现步骤**：
1. 处理特殊情况：当`numRows`为1或大于等于字符串长度时直接返回原字符串
2. 计算Z字形周期长度：`2*numRows-2`
3. 按行遍历，对每行计算对应字符位置
4. 对于首尾行，字符间隔固定；对于中间行，每个周期有两个字符位置

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 利用周期性规律避免实际构造Z字形矩阵
- 通过索引计算直接定位字符位置
- 分别处理首尾行和中间行的不同字符分布规律

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要按特定规律重新排列字符串
- 字符串变换类问题
- 需要优化空间复杂度的场景

### ⚠️ 前提条件：
- 输入字符串非空
- 行数大于0

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n为字符串长度，每个字符访问一次

- 💾 空间复杂度：O(1)，不考虑结果字符串的话只使用常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- `numRows = 1`时，直接返回原字符串
- 字符串长度为1的情况
- `numRows`大于字符串长度的情况

### 💥 易错点：
- 忘记处理`numRows = 1`的特殊情况导致除零错误
- 中间行字符位置计算错误
- 字符串结束符`\0`忘记添加

## 7⃣ 补充说明

### 整体思路

这个算法采用**按行读取**的方式，直接从原字符串中按Z字形顺序提取字符。

### 代码详解

1. 初始化和特殊情况处理
```
int len = strlen(s);
// 特殊情况：行数为1或字符串长度小于行数时，直接返回原字符串
if (numRows == 1 || numRows >= len) {
    return s;
}
```
解释：

- 当 `numRows = 1` 时，Z字形排列就是原字符串本身
- 当 `numRows >= len` 时，每行最多一个字符，结果也是原字符串

2. 关键参数计算
```
int cycleLen = 2 * numRows - 2;
```
解释：计算Z字形的周期长度

- 例如 `numRows = 3` 时，`cycleLen = 2*3-2 = 4`
- 这意味着每`4`个字符为一个完整的`V`字形周期

3. 按行遍历核心逻辑
```
for (int i = 0; i < numRows; i++) {
    for (int j = 0; j + i < len; j += cycleLen) {
        result[index++] = s[j + i];
        
        if (i != 0 && i != numRows - 1 && j + cycleLen - i < len) {
            result[index++] = s[j + cycleLen - i];
        }
    }
}
```

### 详细例子演示

以 `s = "PAYPALISHIRING"`, `numRows = 3` 为例：
```
原字符串索引: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
原字符串:     P A Y P A L I S H I R  I  N  G
cycleLen = 2*3-2 = 4
```
第0行 (i=0)：
```
j=0:  j+i=0, 取s[0]='P'
j=4:  j+i=4, 取s[4]='A'  
j=8:  j+i=8, 取s[8]='H'
j=12: j+i=12,取s[12]='N'
第0行结果: PAHN
```

第1行 (i=1)：
```
j=0: j+i=1, 取s[1]='A'
     j+cycleLen-i = 0+4-1=3, 取s[3]='P'
j=4: j+i=5, 取s[5]='L'
     j+cycleLen-i = 4+4-1=7, 取s[7]='S'
j=8: j+i=9, 取s[9]='I'
     j+cycleLen-i = 8+4-1=11,取s[11]='I'
j=12:j+i=13,取s[13]='G'
第1行结果: APLSIIG
```

第2行 (i=2)：
```
j=0: j+i=2, 取s[2]='Y'
j=4: j+i=6, 取s[6]='I'
j=8: j+i=10,取s[10]='R'
第2行结果: YIR
```

### Z字形图形化理解
```
P     A     H     N        // i=0, 索引: 0,4,8,12
 A   P L   S I   I G       // i=1, 索引: 1,3,5,7,9,11,13
  Y     I     R            // i=2, 索引: 2,6,10
```

### 核心规律

  1.垂直列字符：位于索引 `j + i` 处

  2.斜线字符：位于索引 `j + cycleLen - i` 处（仅中间行）

  3.周期跳跃：每次跳跃 `cycleLen` 个位置
  
**时间复杂度**
- 时间复杂度：O(n)，每个字符只访问一次
- 空间复杂度：O(n)，用于存储结果字符串

这种方法避免了构造二维数组的额外空间，直接通过数学计算定位字符位置，效率很高。

这道题我至今**尚未完全理解**（20250815）



</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-16-LeetCode28.mdx===
---FRONTMATTER---
slug: LeetCode28
title: 找出字符串中第一个匹配项的下标
authors: eurekaX
tags: [字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——28题](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 在haystack字符串中查找needle字符串的第一个匹配位置
 * @param haystack 主字符串
 * @param needle 要查找的子字符串
 * @return 返回第一次匹配的索引，如果未找到则返回-1
 */
int strStr(char* haystack, char* needle) {
    // 边界条件处理
    if (needle == NULL || *needle == '\0') {
        return 0;  // 空字符串在任何字符串的索引0处匹配
    }
    
    if (haystack == NULL || *haystack == '\0') {
        return -1; // 主字符串为空但要查找的字符串非空，返回-1
    }
    
    int hLen = strlen(haystack);  // 主字符串长度
    int nLen = strlen(needle);    // 子字符串长度
    
    // 如果子字符串比主字符串长，不可能匹配
    if (nLen > hLen) {
        return -1;
    }
    
    // 构建next数组（KMP算法的核心）
    int* next = (int*)malloc(sizeof(int) * nLen);
    next[0] = 0;  // 第一个字符的最长相等前后缀长度为0
    int j = 0;    // 前缀末尾索引
    
    // 构造next数组
    for (int i = 1; i < nLen; i++) {
        // 当前后缀不匹配时，回退到前一个位置的next值
        while (j > 0 && needle[i] != needle[j]) {
            j = next[j - 1];
        }
        // 如果当前字符匹配，前缀长度加1
        if (needle[i] == needle[j]) {
            j++;
        }
        next[i] = j;  // 记录当前位置的最长相等前后缀长度
    }
    
    // KMP匹配过程
    j = 0;  // needle的索引
    for (int i = 0; i < hLen; i++) {
        // 当字符不匹配时，根据next数组回退
        while (j > 0 && haystack[i] != needle[j]) {
            j = next[j - 1];
        }
        // 如果字符匹配，移动needle的指针
        if (haystack[i] == needle[j]) {
            j++;
        }
        // 如果needle已经完全匹配，返回匹配起始位置
        if (j == nLen) {
            free(next);  // 释放内存
            return i - nLen + 1;
        }
    }
    
    free(next);  // 释放内存
    return -1;   // 未找到匹配
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 找出字符串中第一个匹配项的下标

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：在主字符串(haystack)中查找子字符串(needle)第一次出现的位置，若不存在则返回-1

📥 **输入输出**：
- **输入**：
  - `haystack`：主字符串，被搜索的字符串
  - `needle`：模式字符串，需要查找的子字符串
- **输出**：返回`needle`在`haystack`中第一次出现的索引位置，如果不存在则返回-1

---

## 2️⃣ 实现原理

💡 **核心思路**：使用KMP(Knuth-Morris-Pratt)字符串匹配算法，通过预处理模式串构建next数组来避免不必要的字符比较

📋 **实现步骤**：
1. 处理边界情况：空字符串、主串为空等情况
2. 构建next数组：记录模式串中每个位置的最长相等前后缀长度
3. 使用KMP算法进行匹配：利用next数组避免主串指针回溯
4. 返回匹配结果：找到匹配则返回起始位置，否则返回-1

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **KMP算法应用**：通过构建next数组实现高效的字符串匹配
- **双指针技术**：使用两个指针分别遍历主串和模式串
- **状态回退优化**：利用next数组实现匹配失败时的智能回退，避免重复比较

## 4️⃣ 使用场景

### ✅ 适用情况：
- 在大文本中查找特定子串的位置
- 需要高效字符串匹配的场景
- 文本编辑器的查找功能实现

### ⚠️ 前提条件：
- 输入参数为有效的C风格字符串
- 字符串以'\0'结尾

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n + m)，其中n是主串长度，m是模式串长度，避免了暴力算法的O(n*m)复杂度

- 💾 空间复杂度：O(m)，主要用于存储next数组

## 6️⃣ 注意事项

### 🚩 边界情况：
- needle为空字符串时应返回0
- haystack为空字符串但needle非空时应返回-1
- needle长度大于haystack时直接返回-1

### 💥 易错点：
- next数组的构建逻辑容易出错，特别是回退条件的判断
- 匹配成功后的返回索引计算容易错误，应返回i - nLen + 1
- 内存管理需要注意，使用完next数组后需要释放内存

## 7️⃣ 注意事项

### KMP算法原理简述

`KMP算法`是一种改进的字符串匹配算法，它的核心思想是当字符匹配失败时，利用已经匹配的部分信息，尽可能地跳过一些不必要的比较。

### 第一步：边界条件处理
```
if (needle == NULL || *needle == '\0') {
    return 0;  // 空字符串在任何字符串的索引0处匹配
}

if (haystack == NULL || *haystack == '\0') {
    return -1; // 主字符串为空但要查找的字符串非空，返回-1
}
```
这部分处理特殊情况：

- 如果要查找的字符串为空，则在任何字符串的第0个位置都能找到它
- 如果主字符串为空但要查找的字符串不为空，则肯定找不到

### 第二步：获取字符串长度并比较
```
int hLen = strlen(haystack);  // 主字符串长度
int nLen = strlen(needle);    // 子字符串长度

if (nLen > hLen) {
    return -1;
}
```
如果要查找的字符串比主字符串还长，那肯定找不到。

### 第三步：构建next数组（KMP算法的核心）
```
int* next = (int*)malloc(sizeof(int) * nLen);
next[0] = 0;  // 第一个字符的最长相等前后缀长度为0
int j = 0;    // 前缀末尾索引

// 构造next数组
for (int i = 1; i < nLen; i++) {
    // 当前后缀不匹配时，回退到前一个位置的next值
    while (j > 0 && needle[i] != needle[j]) {
        j = next[j - 1];
    }
    // 如果当前字符匹配，前缀长度加1
    if (needle[i] == needle[j]) {
        j++;
    }
    next[i] = j;  // 记录当前位置的最长相等前后缀长度
}
```
我们通过一个具体例子来理解next数组的构建过程。假设`needle = "ababa"`：

| i | needle[i] | j | next[i] | 说明 |
|---|-----------|---|---------|------|
| 0 | a | 0 | 0 | 初始值 |
| 1 | b | 0 | 0 | 'a' != 'b'，j保持0 |
| 2 | a | 1 | 1 | 'b' != 'a'，j回退到next[0]=0，然后'a' == 'a'，j=1 |
| 3 | b | 2 | 2 | 'a' != 'b'，j回退到next[1]=0，然后'b' == 'b'，j=1，再'a' == 'a'，j=2 |
| 4 | a | 3 | 3 | 同上逻辑，j=3 |

所以`next = [0, 0, 1, 2, 3]`

### 第四步：KMP匹配过程
```
j = 0;  // needle的索引
for (int i = 0; i < hLen; i++) {
    // 当字符不匹配时，根据next数组回退
    while (j > 0 && haystack[i] != needle[j]) {
        j = next[j - 1];
    }
    // 如果字符匹配，移动needle的指针
    if (haystack[i] == needle[j]) {
        j++;
    }
    // 如果needle已经完全匹配，返回匹配起始位置
    if (j == nLen) {
        free(next);
        return i - nLen + 1;
    }
}
```
示例1：`haystack = "sadbutsad", needle = "sad"`

首先构建的next数组为[0, 0, 0]（因为"sad"中没有重复的前后缀）

| i | haystack[i] | j | needle[j] | 匹配情况 | 说明 |
|---|-------------|---|-----------|----------|------|
| 0 | s | 0 | s | 匹配 | j++ → 1 |
| 1 | a | 1 | a | 匹配 | j++ → 2 |
| 2 | d | 2 | d | 匹配 | j++ → 3 |
| - | - | 3 | - | - | j==nLen，匹配成功，返回 2-3+1=0 |

所以返回索引0。

示例2：`haystack = "leetcode", needle = "leeto"`

构建的next数组为[0, 0, 0, 0, 0]（因为"leeto"中没有重复前后缀）

| i | haystack[i] | j | needle[j] | 匹配情况 | 说明 |
|---|-------------|---|-----------|----------|------|
| 0 | l | 0 | l | 匹配 | j++ → 1 |
| 1 | e | 1 | e | 匹配 | j++ → 2 |
| 2 | e | 2 | e | 匹配 | j++ → 3 |
| 3 | t | 3 | t | 匹配 | j++ → 4 |
| 4 | c | 4 | o | 不匹配 | j回退到next[3]=0，仍不匹配，j保持0 |
| 5 | o | 0 | l | 不匹配 | j保持0 |
| 6 | d | 0 | l | 不匹配 | j保持0 |
| 7 | e | 0 | l | 不匹配 | j保持0 |

整个过程j从未达到nLen=5，所以返回-1。

### KMP算法的优势

相比暴力匹配算法，KMP算法的优势在于：

1.时间复杂度从O(n*m)降低到O(n+m)

2.当发生不匹配时，主串的指针不会回溯，避免了重复比较

3.利用已匹配的信息，通过next数组决定模式串应该移动多少位

这就是KMP算法解决字符串匹配问题的完整过程。

这个 `KMP算法` 我至今不理解！（20250816）

</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-17-LeetCode68.mdx===
---FRONTMATTER---
slug: LeetCode68
title: 文本左右对齐
authors: eurekaX
tags: [字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——68题](https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 根据给定的单词数组和最大宽度，生成左右对齐的文本行
 * @param words 单词数组
 * @param wordsSize 单词数量
 * @param maxWidth 每行的最大字符数
 * @param returnSize 返回结果数组的大小
 * @return 对齐后的文本行数组
 */
char ** fullJustify(char ** words, int wordsSize, int maxWidth, int* returnSize){
    // 分配结果数组内存
    char **result = (char **)malloc(sizeof(char *) * wordsSize);
    *returnSize = 0;
    
    int i = 0;
    // 遍历所有单词
    while (i < wordsSize) {
        // 确定当前行可以容纳的单词范围 [i, j)
        int j = i;
        int lineLength = 0;  // 当前行单词总长度（不包括空格）
        
        // 贪心算法：尽可能多地放置单词
        // 条件：还有单词未处理 且 当前行还能放下下一个单词（包括必要的空格）
        while (j < wordsSize && lineLength + strlen(words[j]) + (j - i) <= maxWidth) {
            lineLength += strlen(words[j]);
            j++;
        }
        
        // 分配当前行内存
        result[*returnSize] = (char *)malloc(sizeof(char) * (maxWidth + 1));
        result[*returnSize][maxWidth] = '\0';  // 字符串结束符
        
        // 计算空格分配
        int wordCount = j - i;  // 当前行的单词数
        int spaces = maxWidth - lineLength;  // 需要填充的空格总数
        
        // 处理不同情况
        if (j == wordsSize) {
            // 最后一行：左对齐
            int pos = 0;
            for (int k = i; k < j; k++) {
                // 复制单词
                for (int l = 0; l < strlen(words[k]); l++) {
                    result[*returnSize][pos++] = words[k][l];
                }
                // 单词间添加一个空格（除了最后一个单词）
                if (k < j - 1) {
                    result[*returnSize][pos++] = ' ';
                }
            }
            // 在行尾填充剩余空格
            while (pos < maxWidth) {
                result[*returnSize][pos++] = ' ';
            }
        } else if (wordCount == 1) {
            // 只有一个单词：左对齐，右侧填充空格
            int pos = 0;
            // 复制单词
            for (int k = 0; k < strlen(words[i]); k++) {
                result[*returnSize][pos++] = words[i][k];
            }
            // 右侧填充空格
            for (int k = 0; k < spaces; k++) {
                result[*returnSize][pos++] = ' ';
            }
        } else {
            // 多个单词且非最后一行：左右对齐
            int avgSpaces = spaces / (wordCount - 1);  // 平均每个间隔的空格数
            int extraSpaces = spaces % (wordCount - 1);  // 需要额外分配的空格数
            
            int pos = 0;
            for (int k = i; k < j; k++) {
                // 复制单词
                for (int l = 0; l < strlen(words[k]); l++) {
                    result[*returnSize][pos++] = words[k][l];
                }
                // 添加空格（除了最后一个单词）
                if (k < j - 1) {
                    // 先添加平均分配的空格
                    for (int l = 0; l < avgSpaces; l++) {
                        result[*returnSize][pos++] = ' ';
                    }
                    // 再分配额外的空格（左侧优先）
                    if (k - i < extraSpaces) {
                        result[*returnSize][pos++] = ' ';
                    }
                }
            }
        }
        
        (*returnSize)++;
        i = j;  // 移动到下一行的第一个单词
    }
    
    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 字符串左右对齐

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定一个单词数组和最大行宽，将单词重新排版成每行恰好有 maxWidth 个字符且左右两端对齐的文本，最后一行左对齐。

📥 **输入输出**：
- **输入**：
  - `words`: 单词数组，每个元素是一个非空字符串
  - `wordsSize`: 单词数组长度
  - `maxWidth`: 每行最大字符数
- **输出**：
  - 返回重新排版后的字符串数组
  - `returnSize`: 返回数组的实际大小

---

## 2️⃣ 实现原理

💡 **核心思路**：使用贪心算法，每行尽可能多地放置单词，然后根据对齐规则分配空格。

📋 **实现步骤**：
1. 遍历单词数组，确定每一行可以放置的单词范围
2. 根据行的类型（最后一行、单个单词行、普通行）采用不同的空格分配策略
3. 对于普通行，计算平均空格数和额外空格数，左侧优先分配额外空格
4. 构造每行字符串并添加到结果数组中

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **贪心策略**：每行尽可能多地放置单词，通过 `lineLength + strlen(words[j]) + (j - i) <= maxWidth` 判断
- **空格均匀分配**：使用除法和取模运算分别计算平均空格数和额外空格数
- **边界处理**：针对最后一行、单个单词行等特殊情况采用不同的对齐策略

## 4️⃣ 使用场景

### ✅ 适用情况：
- 文本排版和格式化
- 打印预览和文档处理
- 控制台输出格式化

### ⚠️ 前提条件：
- 每个单词长度不超过 maxWidth
- 单词数组至少包含一个单词
- maxWidth 大于等于1

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(N × M)，其中 N 是单词总数，M 是最大宽度，需要遍历每个单词并构造每行字符串

- 💾 空间复杂度：O(M)，用于存储每行结果字符串

## 6️⃣ 注意事项

### 🚩 边界情况：
- 最后一行需要特殊处理为左对齐
- 只包含一个单词的行需要左对齐
- 空格不能均匀分配时需要左侧优先

### 💥 易错点：
- 忘记处理最后一行的左对齐特殊情况
- 空格分配不均匀，右侧空格多于左侧
- 单词间空格计算错误，没有考虑单词数量与间隔数的关系

## 7⃣ 补充说明

以示例1为例：

- `words = ["This", "is", "an", "example", "of", "text", "justification."]`
- `maxWidth = 16`

## 执行步骤详解

### 第一行处理

#### 确定单词范围：
- 从索引0开始（"This"）
- 尝试添加单词："This"(4字符) + "is"(2字符) + "an"(2字符) + "example"(7字符)
- 计算总长度：4 + 2 + 2 + 7 = 15字符
- 计算空格：3个间隔（4个单词间需要3个空格）
- 总计：15 + 3 = 18 > 16，超出限制
- 回退到："This"(4) + "is"(2) + "an"(2) = 8字符，2个间隔
- 总计：8 + 2 = 10 ≤ 16，符合要求
- 所以第一行单词为：["This", "is", "an"]

#### 空格分配：
- 单词总长度：4 + 2 + 2 = 8
- 需要空格数：16 - 8 = 8个空格
- 单词间隔数：3 - 1 = 2个间隔
- 平均每个间隔：8 / 2 = 4个空格
- 额外空格：8 % 2 = 0个
- 每个间隔都放4个空格

#### 构造结果：
```
"This" + "    " + "is" + "    " + "an" = "This    is    an"
```

### 第二行处理

#### 确定单词范围：
- 从索引3开始（"example"）
- 尝试添加："example"(7) + "of"(2) + "text"(4) = 13字符
- 空格间隔：2个
- 总计：13 + 2 = 15 ≤ 16，符合要求
- 所以第二行单词为：["example", "of", "text"]

#### 空格分配：
- 单词总长度：7 + 2 + 4 = 13
- 需要空格数：16 - 13 = 3个空格
- 单词间隔数：3 - 1 = 2个间隔
- 平均每个间隔：3 / 2 = 1个空格
- 额外空格：3 % 2 = 1个
- 第一个间隔放：1 + 1 = 2个空格
- 第二个间隔放：1个空格

#### 构造结果：
```
"example" + "  " + "of" + " " + "text" = "example  of text"
```

### 第三行处理（最后一行）

#### 确定单词范围：
- 从索引6开始（"justification."）
- 只剩这一个单词，长度为15 ≤ 16
- 所以第三行为：["justification."]

#### 特殊处理：
- 由于是最后一行，采用左对齐
- 单词后不添加额外空格（只有一个单词）
- 行尾填充剩余空格：16 - 15 = 1个空格

#### 构造结果：
```
"justification." + " " = "justification.  "
```

## 最终输出
```
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
```

通过这个例子可以看出，算法的核心在于：

1.贪心地确定每行单词数量

2.根据行的类型采用不同的空格分配策略

3.特别处理最后一行的左对齐要求
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-18-LeetCode125.mdx===
---FRONTMATTER---
slug: LeetCode125
title: 验证回文串
authors: eurekaX
tags: [双指针,字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——125题](https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 判断字符串是否为回文串
 * 
 * 解题思路：
 * 1. 使用双指针法，从字符串两端向中间移动
 * 2. 跳过所有非字母数字字符
 * 3. 将大写字母转换为小写进行比较
 * 4. 如果所有对应字符都相等，则为回文串
 * 
 * @param s 输入字符串
 * @return true 表示是回文串，false 表示不是回文串
 */
bool isPalindrome(char * s){
    // 检查输入是否为空指针
    if (s == NULL) {
        return true;
    }
    
    // 初始化双指针
    int left = 0;                    // 左指针指向字符串开头
    int right = strlen(s) - 1;       // 右指针指向字符串末尾
    
    // 当左指针小于右指针时继续循环
    while (left < right) {
        // 跳过左侧非字母数字字符
        while (left < right && !isalnum(s[left])) {
            left++;
        }
        
        // 跳过右侧非字母数字字符
        while (left < right && !isalnum(s[right])) {
            right--;
        }
        
        // 比较左右字符（转换为小写后比较）
        if (tolower(s[left]) != tolower(s[right])) {
            return false;  // 字符不相等，不是回文串
        }
        
        // 移动指针向中间靠拢
        left++;
        right--;
    }
    
    // 所有对应字符都相等，是回文串
    return true;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 验证回文串

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：判断一个字符串在去除所有非字母数字字符并转换为小写后，是否为回文串

📥 **输入输出**：
- **输入**：char * s - 待判断的字符串
- **输出**：bool - true表示是回文串，false表示不是回文串

---

## 2️⃣ 实现原理

💡 **核心思路**：使用双指针法从字符串两端向中间移动，跳过非字母数字字符并忽略大小写进行比较

📋 **实现步骤**：
1. 初始化左右两个指针分别指向字符串的开始和结束位置
2. 移动左指针跳过所有非字母数字字符
3. 移动右指针跳过所有非字母数字字符
4. 比较左右指针指向字符的小写形式，如果不相等则返回false
5. 继续向中间移动指针，重复步骤2-4直到指针相遇

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用双指针法避免创建新字符串，节省空间
- 利用 `isalnum()` 函数判断字符是否为字母或数字
- 使用 `tolower()` 函数统一字符大小写进行比较
- 在循环中同时处理字符过滤和比较逻辑

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要验证文本是否为回文格式
- 文本预处理后判断对称性
- 验证标识符或代码中的回文模式

### ⚠️ 前提条件：
- 输入字符串为ASCII字符
- 需要忽略大小写和非字母数字字符

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n为字符串长度，每个字符最多被访问一次

- 💾 空间复杂度：O(1)，只使用了常数级别的额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空字符串或NULL指针
- 只包含非字母数字字符的字符串
- 单个字符的字符串

### 💥 易错点：
- 忘记跳过非字母数字字符
- 忽略大小写转换导致判断错误
- 指针边界条件处理不当导致数组越界

## 7️⃣ 补充说明

函数的工作原理：

1.输入检查：首先检查输入字符串是否为 `NULL`，如果是则返回 `true`

2.双指针初始化：使用两个指针，`left` 指向字符串开始，`right` 指向字符串结束

3.双指针向中间移动：跳过非字母数字字符，只比较有效字符

4.字符比较：将字符转换为小写后进行比较

5.返回结果：如果所有对应字符都匹配，则返回 `true`，否则返回 `false`

例：简单回文 "A man, a plan, a canal: Panama"

```
原始字符串: "A man, a plan, a canal: Panama"
有效字符:   A m a n a p l a n a c a n a l P a n a m a
转换为小写: a m a n a p l a n a c a n a l p a n a m a
```

执行过程：

1.`left=0` 指向 'A'，`right=32` 指向 'a'

2.比较 `tolower('A')`和 `tolower('a')`，都是`'a'`，相等

3.继续向中间移动指针，跳过逗号和空格等非字母数字字符

4.依次比较每一对字符：(m,m), (a,a), (n,n)...

5.所有对应字符都相等，返回 `true`


</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-19-ffmpeg.mdx===
---FRONTMATTER---
slug: ffmpeg
title: 关于ffmpeg 
authors: eurekaX
tags: [ffmpeg]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

本文介绍使用 ffmpeg 的基本使用方法。
<!-- truncate -->

# <B2>FFmpeg 使用指南 🎬</B2>

## <B2>📦 [FFmpeg 安装教程](https://blog.csdn.net/Natsuago/article/details/143231558 "FFmpeg 安装详细步骤")</B2>


---

## <B2>🔄 m3u8 格式视频转 mp4</B2>

### 🔑 密钥文件准备

在 `index` 目录下有一个视频密钥文件 `0.key`：

<p><CardImg src="/img/ffmpeg/index0key.jpg" alt="0.key" isCenter={true} isBoxed={true} /></p>

### ▶️ 转换命令

在 `m3u8` 文件所在目录下执行相应命令：
<Tabs>

<TabItem value="with-key" label="🔐 有密钥">

```bash
ffmpeg -allowed_extensions ALL -i "index.m3u8" -c copy -bsf:a aac_adtstoasc -hls_key_info_file "index/0.key" "output.mp4"
```

</TabItem>

<TabItem value="without-key" label="🔓 无密钥">

```bash
ffmpeg -i "index.m3u8" -c copy -bsf:a aac_adtstoasc "output.mp4"
```

</TabItem>   
  
</Tabs>

### ✅ 转换结果
<p><CardImg src="/img/ffmpeg/success1.jpg" alt="转换成功1" isCenter={true} isBoxed={true} /></p>
<p><CardImg src="/img/ffmpeg/success2.jpg" alt="转换成功2" isCenter={true} isBoxed={true} /></p>
🎉 转换成功！！！
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-19-LeetCode392.mdx===
---FRONTMATTER---
slug: LeetCode392
title: 判断子序列
authors: eurekaX
tags: [双指针,字符串]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——392题](https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 判断字符串 s 是否为字符串 t 的子序列
 * 
 * @param s 待检查的子序列字符串
 * @param t 主字符串
 * @return bool 如果 s 是 t 的子序列返回 true，否则返回 false
 */
bool isSubsequence(char * s, char * t) {
    // 使用双指针分别指向两个字符串的当前位置
    int i = 0; // 指向字符串 s 的指针
    int j = 0; // 指向字符串 t 的指针
    
    // 遍历两个字符串
    while (s[i] != '\0' && t[j] != '\0') {
        // 如果当前字符匹配，则移动 s 的指针
        if (s[i] == t[j]) {
            i++;
        }
        // 总是移动 t 的指针
        j++;
    }
    
    // 如果 s 的指针到达末尾，说明 s 是 t 的子序列
    return s[i] == '\0';
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 判断子序列

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：判断字符串 s 是否为字符串 t 的子序列，即能否通过删除 t 中的一些字符（也可以不删除）得到 s，且不改变字符的相对位置

📥 **输入输出**：
- **输入**：两个字符串 s（待检查的子序列）和 t（主字符串）
- **输出**：布尔值，如果 s 是 t 的子序列返回 true，否则返回 false

---

## 2️⃣ 实现原理

💡 **核心思路**：使用双指针技术逐个匹配字符，或者预处理主字符串建立索引表以优化大量查询场景

📋 **实现步骤**：
1. 基础解法：使用两个指针分别遍历 s 和 t 字符串
2. 当字符匹配时，同时移动两个指针；不匹配时只移动 t 的指针
3. 进阶解法：预处理 t 字符串，为每个位置建立字符索引表
4. 查询时直接利用索引表快速定位下一个匹配字符的位置

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 双指针技术：有效处理序列匹配问题
- 预处理优化：通过空间换时间，提高大量查询场景下的效率
- 边界处理：正确判断指针到达字符串末尾的情况

## 4️⃣ 使用场景

### ✅ 适用情况：
- 判断一个字符串是否为另一个字符串的子序列
- 文本处理中的模式匹配
- 大量重复查询同一主字符串的子序列判断

### ⚠️ 前提条件：
- 输入字符串只包含小写英文字母
- 主字符串相对固定，需要多次查询不同子序列

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：
  - 基础解法：O(|t|)，其中 |t| 是主字符串长度
  - 进阶解法：预处理 O(|t|)，单次查询 O(|s|)

- 💾 空间复杂度：
  - 基础解法：O(1)
  - 进阶解法：O(|t| × 26) = O(|t|)

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空字符串 s 总是任何字符串 t 的子序列
- 非空字符串 s 永远不是空字符串 t 的子序列
- s 长度大于 t 长度时，s 不可能是 t 的子序列

### 💥 易错点：
- 忘记处理字符串结束符 '\0'
- 在进阶解法中索引映射错误（字符到数组下标转换）
- 查询时位置更新逻辑错误，导致重复匹配同一位置字符

## 7️⃣ 进阶解法
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

/**
 * 预处理字符串 t，建立字符位置索引表
 * 
 * @param t 主字符串
 * @param tLen 主字符串长度
 * @param indexMap 字符索引表，indexMap[c][i] 表示字符 c 在位置 i 之后第一次出现的位置
 */
void preprocess(char* t, int tLen, int** indexMap) {
    // 为每个字符分配空间，存储下一个出现位置的信息
    for (int i = 0; i < 26; i++) {
        indexMap[i] = (int*)malloc((tLen + 1) * sizeof(int));
        // 初始化为 -1，表示未找到
        for (int j = 0; j <= tLen; j++) {
            indexMap[i][j] = -1;
        }
    }
    
    // 从后往前填充索引表
    for (int i = tLen - 1; i >= 0; i--) {
        int c = t[i] - 'a'; // 将字符转换为索引 0-25
        // 复制上一个位置的所有字符的索引信息
        for (int j = 0; j < 26; j++) {
            indexMap[j][i] = indexMap[j][i + 1];
        }
        // 更新当前字符在位置 i 的索引
        indexMap[c][i] = i;
    }
}

/**
 * 使用预处理的索引表快速判断 s 是否为 t 的子序列
 * 
 * @param s 待检查的子序列字符串
 * @param indexMap 预处理得到的字符索引表
 * @return bool 如果 s 是 t 的子序列返回 true，否则返回 false
 */
bool isSubsequenceAdvanced(char* s, int** indexMap) {
    int pos = 0; // 当前在 t 中的位置
    
    for (int i = 0; s[i] != '\0'; i++) {
        int c = s[i] - 'a'; // 将字符转换为索引 0-25
        // 查找字符 c 在当前位置之后第一次出现的位置
        pos = indexMap[c][pos];
        // 如果找不到，说明不是子序列
        if (pos == -1) {
            return false;
        }
        // 移动到找到位置的下一个位置
        pos++;
    }
    
    return true;
}

/**
 * 释放预处理索引表占用的内存
 * 
 * @param indexMap 字符索引表
 */
void freeIndexMap(int** indexMap) {
    for (int i = 0; i < 26; i++) {
        free(indexMap[i]);
    }
    free(indexMap);
}

// 示例用法
int main() {

    // 进阶解法测试
    printf("\n进阶解法测试:\n");
    char t[] = "ahbgdc";
    int tLen = strlen(t);
    
    // 预处理
    int** indexMap = (int**)malloc(26 * sizeof(int*));
    preprocess(t, tLen, indexMap);
    
    // 查询
    printf("isSubsequenceAdvanced(\"abc\", indexMap): %s\n", 
           isSubsequenceAdvanced("abc", indexMap) ? "true" : "false");
    printf("isSubsequenceAdvanced(\"axc\", indexMap): %s\n", 
           isSubsequenceAdvanced("axc", indexMap) ? "true" : "false");
    
    // 释放内存
    freeIndexMap(indexMap);
    
    return 0;
}
```
## 8⃣ 补充说明

### 1. 预处理阶段

—— `preprocess` 函数

这个函数的主要目的是为字符串 t 构建一个索引表，使得后续查询更高效。

#### 核心思想

构建一个二维数组 `indexMap[26][tLen+1]`，其中：

- 第一维代表26个小写字母（a-z）
- 第二维代表在字符串 t 中的位置（0 到 tLen）
- `indexMap[c][i]` 的值表示字符 c 在位置 i 之后（包括位置 i）第一次出现的位置

#### 举例说明

假设 `t = "abcba"`，长度为5：

1. **初始化**：创建一个 26×6 的二维数组，所有值初始化为 -1

2. **从后往前填充**：
   - 位置4（字符'a'）:
     - 先复制位置5的所有信息（都是-1）
     - 更新字符'a'在位置4的值为4
   - 位置3（字符'b'）:
     - 先复制位置4的所有信息
     - 更新字符'b'在位置3的值为3
   - 位置2（字符'c'）:
     - 先复制位置3的所有信息
     - 更新字符'c'在位置2的值为2
   - 位置1（字符'b'）:
     - 先复制位置2的所有信息
     - 更新字符'b'在位置1的值为1
   - 位置0（字符'a'）:
     - 先复制位置1的所有信息
     - 更新字符'a'在位置0的值为0

最终得到的部分索引表（只显示相关字符）：
```
indexMap['a'-'a'][0]=0, indexMap['a'-'a'][1]=4, indexMap['a'-'a'][2]=4, indexMap['a'-'a'][3]=4, indexMap['a'-'a'][4]=4, indexMap['a'-'a'][5]=-1
indexMap['b'-'a'][0]=1, indexMap['b'-'a'][1]=1, indexMap['b'-'a'][2]=3, indexMap['b'-'a'][3]=3, indexMap['b'-'a'][4]=-1, indexMap['b'-'a'][5]=-1
indexMap['c'-'a'][0]=2, indexMap['c'-'a'][1]=2, indexMap['c'-'a'][2]=2, indexMap['c'-'a'][3]=-1, indexMap['c'-'a'][4]=-1, indexMap['c'-'a'][5]=-1
```

### 2. 查询阶段

—— `isSubsequenceAdvanced` 函数

使用预处理好的索引表快速判断子序列：

#### 工作原理

维护一个当前位置 `pos`，对于要查找的字符串 `s` 中的每个字符：

1. 查找该字符在当前位置之后第一次出现的位置
2. 如果找不到（返回-1），则说明不是子序列
3. 如果找到，则将位置更新为找到位置的下一个位置

#### 举例说明

继续使用上面的例子，`t = "abcba"`，现在要检查 `s = "acb"` 是否为子序列：

1. 初始位置 `pos = 0`
2. 查找字符 'a'：
   - `indexMap['a'-'a'][0] = 0`
   - 找到位置0，更新 `pos = 0 + 1 = 1`
3. 查找字符 'c'：
   - `indexMap['c'-'a'][1] = 2`
   - 找到位置2，更新 `pos = 2 + 1 = 3`
4. 查找字符 'b'：
   - `indexMap['b'-'a'][3] = 3`
   - 找到位置3，更新 `pos = 3 + 1 = 4`
5. 字符串遍历完成，返回 `true`

如果检查 `s = "abc"`：

1. 初始位置 `pos = 0`
2. 查找字符 'a'：`indexMap['a'-'a'][0] = 0`，`pos = 1`
3. 查找字符 'b'：`indexMap['b'-'a'][1] = 1`，`pos = 2`
4. 查找字符 'c'：`indexMap['c'-'a'][2] = 2`，`pos = 3`
5. 返回 `true`

这种方法的优势在于，无论主字符串 `t` 有多长，每次查询的时间复杂度只与待查询字符串 `s` 的长度有关，而与 `t` 的长度无关。这对于需要大量查询的场景非常有用。

关于此进阶解法，我**尚不理解**！
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-20-LeetCode167.mdx===
---FRONTMATTER---
slug: LeetCode167
title: 两数之和Ⅱ-输入有序数组
authors: eurekaX
tags: [数组,双指针]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——167题](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 两数之和 II - 输入有序数组
 * 
 * 给定一个按非递减顺序排列的整数数组，找出两个数使得它们的和等于目标值
 * 返回这两个数的下标（下标从1开始）
 * 
 * 解题思路：
 * 使用双指针法，利用数组有序的特性
 * 设置左指针指向数组开始，右指针指向数组结束
 * 根据当前两数之和与目标值的比较，移动指针
 * 
 * 时间复杂度：O(n) - 最多遍历一次数组
 * 空间复杂度：O(1) - 只使用常量级额外空间
 * 
 * @param numbers 输入的有序整数数组
 * @param numbersSize 数组长度
 * @param target 目标和
 * @param returnSize 返回数组的长度
 * @return 包含两个下标的数组
 */
int* twoSum(int* numbers, int numbersSize, int target, int* returnSize) {
    // 分配返回数组内存
    int* result = (int*)malloc(2 * sizeof(int));
    *returnSize = 2;
    
    // 初始化双指针
    int left = 0;          // 左指针，指向数组开始
    int right = numbersSize - 1;  // 右指针，指向数组结束
    
    // 双指针向中间移动查找
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        
        if (sum == target) {
            // 找到目标和，注意题目要求下标从1开始
            result[0] = left + 1;
            result[1] = right + 1;
            return result;
        } else if (sum < target) {
            // 当前和小于目标值，左指针右移增大和值
            left++;
        } else {
            // 当前和大于目标值，右指针左移减小和值
            right--;
        }
    }
    
    // 根据题目保证有唯一解，此处不会执行到
    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 两数之和Ⅱ-输入有序数组

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：在一个非递减有序整数数组中找到两个数，使其和等于目标值，并返回这两个数的下标（从1开始）

📥 **输入输出**：
- **输入**：
  - `numbers`: 按非递减顺序排列的整数数组
  - `target`: 目标和值
- **输出**：包含两个下标的数组 [index1, index2]，其中 `1 <= index1 < index2 <= numbers.length`

---

## 2️⃣ 实现原理

💡 **核心思路**：利用数组有序的特性，使用双指针技术从两端向中间搜索，根据当前和与目标值的比较来移动指针

📋 **实现步骤**：
1. 初始化左指针指向数组开始，右指针指向数组结束
2. 计算左右指针所指向元素的和
3. 比较当前和与目标值：
   - 如果相等，则找到答案，返回下标（注意转换为从1开始）
   - 如果小于目标值，左指针右移以增大和值
   - 如果大于目标值，右指针左移以减小和值
4. 重复步骤2-3直到找到答案

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **双指针法**：利用有序数组的特性，避免了O(n²)的暴力搜索
- **有序数组的单调性**：根据和值与目标值的比较，可以确定移动哪个指针
- **下标转换**：题目要求下标从1开始，需要将数组索引+1

## 4️⃣ 使用场景

### ✅ 适用情况：
- 在有序数组中查找满足某种条件的两个元素
- 需要常量级空间复杂度的两数查找问题
- 已知数组有序且有唯一解的情况

### ⚠️ 前提条件：
- 数组必须是非递减有序排列
- 保证存在唯一解
- 不允许重复使用相同元素

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n是数组长度，最多需要遍历一次数组
- 💾 空间复杂度：O(1)，只使用了常量级额外空间（不计算返回数组）

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组只有两个元素且满足条件
- 目标值由数组首尾元素组成
- 负数参与计算的情况

### 💥 易错点：
- 忘记将数组索引转换为从1开始的下标
- 指针移动条件判断错误
- 没有正确处理循环终止条件
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-21-LeetCode11.mdx===
---FRONTMATTER---
slug: LeetCode11
title: 盛最多水的容器
authors: eurekaX
tags: [数组,双指针,贪心]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——11题](https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 盛最多水的容器 - 双指针解法
 * @param height 整数数组，表示每条垂线的高度
 * @param heightSize 数组长度
 * @return 容器可以储存的最大水量
 */
int maxArea(int* height, int heightSize) {
    // 初始化左右指针
    int left = 0;              // 左指针指向数组开始
    int right = heightSize - 1; // 右指针指向数组末尾
    int maxWater = 0;          // 记录最大储水量
    
    // 当左指针小于右指针时继续循环
    while (left < right) {
        // 计算当前容器的储水量
        // 面积 = 两线中较短的高度 × 两线之间的距离
        int currentWater = (right - left) * 
                          (height[left] < height[right] ? height[left] : height[right]);
        
        // 更新最大储水量
        if (currentWater > maxWater) {
            maxWater = currentWater;
        }
        
        // 移动较短的那根垂线的指针
        // 因为只有这样才能可能找到更大的面积
        if (height[left] < height[right]) {
            left++;  // 移动左指针
        } else {
            right--; // 移动右指针
        }
    }
    
    return maxWater; // 返回最大储水量
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 盛最多水的容器

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定n条垂线的高度数组，找出其中两条线使得它们与x轴构成的容器能容纳最多的水

📥 **输入输出**：
- **输入**：`height`整数数组表示每条垂线高度，`heightSize`表示数组长度
- **输出**：返回容器可以储存的最大水量（面积）

---

## 2️⃣ 实现原理

💡 **核心思路**：使用双指针法从数组两端向中间移动，每次移动较短边的指针以寻找可能的最大面积

📋 **实现步骤**：
1. 初始化左右指针分别指向数组首尾
2. 计算当前两指针构成的容器面积
3. 更新记录的最大面积值
4. 移动较短边的指针，重复步骤2-3直到指针相遇

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用三元运算符简化高度比较：`height[left] < height[right] ? height[left] : height[right]`
- 贪心策略：总是移动较短边以寻找更大面积的可能性
- 面积计算公式：宽度×较短高度 = `(right-left) * min(height[left], height[right])`

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要在一个数组中找到两个元素使某种乘积最大化
- 可以用双指针优化暴力解法的问题
- 求解具有对称性质的最优化问题

### ⚠️ 前提条件：
- 输入数组至少包含两个元素
- 数组元素为非负整数

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n是数组长度，每个元素最多访问一次

- 💾 空间复杂度：O(1)，只使用常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组只有两个元素的情况
- 所有元素高度相同的情况
- 数组为空或只有一个元素的情况（题目保证不会出现）

### 💥 易错点：
- 错误地移动较高边的指针，导致错过最优解
- 面积计算时忘记取两线中的较小值作为高度
- 循环条件判断错误，可能导致指针越界
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-22-AddBlogReview.mdx===
---FRONTMATTER---
slug: AddBlogReview
title: 添加博客评论
authors: eurekaX
tags: [博客]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CardImg from '@site/src/components/CardImg';

### <B2>在 Docusaurus 的博客中添加 giscus 评论🤔</B2>

<!-- truncate -->


## 安装依赖

<Tabs>

  <TabItem value="npm" label="npm">
```bash
npm install --save @giscus/react
```
  </TabItem>

  <TabItem value="yarn" label="yarn">
```bash
yarn add @giscus/react
```
  </TabItem>

  <TabItem value="pnpm" label="pnpm">
```bash
pnpm add @giscus/react
```
  </TabItem>  
 
</Tabs>




## 创建评论组件
```tsx title="src/components/Comment.tsx"
import React, { useEffect, useState } from 'react'
import BrowserOnly from '@docusaurus/BrowserOnly'

export default function Comment(): JSX.Element {
  return (
    <div style={{ marginTop: '2rem' }}>
      <BrowserOnly fallback={<div style={{ minHeight: '200px' }}>加载评论中...</div>}>
        {() => {
          const { useThemeConfig } = require('@docusaurus/theme-common')
          const { useLocation } = require('@docusaurus/router')
          const Giscus = require('@giscus/react').default
          
          const themeConfig = useThemeConfig()
          const location = useLocation()

          // 修改页面类型检查，适配你的博客路径格式
          // 检查是否为博客文章页面：/blog/文章标题
          const isBlogPostPage = /^\/blog\/[^/]+$/.test(location.pathname) || 
                                (/^\/blog\//.test(location.pathname) && !/^\/blog\/?$/.test(location.pathname) && location.pathname.split('/').length === 3);
          
          const isDocPage = location.pathname.startsWith('/docs/');
          
          // 调试信息，可以帮助你确认路径匹配
          console.log('Current path:', location.pathname);
          console.log('Is blog post page:', isBlogPostPage);
          console.log('Is doc page:', isDocPage);
          
          // 如果不是博客文章页面或文档页面，不显示评论
          if (!isBlogPostPage && !isDocPage) {
            return <div></div>; // 返回空内容，不显示评论
          }

          const giscus: any = { ...themeConfig.giscus }

          if (!giscus.repo || !giscus.repoId || !giscus.categoryId) {
            return (
              <div style={{ padding: '1rem', textAlign: 'center', color: 'red' }}>
                评论系统配置缺失
              </div>
            )
          }

          // 处理路径
          const path = location.pathname.replace(/^\/|\/$/g, '');
          const subPath = path || "index";
          giscus.term = subPath;

          // 主题监听组件
          const GiscusWithThemeListener = () => {
            const [theme, setTheme] = useState('light');

            useEffect(() => {
              const updateTheme = () => {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                setTheme(currentTheme === 'dark' ? 'transparent_dark' : 'light');
              };

              // 初始化
              updateTheme();

              // 监听主题变化
              const observer = new MutationObserver(() => {
                updateTheme();
              });

              observer.observe(document.documentElement, {
                attributes: true,
                attributeFilter: ['data-theme']
              });

              return () => observer.disconnect();
            }, []);

            return <Giscus {...giscus} theme={theme} />;
          };

          return <GiscusWithThemeListener />;
        }}
      </BrowserOnly>
    </div>
  )
}
```

:::info[特别说明]

上面 Comment.tsx中的正则表达式匹配的是：

- ✅ `/blog/FirstBlog`
- ✅ `/blog/任何单个路径段`
- ❌ `/blog/`(博客列表页)
- ❌ `/blog/category/subcategory`(多级路径)

:::

## 博客页面启用评论
博客页面由 `docusaurus` 的 `BlogPostItem` 组件渲染，下面是自定义方法。

1. swizzle `BlogPostItem `：
<Tabs>

  <TabItem value="npm" label="npm">
```bash
npm run swizzle @docusaurus/theme-classic BlogPostItem -- --wrap --typescript
```
  </TabItem>

  <TabItem value="yarn" label="yarn">
```bash
yarn swizzle @docusaurus/theme-classic BlogPostItem --wrap --typescript
```
  </TabItem>

  <TabItem value="pnpm" label="pnpm">
```bash
pnpm run swizzle @docusaurus/theme-classic BlogPostItem -- --wrap --typescript
```
  </TabItem>  
 
</Tabs>

出现警报说不安全什么的，直接

>YES: I know what I am doing!


2. 然后在 `BlogPostItem` 的 `index.tsx` 里面，将其**全部替换**为下列的代码：
```tsx title="src/theme/BlogPostItem/index.tsx"
import React from 'react';
import BlogPostItem from '@theme-original/BlogPostItem';
import type { WrapperProps } from '@docusaurus/types';
import Comment from '@site/src/components/Comment';

type Props = WrapperProps<typeof BlogPostItem>;

export default function BlogPostItemWrapper(props: Props): JSX.Element {
  const { children, ...otherProps } = props;
  
  return (
    <BlogPostItem {...otherProps}>
      {children}
      <div className="blog-post-comments" style={{ 
        marginTop: '2rem',
        paddingTop: '1.5rem',
        borderTop: '1px solid var(--ifm-color-emphasis-300)'
      }}>
        <Comment />
      </div>
    </BlogPostItem>
  );
}
```

## 配置giscus

[giscus官网](https://giscus.app/zh-CN)

<p><CardImg src="/img/Blog/giscuscongf1.jpg" alt="评论功能添加成功" isCenter={true} /></p>

所谓的 `Discussions` 功能是指这里：`Github->Settings->General`

<p><CardImg src="/img/Blog/giscuscongf5.jpg" alt="评论功能添加成功" isCenter={true} /></p>

三个条件都满足时，输入：`用户名/仓库名`，giscus提示仓库满足条件时，可以正式开始配置

1. 分类选 `General`；特性第一个默认选，最后两个可选可不选（即使不选后续也可以继续配置）

<p><CardImg src="/img/Blog/giscuscongf2.jpg" alt="评论功能添加成功" isCenter={true} /></p>

2. 这四个信息：

<p><CardImg src="/img/Blog/giscuscongf3.jpg" alt="评论功能添加成功" isCenter={true} /></p>

3. 依次填入到： `docusaurus.config.js` 的这个位置

<p><CardImg src="/img/Blog/giscuscongf4.jpg" alt="评论功能添加成功" isCenter={true} /></p>

```js title="docusaurus.config.js"
// 添加 giscus 评论功能
giscus: {
	repo: 'username/username.github.io',
	repoId: '********',
	category: 'General',
	categoryId: '********',
	lang: 'zh-CN', // 中文评论模块
	inputPosition: 'top',//表示输入框在评论区顶部
},
```

4. 最后，`yarn start`

大功告成！这时就会看到已经出现评论了：

<p><CardImg src="/img/Blog/BlogReview.jpg" alt="评论功能添加成功" isCenter={true} /></p>

想要给 `文档页面` 也添加这样的评论功能，可以参考这篇[文章](https://imroc.cc/note/docusaurus/giscus)。

## 📚 参考资料

[添加 giscus 评论功能](https://imroc.cc/note/docusaurus/giscus)
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-22-LeetCode15.mdx===
---FRONTMATTER---
slug: LeetCode15
title: 三数之和
authors: eurekaX
tags: [数组,双指针,排序]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——15题](https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
// 比较函数，用于qsort排序
int compare(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    // 初始化返回结果数量为0
    *returnSize = 0;
    
    // 如果数组长度小于3，无法构成三元组，直接返回
    if (numsSize < 3) {
        return NULL;
    }
    
    // 对数组进行排序，时间复杂度O(nlogn)
    qsort(nums, numsSize, sizeof(int), compare);
    
    // 分配结果数组空间，最坏情况下所有组合都满足条件
    int** result = (int**)malloc(sizeof(int*) * numsSize * numsSize);
    *returnColumnSizes = (int*)malloc(sizeof(int) * numsSize * numsSize);
    
    // 遍历数组，固定第一个数
    for (int i = 0; i < numsSize - 2; i++) {
        // 如果当前数字大于0，由于数组已排序，后面的数字都大于0，三数之和不可能为0
        if (nums[i] > 0) {
            break;
        }
        
        // 跳过重复元素，避免重复的三元组
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        
        // 使用双指针法查找另外两个数
        int left = i + 1;        // 左指针指向i之后的第一个元素
        int right = numsSize - 1; // 右指针指向数组末尾
        
        // 双指针向中间移动查找满足条件的组合
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            
            if (sum == 0) {
                // 找到满足条件的三元组
                result[*returnSize] = (int*)malloc(sizeof(int) * 3);
                result[*returnSize][0] = nums[i];
                result[*returnSize][1] = nums[left];
                result[*returnSize][2] = nums[right];
                (*returnColumnSizes)[*returnSize] = 3;
                (*returnSize)++;
                
                // 跳过重复元素
                while (left < right && nums[left] == nums[left + 1]) {
                    left++;
                }
                while (left < right && nums[right] == nums[right - 1]) {
                    right--;
                }
                
                // 移动指针继续查找
                left++;
                right--;
            } else if (sum < 0) {
                // 三数之和小于0，说明需要更大的数，左指针右移
                left++;
            } else {
                // 三数之和大于0，说明需要更小的数，右指针左移
                right--;
            }
        }
    }
    
    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 三数之和

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：在给定整数数组中找出所有不重复的三元组，使得三个数的和为0

📥 **输入输出**：
- **输入**：整数数组`nums`及其长度`numsSize`
- **输出**：所有和为0的不重复三元组组成的二维数组，通过`returnSize`返回结果数量，通过`returnColumnSizes`返回每行的列数

---

## 2️⃣ 实现原理

💡 **核心思路**：先对数组排序，然后固定一个数，用双指针在剩余数组中查找另外两个数，使得三数之和为0

📋 **实现步骤**：
1. 对输入数组进行排序
2. 遍历数组，固定第一个数`nums[i]`
3. 在`nums[i]`之后的子数组中使用双指针法查找另外两个数
4. 左指针指向`i+1`，右指针指向数组末尾，根据三数之和调整指针位置
5. 跳过重复元素避免重复三元组

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **排序预处理**：通过对数组排序，使双指针法成为可能，并便于去重
- **双指针法**：在有序数组中查找两数之和，时间复杂度从O(n²)降到O(n)
- **去重策略**：在遍历和查找过程中跳过重复元素，确保结果不重复

## 4️⃣ 使用场景

### ✅ 适用情况：
- 在数组中查找固定元素个数的组合问题
- 需要找出满足特定和值的数字组合
- 数据规模适中且对时间复杂度有要求的场景

### ⚠️ 前提条件：
- 输入数组至少包含3个元素
- 数组元素可以为负数、零或正数

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n²)，其中n为数组长度。排序需要O(n log n)，外层循环O(n)，内层双指针O(n)

- 💾 空间复杂度：O(1)，不考虑返回数组的空间，只使用常数级别的额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组长度小于3的情况
- 数组全为正数或全为负数的情况
- 数组中有大量重复元素的情况

### 💥 易错点：
- 忘记对结果去重，导致重复三元组
- 双指针移动条件判断错误
- 边界条件处理不当，可能导致数组越界
- 忽略排序的重要性，影响算法正确性

## 7⃣ 补充说明

以 `nums = [-1, 0, 1, 2, -1, -4]` 为例：

### 第一步：排序

```c
qsort(nums, numsSize, sizeof(int), compare);
```
排序后：`nums = [-4, -1, -1, 0, 1, 2]`

### 第二步：外层循环遍历

开始遍历数组，固定第一个数：

#### i = 0，`nums[0] = -4`
- `nums[0] = -4 <= 0`，继续处理
- `left = 1, right = 5`
- 双指针查找过程：
  - `nums[0] + nums[1] + nums[5] = -4 + (-1) + 2 = -3 < 0`，`left++`
  - `nums[0] + nums[2] + nums[5] = -4 + (-1) + 2 = -3 < 0`，`left++`
  - `nums[0] + nums[3] + nums[5] = -4 + 0 + 2 = -2 < 0`，`left++`
  - `nums[0] + nums[4] + nums[5] = -4 + 1 + 2 = -1 < 0`，`left++`
- `left = right`，结束本轮

#### i = 1，`nums[1] = -1`
- `nums[1] = -1 <= 0`，继续处理
- `left = 2, right = 5`
- 双指针查找过程：
  - `nums[1] + nums[2] + nums[5] = -1 + (-1) + 2 = 0 == 0`，找到三元组`[-1, -1, 2]`
    - 记录结果
    - 跳过重复：`nums[2] == nums[3]`，所以`left++`，`left = 3`
    - `right--`，`right = 4`
  - `nums[1] + nums[3] + nums[4] = -1 + 0 + 1 = 0 == 0`，找到三元组`[-1, 0, 1]`
    - 记录结果
    - `left++`，`left = 4`
    - `right--`，`right = 3`
- `left > right`，结束本轮

#### i = 2，`nums[2] = -1`
- `nums[2] = -1 <= 0`，但是`nums[2] == nums[1]`，跳过避免重复

#### i = 3，`nums[3] = 0`
- `nums[3] = 0 <= 0`，继续处理
- `left = 4, right = 5`
- 双指针查找过程：
  - `nums[3] + nums[4] + nums[5] = 0 + 1 + 2 = 3 > 0`，`right--`
- `left = right`，结束本轮

#### i = 4，`nums[4] = 1`
- `nums[4] = 1 > 0`，直接break，后续元素都大于0，不可能找到和为0的三元组

### 最终结果

得到两个不重复的三元组：

1. `[-1, -1, 2]`
2. `[-1, 0, 1]`

这个过程展示了算法如何通过排序和双指针技巧有效地找到所有满足条件的三元组，并通过跳过重复元素来避免重复结果。

</details>

**这道题我还不理解，明天我一定补上！**
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-23-LeetCode209.mdx===
---FRONTMATTER---
slug: LeetCode209
title: 长度最小的子数组
authors: eurekaX
tags: [数组,二分查找,前缀和]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——209题](https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 找到数组中和大于等于target的最短连续子数组长度
 * @param target 目标和
 * @param nums 输入数组
 * @param numsSize 数组长度
 * @return 最短子数组长度，不存在则返回0
 */
int minSubArrayLen(int target, int* nums, int numsSize) {
    // left: 滑动窗口左指针
    // right: 滑动窗口右指针
    int left = 0, right = 0;
    
    // sum: 当前窗口内元素的和
    int sum = 0;
    
    // minLen: 记录满足条件的最短子数组长度
    // 初始化为最大整数值，便于后续比较
    int minLen = INT_MAX;
    
    // 滑动窗口主循环：右指针遍历整个数组
    while (right < numsSize) {
        // 扩大窗口：将右指针指向的元素加入窗口
        sum += nums[right];
        
        // 收缩窗口：当窗口内元素和满足条件时，尝试缩小窗口
        while (sum >= target) {
            // 更新最小长度：取当前窗口长度与已记录最小长度的较小值
            int currentLen = right - left + 1;
            minLen = (currentLen < minLen) ? currentLen : minLen;
            
            // 缩小窗口：从窗口中移除左指针指向的元素，左指针右移
            sum -= nums[left];
            left++;
        }
        
        // 右指针右移，继续扩大窗口
        right++;
    }
    
    // 如果minLen仍为初始值，说明没有找到满足条件的子数组，返回0
    // 否则返回找到的最短子数组长度
    return (minLen == INT_MAX) ? 0 : minLen;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 长度最小的子数组

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定一个正整数数组和目标值，找到数组中元素和大于等于目标值的最短连续子数组长度

📥 **输入输出**：
- **输入**：
  - `target`: 目标和值（正整数）
  - `nums`: 包含n个正整数的数组
  - `numsSize`: 数组长度
- **输出**：满足条件的最短连续子数组长度，不存在则返回0

---

## 2️⃣ 实现原理

💡 **核心思路**：使用滑动窗口（双指针）技术，维护一个动态窗口来寻找满足条件的最短子数组

📋 **实现步骤**：
1. 初始化左右指针、窗口元素和、最小长度记录器
2. 右指针遍历数组，不断扩大窗口并将元素加入窗口和
3. 当窗口和满足条件（≥target）时，记录当前窗口长度并尝试缩小窗口
4. 左指针右移缩小窗口，更新窗口和，直到不满足条件为止
5. 继续扩大窗口直到遍历完整个数组，返回记录的最小长度

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **滑动窗口优化**：通过双指针技术避免重复计算，实现O(n)时间复杂度
- **动态更新**：实时维护窗口状态和最优解，避免存储所有可能的子数组
- **边界处理**：使用INT_MAX作为初始值，方便后续比较和不存在解的判断

## 4️⃣ 使用场景

### ✅ 适用情况：
- 寻找满足特定条件的连续子数组
- 需要优化时间复杂度的数组问题
- 可以通过扩大/缩小窗口来验证条件的问题

### ⚠️ 前提条件：
- 数组元素均为正整数（保证窗口缩小会使得和减小）
- 目标值为正整数

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n) - 每个元素最多被访问两次（right指针和left指针各一次）

- 💾 空间复杂度：O(1) - 只使用了常数级别的额外变量空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组为空或长度为0
- 不存在满足条件的子数组
- 整个数组的和刚好等于目标值

### 💥 易错点：
- 忘记处理不存在解的情况（应返回0）
- 滑动窗口的更新逻辑错误，可能导致无限循环
- 初始最小长度值设置不当，影响最终结果判断
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-23-VercelBlog.mdx===
---FRONTMATTER---
slug: VercelBlog
title: 将 Docusaurus 网站部署到 Vercel 
authors: eurekaX
tags: [Vercel]
---END FRONTMATTER---

---CONTENT---
import CardImg from '@site/src/components/CardImg';


<!-- truncate -->

## 碎碎念🥱

为了实现 [git pages](https://eurekashadow.github.io/ )网站的**流畅访问**，我曾尝试了各种方法：

1. 尝试用 `cloudflare`的 CDN 进行加速，一番折腾之后，加了一个寂寞，故放弃 [cloudflare](https://www.cloudflare-cn.com/ ) 方案；

> 后记：可能 `cloudflare` 加速是有一点作用的，但是之前或许由于这个[问题](/docs/Issues#build文件夹过大问题 )，导致效果不太明显。由于后来部署在 Vercel 后已经能够实现流畅[访问](https://www.eurekashadow.xin/ )了，所以就不弄 `cloudflare` 了。

2. 尝试用 [阿里云 OSS + CDN](https://www.aliyun.com/solution/tech-solution/oss-x-cdn?spm=5176.28507329.J_XmGx2FZCDAeIy2ZCWL7sW.32.384a2868h1X2kE&scm=20140722.S_product@@%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88@@2835888._.RL_CDN-LOC_2024NSHelpLink-OR_ser-PAR1_213e36dc17561936131571537ec7dc-V_4-P0_0-P1_0 )的方式进行加速，未遂。原因是 OSS 服务需要域名备案，而域名备案需要ESC(云服务器)，得花钱买，没钱且暂时没精力去折腾什么服务器；

3. 尝试用 `七牛云` 的**免费** `OSS + CDN` 进行加速，依旧未遂，还是域名备案问题；

4. 尝试将网站部署到 `Gitee` 的 `Gitee pages`上，以实现加速，但兴致冲冲将代码推送到 `Gitee` 之后发现，Gitee pages **似乎下线了**。😑 

以上问题对于有相关背景的程序员来说，也许根本不算什么，分分钟就解决了。但我只是个新手，完全小白，做这个网站完全是兴趣使然，就当图一乐吧。🤣

## 为什么选择 Vercel？

主要原因依旧是部署到 git pages 上的网站在国内访问**实在是太慢了**，想换成 Vercel 看看能不能快一点，结果网站的部署异常的顺利！虽然不见得有多快，但部署实在是省心省力，我开始有点喜欢Vercel了，想写个博客总结一下。在这篇文章中，我将记录将 Docusaurus 网站部署到 Vercel 的主要过程。

### 准备工作：
如果之前已经学会将 `Docusaurus` 网站部署到 `git pages` 上，那么 `Vercel部署` 自然就显得简单许多，可以说是易如反掌。反之，则起码需要满足下列三个要求：
1. 能够构建 [Docusaurus](https://www.docusaurus.cn/docs "官方参考文档") 项目；
2. 能够将与网站相关的代码[推送](https://blog.csdn.net/jiunian_2761/article/details/122907766 "参考")到 [github](https://github.com/) ；
3. 已购买域名；

:::danger[特别提醒]

如果没自己域名需要"梯子"才能访问部署成功的网站！自定义域名后方可解决该问题！

:::

完成以上准备工作后，网站的文件内容大致是这样的：

<p><CardImg src="/img/Blog/DocAndGit.jpg" alt="内容" isCenter={true} /></p>

如果使用的是 `SSH` 可以进行连接性测试：
```bash title="bash"
ssh -T git@github.com
```
预期结果大概是：

<p><CardImg src="/img/Blog/SSHTest.jpg" alt="测试结果" isCenter={true} /></p>

如果用的是 https 方式，就用不了上面的测试命令了，但只要 `git push` 能够成功便可。另外，对于**仓库的名称**，可以**不用**是 `username.github.io`，普通名称的公开仓库应该也可以（没试过，但我推断大概率可以）。

## 🚀 Vercel 部署步骤

### 第一步：注册并连接 GitHub

打开 [Vercel 官网](https://vercel.com/)，注册账号（最好 continue with github）。

已安装的 Vercel：

<p><CardImg src="/img/Blog/Vercelinstall.jpg" alt="已安装Vercel" isCenter={true} /></p>

权限设置：

<p><CardImg src="/img/Blog/VercelPer.jpg" alt="Permission" isCenter={true} /></p>

### 第二步：导入项目

引入包含 Docusaurus 项目的仓库：

<p><CardImg src="/img/Blog/GithubRepoImport.jpg" alt="import" isCenter={true} /></p>

Vercel 会自动检测项目类型并配置构建设置，直接点击部署：

<p><CardImg src="/img/Blog/VercelDeploy.jpg" alt="Deploy" isCenter={true} /></p>

### 第三步：访问部署结果

部署成功后大致是这样的：

<p><CardImg src="/img/Blog/VercelDomain.jpg" alt="Deploy" isCenter={true} /></p>

如果有梯子的话，点击 Vercel 给出的域名就可以访问已经成功部署的网站了。

## 🌐 域名配置

### 为什么需要自定义域名

没梯子无法访问默认域名，需要配置自定义域名后方可正常访问。

### 自定义域名的优势

- 🌍 **全球访问**：无需科学上网即可访问
- 🏢 **专业形象**：提升网站专业性和品牌形象
- 🔍 **SEO友好**：有利于搜索引擎优化
- 🔗 **品牌统一**：统一品牌标识和用户体验
- ⚡ **访问加速**：通过 CDN 提供更快的访问速度

## 🌐 为 Vercel 部署的网站添加自定义域名

为你的 Vercel 网站配置自定义域名，让用户可以通过你自己的域名访问网站，提升专业性和用户体验。

### 🔧 步骤一：在 Vercel 中添加域名

1. 进入 Vercel 控制台，选择你的项目
2. 导航到 `Settings` → `Domains`
3. 点击 `Add Domain` 按钮添加你的自定义域名

<p><CardImg src="/img/Blog/VercelAddDomain1.jpg" alt="在 Vercel 中添加域名" isCenter={true} /></p>

### 📋 步骤二：获取 Vercel 的 NameServers

添加域名后，Vercel 会提供一组 NameServers 地址，我们需要将这些地址配置到域名注册商处。

<p><CardImg src="/img/Blog/VercelAddDomain2.jpg" alt="获取 Vercel NameServers" isCenter={true} /></p>

### ⚙️ 步骤三：在阿里云修改 DNS 设置

1. 登录阿里云控制台
2. 进入 `域名列表` 页面

<p><CardImg src="/img/Blog/VercelAddDomain3.jpg" alt="阿里云域名列表" isCenter={true} /></p>

3. 找到你要配置的域名，点击 `修改DNS`

<p><CardImg src="/img/Blog/VercelAddDomain4.jpg" alt="域名解析设置入口" isCenter={true} /></p>

4. 修改 DNS 服务器地址，将 Vercel 提供的 NameServers 填入此处：

<p><CardImg src="/img/Blog/VercelDNSModify.jpg" alt="修改 DNS 服务器" isCenter={true} /></p>

5. 保存设置，等待 DNS 生效（通常需要几分钟到几小时）

<p><CardImg src="/img/Blog/VercelAddDomain5.jpg" alt="DNS 修改完成" isCenter={true} /></p>

### 📝 步骤四：查看 Vercel DNS 记录

Vercel 会提供两种类型的 DNS 记录用于验证和配置：

#### 记录 1：A 记录（用于根域名指向）

<p><CardImg src="/img/Blog/VercelAddDomain6.jpg" alt="A 记录配置" isCenter={true} /></p>

#### 记录 2：CNAME 记录（用于 www 子域名）

<p><CardImg src="/img/Blog/VercelAddDomain7.jpg" alt="CNAME 记录配置" isCenter={true} /></p>

### 🔄 步骤五：在阿里云添加 DNS 记录

进入阿里云的 `域名解析` 页面，添加上述两条记录：

<p><CardImg src="/img/Blog/VercelAddDomain9.jpg" alt="在阿里云添加 DNS 记录" isCenter={true} /></p>

### ✅ 步骤六：验证配置

返回 Vercel 控制台，刷新域名配置页面。当所有配置正确时，你应该看到类似以下的成功状态：

<p><CardImg src="/img/Blog/VercelAddDomain8.jpg" alt="域名配置成功" isCenter={true} /></p>

## 🎉 完成！

🎉 **恭喜！** 现在你的 Vercel 网站已经可以通过自定义域名访问了！

### ⏰ 注意事项
- DNS 变更可能需要几分钟到几小时才能完全生效
- 如果配置后仍无法访问，请检查防火墙设置
- 建议同时配置根域名和 www 子域名的记录
- 定期检查 DNS 配置确保正常运行

现在用户可以直接通过你的自定义域名访问网站，享受更快更稳定的访问体验！

## 后续部署

之后对博客内容进行更新后，想要再进行部署时，git push 成功之后，Vercel会识别到仓库代码的变换然后自动进行部署了！没错，只需：
```bash title="bash"
git add .
git commit -m "commit message"
git push
```
## 性能洞察与网站分析
此外，我还添加了 `Speed Insights` 和 `Web Analytics` 功能，按照 Vercel 提供的[教程](https://vercel.com/docs/speed-insights ) 进行操作即可，没啥难度。
唯一有点让人感到困惑的可能是第三步。以下是第三步的参考代码：
```js title="src/theme/Root.js"
import React from 'react';
// highlight-add-start
import { SpeedInsights } from '@vercel/speed-insights/react';
import { Analytics } from '@vercel/analytics/react';
// highlight-add-end

function Root({ children }) {
  return (
    <>
      {children}
	  // highlight-add-start
      <SpeedInsights />
	  <Analytics />
	  // highlight-add-end
    </>
  );
}

export default Root;
```
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-24-PicCovert.mdx===
---FRONTMATTER---
slug: AboutPic
title: 图片转换
authors: eurekaX
tags: [ffmpeg,图片]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## <B2> [process-images.js](https://github.com/EurekaShadow/EurekaShadow.github.io/blob/master/scripts/process-images.js ) 脚本</B2>

本文将介绍 `process-images.js` 脚本以及在使用过程中需要注意的问题。

<!-- truncate -->

## 🎯 功能
- 格式转换：将PNG、GIF、BMP、WebP等格式转换为JPG
- 智能压缩：自动优化JPG图片大小，保持质量平衡
- 批量重命名：按指定前缀自动编号重命名图片
- 处理统计：显示压缩率、处理时间等详细信息
- 日志记录：可选生成详细处理日志

## 📝 用途
适用于网站图片优化，特别适合Docusaurus等静态网站项目，帮助：

- 减小图片文件大小，提升网页加载速度
- 统一图片格式，便于管理
- 规范图片命名，避免重复文件名

## ▶️ 用法

<Tabs>

  <TabItem value="node" label="node">
```bash title="bash"
# 运行脚本
node scripts/process-images.js
# 按提示操作：
# 1. 选择要处理的图片目录
# 2. 输入文件名前缀（直接回车跳过重命名）
# 3. 选择是否生成日志文件
# 4. 确认开始处理
```
  </TabItem>

  <TabItem value="yarn" label="yarn">
```bash title="bash"
yarn process-img
```
  </TabItem>

</Tabs>

## ⚠️ 注意事项
- 需要系统已安装ffmpeg
- 默认处理 static/img 目录下的图片
- 原文件会被删除，建议先备份重要图片
- 日志文件默认保存在项目根目录的 logs/ 文件夹
- 处理大图片或大量图片时需要较长时间
- 脚本会自动跳过已按命名规则处理的文件

## 📁 目录结构
```
项目根目录/
├── static/img/          # 图片处理目录
│   ├── Blog/           # 子目录图片
│   └── *.png/jpg等     # 待处理图片
├── logs/               # 日志文件目录（自动生成）
└── process-images.js   # 脚本文件
```
---

## 错误将图片进行转换压缩重命名后，想要复原

### 1. 恢复已跟踪的文件到之前状态
```bash
git checkout HEAD~1 -- "D:/Docusaurus/test-site/static/img/Blog/"
```
### 2. 查看未跟踪的文件
```bash
git ls-files --others "D:/Docusaurus/test-site/static/img/Blog/"
```

### 3. 清理未跟踪的文件（预览）
```bash
git clean -n "D:/Docusaurus/test-site/static/img/Blog/"
```

### 4. 确认无误后执行清理
```bash
git clean -f "D:/Docusaurus/test-site/static/img/Blog/"
```

### 5. 查看最终状态
```bash
git status
```

## 预防措施
在运行图片处理脚本前：
```
# 1. 提交当前状态
git add .
git commit -m "Before running image processing script"

# 2. 创建备份分支
git checkout -b backup-before-processing

# 3. 回到主分支进行处理
git checkout main

# 运行脚本...
# node process-images.js

# 如果不满意结果，可以轻松回到备份状态：
# git reset --hard backup-before-processing
```

## 压缩 gif 图片思路
> 后续应把 gif 转 jpg 的代码删去
### 交互流程设计
```
=== 图片处理脚本 ===
请选择处理类型：
1. 普通图片处理（PNG/JPG等格式转换和压缩）
2. GIF图片优化

请输入选项编号:

# 如果选择1：进入原有流程
# 如果选择2：进入GIF专用流程
```

### GIF处理流程
```
请选择要处理的GIF目录:
1. ~/static/img/xxx目录 (包含N个GIF文件)
...

请选择GIF处理选项：
1. 仅转换格式（PNG/JPG）
2. 轻微压缩（减小20-30%，保持质量）
3. 中度压缩（减小50-70%，适度降低质量）
4. 重度压缩（减小80%+，显著降低质量）
5. 自定义压缩

是否需要重命名处理后的文件？(Y/N):
```

### ffmpeg命令示例
```bash title="bash"
# 轻微压缩
ffmpeg -i input.gif -filter_complex "[0:v] split [a][b];[a] palettegen=reserve_transparent=on:transparency_color=ffffff [p];[b][p] paletteuse" output.gif

# 中度压缩
ffmpeg -i input.gif -filter_complex "[0:v] fps=15,scale=iw/2:-1 [a];[a] split [b][c];[b] palettegen=reserve_transparent=on:transparency_color=ffffff [p];[c][p] paletteuse" output.gif

# 重度压缩
ffmpeg -i input.gif -filter_complex "[0:v] fps=10,scale=iw/3:-1 [a];[a] split [b][c];[b] palettegen=reserve_transparent=on:transparency_color=ffffff [p];[c][p] paletteuse" -colors 32 output.gif
```
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-25-LeetCode3.mdx===
---FRONTMATTER---
slug: LeetCode3
title: 无重复字符的最长子串
authors: eurekaX
tags: [哈希表,字符串,滑动窗口]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——3题](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 找出字符串中不含有重复字符的最长子串的长度
 * 使用滑动窗口 + 哈希表的方法
 * 
 * @param s 输入字符串
 * @return 不含有重复字符的最长子串的长度
 */
int lengthOfLongestSubstring(char* s) {
    // 处理边界情况：空字符串
    if (s == NULL || strlen(s) == 0) {
        return 0;
    }
    
    int len = strlen(s);                    // 字符串长度
    int maxLen = 0;                         // 最长子串长度
    int left = 0;                           // 滑动窗口左边界
    int charIndex[128];                     // 字符最后出现位置的索引数组（ASCII码范围）
    
    // 初始化字符索引数组为-1，表示字符尚未出现
    for (int i = 0; i < 128; i++) {
        charIndex[i] = -1;
    }
    
    // 滑动窗口右边界向右移动
    for (int right = 0; right < len; right++) {
        char currentChar = s[right];        // 当前处理的字符
        
        // 如果当前字符在当前窗口中已经出现过
        // 即：字符最后出现的位置 >= 窗口左边界
        if (charIndex[currentChar] >= left) {
            // 移动左边界到重复字符上次出现位置的下一位
            // 这样可以保证窗口内没有重复字符
            left = charIndex[currentChar] + 1;
        }
        
        // 更新当前字符的最新位置
        charIndex[currentChar] = right;
        
        // 计算当前窗口长度并更新最大长度
        int currentLen = right - left + 1;
        if (currentLen > maxLen) {
            maxLen = currentLen;
        }
    }
    
    return maxLen;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>

## 🤔 无重复字符的最长子串

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定一个字符串，找出其中不含有重复字符的最长子串的长度

📥 **输入输出**：
- **输入**：`char* s` - 输入字符串
- **输出**：返回不含有重复字符的最长子串的长度（整数）

---

## 2️⃣ 实现原理

💡 **核心思路**：使用滑动窗口算法配合哈希表记录字符最后出现位置，动态维护一个无重复字符的窗口

📋 **实现步骤**：
1. 初始化滑动窗口左右边界和字符索引数组
2. 遍历字符串，将右边界逐步右移
3. 对于每个字符，检查是否在当前窗口内已经出现过
4. 如果出现重复，则移动左边界至重复字符上次出现位置的下一位
5. 持续更新最大长度

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **滑动窗口优化**：通过记录字符最后出现位置，直接跳转左边界，避免逐步移动
- **ASCII索引数组**：使用固定大小数组代替哈希表，提高访问效率
- **边界处理**：通过比较字符位置与窗口左边界判断是否在当前窗口内重复

## 4️⃣ 使用场景

### ✅ 适用情况：
- 查找满足特定条件的连续子序列
- 需要维护窗口内元素唯一性的场景
- 字符串模式匹配问题

### ⚠️ 前提条件：
- 输入为ASCII字符字符串
- 需要连续子串而非子序列

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n是字符串长度，每个字符最多被访问两次
- 💾 空间复杂度：O(1)，使用固定大小的字符索引数组(128个ASCII字符)

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空字符串或NULL指针
- 单字符字符串
- 全部字符相同或全部不同

### 💥 易错点：
- 判断字符是否在当前窗口内重复的条件错误
- 左边界移动位置计算错误
- 忘记初始化字符索引数组

```
# 🔍 代码执行过程详解

我们以示例1为例：`s = "abcabcbb"`

---

## 📋 示例输入参数

- `s = "abcabcbb"` (长度为8)
- 目标：找出不含有重复字符的最长子串的长度

---

## 🔧 初始化阶段

```c
len = 8
maxLen = 0
left = 0
charIndex[128] = {-1, -1, ..., -1}  // 全部初始化为-1
🔄 遍历过程详解
第1步：right = 0, currentChar = 'a'
字符 'a' 的ASCII值为97
charIndex[97] = -1 < left(0)  // 字符'a'未在当前窗口出现过
更新 charIndex[97] = 0
当前窗口: "a", 长度 = 0 - 0 + 1 = 1
maxLen = max(0, 1) = 1
第2步：right = 1, currentChar = 'b'
字符 'b' 的ASCII值为98
charIndex[98] = -1 < left(0)  // 字符'b'未在当前窗口出现过
更新 charIndex[98] = 1
当前窗口: "ab", 长度 = 1 - 0 + 1 = 2
maxLen = max(1, 2) = 2
第3步：right = 2, currentChar = 'c'
字符 'c' 的ASCII值为99
charIndex[99] = -1 < left(0)  // 字符'c'未在当前窗口出现过
更新 charIndex[99] = 2
当前窗口: "abc", 长度 = 2 - 0 + 1 = 3
maxLen = max(2, 3) = 3
第4步：right = 3, currentChar = 'a'
字符 'a' 的ASCII值为97
charIndex[97] = 0 >= left(0)  // 字符'a'在当前窗口出现过！
移动左边界: left = charIndex[97] + 1 = 0 + 1 = 1
更新 charIndex[97] = 3
当前窗口: "bca", 长度 = 3 - 1 + 1 = 3
maxLen = max(3, 3) = 3 (保持不变)
第5步：right = 4, currentChar = 'b'
字符 'b' 的ASCII值为98
charIndex[98] = 1 >= left(1)  // 字符'b'在当前窗口出现过！
移动左边界: left = charIndex[98] + 1 = 1 + 1 = 2
更新 charIndex[98] = 4
当前窗口: "cab", 长度 = 4 - 2 + 1 = 3
maxLen = max(3, 3) = 3 (保持不变)
第6步：right = 5, currentChar = 'c'
字符 'c' 的ASCII值为99
charIndex[99] = 2 >= left(2)  // 字符'c'在当前窗口出现过！
移动左边界: left = charIndex[99] + 1 = 2 + 1 = 3
更新 charIndex[99] = 5
当前窗口: "abc", 长度 = 5 - 3 + 1 = 3
maxLen = max(3, 3) = 3 (保持不变)
第7步：right = 6, currentChar = 'b'
字符 'b' 的ASCII值为98
charIndex[98] = 4 >= left(3)  // 字符'b'在当前窗口出现过！
移动左边界: left = charIndex[98] + 1 = 4 + 1 = 5
更新 charIndex[98] = 6
当前窗口: "cb", 长度 = 6 - 5 + 1 = 2
maxLen = max(3, 2) = 3 (保持不变)
第8步：right = 7, currentChar = 'b'
字符 'b' 的ASCII值为98
charIndex[98] = 6 >= left(5)  // 字符'b'在当前窗口出现过！
移动左边界: left = charIndex[98] + 1 = 6 + 1 = 7
更新 charIndex[98] = 7
当前窗口: "b", 长度 = 7 - 7 + 1 = 1
maxLen = max(3, 1) = 3 (保持不变)
✅ 最终结果
函数返回 maxLen = 3

这与题目期望一致：最长无重复字符子串是"abc"，长度为3。
```
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-25-LeetCode30.mdx===
---FRONTMATTER---
slug: LeetCode30
title: 串联所有单词的子串
authors: eurekaX
tags: [哈希表,字符串,滑动窗口]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——30题](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 找出字符串中所有由words数组中所有单词串联组成的子串的起始索引
 * 
 * @param s 输入字符串
 * @param words 单词数组
 * @param wordsSize 单词数组长度
 * @param returnSize 返回结果数组的长度
 * @return 包含所有起始索引的数组
 */
int* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {
    // 如果输入为空或无效，返回空数组
    if (s == NULL || words == NULL || wordsSize == 0) {
        *returnSize = 0;
        return NULL;
    }

    int sLen = strlen(s);                           // 输入字符串长度
    int wordLen = strlen(words[0]);                 // 每个单词的长度（题目保证所有单词等长）
    int totalLen = wordLen * wordsSize;             // 所有单词连接后的总长度
    
    // 如果字符串长度小于所需总长度，不可能存在解
    if (sLen < totalLen) {
        *returnSize = 0;
        return NULL;
    }

    // 分配结果数组空间
    int* result = (int*)malloc(sizeof(int) * sLen);
    *returnSize = 0;

    // 创建单词频率映射表
    // 使用两个哈希表：allWords记录words中每个单词的出现次数，currentWords记录当前窗口中每个单词的出现次数
    char** allWords = (char**)malloc(sizeof(char*) * wordsSize);
    int* allWordsCount = (int*)calloc(wordsSize, sizeof(int));
    int uniqueWords = 0;

    // 构建allWords和allWordsCount，统计words中不重复单词及其出现次数
    for (int i = 0; i < wordsSize; i++) {
        int found = 0;
        // 检查当前单词是否已经在allWords中存在
        for (int j = 0; j < uniqueWords; j++) {
            if (strcmp(words[i], allWords[j]) == 0) {
                allWordsCount[j]++;
                found = 1;
                break;
            }
        }
        // 如果是新单词，则添加到allWords中
        if (!found) {
            allWords[uniqueWords] = (char*)malloc(sizeof(char) * (wordLen + 1));
            strcpy(allWords[uniqueWords], words[i]);
            allWordsCount[uniqueWords] = 1;
            uniqueWords++;
        }
    }

    // 为currentWords分配空间
    int* currentWordsCount = (int*)calloc(uniqueWords, sizeof(int));

    // 滑动窗口算法：按不同的起始位置进行遍历
    // 由于每个单词长度固定为wordLen，所以只需要考虑wordLen种起始位置
    for (int start = 0; start < wordLen; start++) {
        // 重置当前窗口的单词计数
        memset(currentWordsCount, 0, sizeof(int) * uniqueWords);
        int left = start;           // 窗口左边界
        int right = start;          // 窗口右边界
        int count = 0;              // 当前窗口中匹配的单词数量

        // 移动窗口右边界
        while (right + wordLen <= sLen) {
            // 提取当前要处理的单词
            char* word = (char*)malloc(sizeof(char) * (wordLen + 1));
            strncpy(word, s + right, wordLen);
            word[wordLen] = '\0';
            right += wordLen;

            // 检查提取的单词是否在words中存在
            int wordIndex = -1;
            for (int i = 0; i < uniqueWords; i++) {
                if (strcmp(word, allWords[i]) == 0) {
                    wordIndex = i;
                    break;
                }
            }

            // 如果单词存在于words中
            if (wordIndex != -1) {
                currentWordsCount[wordIndex]++;
                count++;

                // 如果当前单词出现次数超过了应有的次数，则需要移动左边界缩小窗口
                while (currentWordsCount[wordIndex] > allWordsCount[wordIndex]) {
                    char* leftWord = (char*)malloc(sizeof(char) * (wordLen + 1));
                    strncpy(leftWord, s + left, wordLen);
                    leftWord[wordLen] = '\0';
                    
                    int leftWordIndex = -1;
                    for (int i = 0; i < uniqueWords; i++) {
                        if (strcmp(leftWord, allWords[i]) == 0) {
                            leftWordIndex = i;
                            break;
                        }
                    }
                    
                    currentWordsCount[leftWordIndex]--;
                    count--;
                    left += wordLen;
                    free(leftWord);
                }

                // 如果当前窗口包含了所有单词，则记录起始位置
                if (count == wordsSize) {
                    result[(*returnSize)++] = left;
                }
            } else {
                // 如果单词不存在于words中，则重置窗口
                memset(currentWordsCount, 0, sizeof(int) * uniqueWords);
                count = 0;
                left = right;
            }
            
            free(word);
        }
    }

    // 释放分配的内存
    for (int i = 0; i < uniqueWords; i++) {
        free(allWords[i]);
    }
    free(allWords);
    free(allWordsCount);
    free(currentWordsCount);

    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 串联所有单词的子串

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：在字符串`s`中找出所有由`words`数组中所有单词按任意顺序连接而成的子串的起始位置

📥 **输入输出**：
- **输入**：
  - `s`：目标字符串
  - `words`：单词数组，所有单词长度相同
  - `wordsSize`：单词数组长度
- **输出**：
  - 返回包含所有起始索引的整数数组
  - `returnSize`：返回数组的实际长度

---

## 2️⃣ 实现原理

💡 **核心思路**：使用滑动窗口算法，通过维护单词频率映射来检查每个可能的子串

📋 **实现步骤**：
1. 统计`words`数组中每个不重复单词的出现频次，构建频率映射表
2. 按照单词长度进行分组遍历（0到wordLen-1），避免重复计算
3. 对每组使用滑动窗口技术，维护当前窗口内的单词频率
4. 当窗口内单词频率与目标频率匹配时，记录起始位置

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **滑动窗口优化**：按照单词长度分组遍历，避免不必要的重复检查
- **频率映射表**：使用两个数组模拟哈希表，记录单词出现频次
- **窗口边界调整**：当单词频次超过限制时，动态移动左边界

## 4️⃣ 使用场景

### ✅ 适用情况：
- 在长文本中查找由固定词汇组合成的模式串
- 需要匹配多个等长子串的连接情况
- 模式匹配问题，其中模式由多个可重复元素组成

### ⚠️ 前提条件：
- 所有单词必须等长
- 必须使用words中所有单词恰好一次
- 单词可以按任意顺序排列

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n × m)，其中n是字符串`s`的长度，m是单词长度
- 💾 空间复杂度：O(k)，其中k是不重复单词的数量

## 6️⃣ 注意事项

### 🚩 边界情况：
- 输入字符串为空或words数组为空
- 字符串长度小于所有单词连接后的总长度
- words数组中存在重复单词

### 💥 易错点：
- 忘记处理words中重复单词的情况
- 滑动窗口边界条件判断错误
- 内存释放不完全导致内存泄漏

## 7️⃣ 补充说明

# 🔍 代码执行过程详解

我们以示例1为例：`s = "barfoothefoobarman"`, `words = ["foo","bar"]`

---

## 📋 示例输入参数

- `s = "barfoothefoobarman"` (长度为18)
- `words = ["foo","bar"]` (wordsSize = 2)
- 每个单词长度 `wordLen = 3`
- 总长度 `totalLen = 3 * 2 = 6`

---

## 🔧 第一步：构建单词频率映射表

```c
// words = ["foo","bar"]
// 处理后得到：
uniqueWords = 2
allWords = ["foo", "bar"]
allWordsCount = [1, 1]  // 每个单词出现1次
🔄 第二步：滑动窗口遍历
📌 start = 0 的情况（起始位置为0，步长为3）
初始状态：

left = 0, right = 0
currentWordsCount = [0, 0]
count = 0
第1次循环 (right = 0):
c
// 提取单词: s[0..2] = "bar"
word = "bar"
wordIndex = 1  // "bar"在allWords中索引为1

currentWordsCount[1]++  // [0, 1]
count = 1

// count < wordsSize(2)，不满足条件
第2次循环 (right = 3):
c
// 提取单词: s[3..5] = "foo"
word = "foo"
wordIndex = 0  // "foo"在allWords中索引为0

currentWordsCount[0]++  // [1, 1]
count = 2

// count == wordsSize，满足条件
// 记录结果: result[0] = left = 0
*returnSize = 1
第3次循环 (right = 6):
c
// 提取单词: s[6..8] = "the"
word = "the"
wordIndex = -1  // "the"不在words中

// 重置窗口
memset(currentWordsCount, 0, sizeof(int) * uniqueWords)
count = 0
left = right = 9
📌 start = 1 的情况（起始位置为1，步长为3）
略过中间无匹配的部分...

📌 start = 2 的情况（起始位置为2，步长为3）
略过中间无匹配的部分...

📌 start = 0 的情况继续（找到第二个匹配）
当窗口移动到合适位置时：

某次循环状态：
left = 9
right = 15
已处理单词："foo"(s[9..11])和"bar"(s[12..14])
c
currentWordsCount = [1, 1]  // "foo"和"bar"各出现1次
count = 2  // 匹配了2个单词

// count == wordsSize，满足条件
// 记录结果: result[1] = left = 9
*returnSize = 2
✅ 最终结果
```c
result = [0, 9]
*returnSize = 2
```
这与题目期望的输出一致：子串"barfoo"(起始位置0)和"foobar"(起始位置9)都是由["foo","bar"]中所有单词连接而成。


</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-26-LeetCode76.mdx===
---FRONTMATTER---
slug: LeetCode76
title: 最小覆盖子串
authors: eurekaX
tags: [字符串,滑动窗口,哈希表]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——76题](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 找到字符串 s 中包含字符串 t 所有字符的最小子串
 * 使用滑动窗口算法，时间复杂度 O(m+n)，空间复杂度 O(1)
 * 
 * @param s 输入字符串
 * @param t 目标字符串
 * @return 返回最小覆盖子串，如果不存在则返回空字符串
 */
char* minWindow(char* s, char* t) {
    // 边界条件检查
    if (!s || !t || strlen(s) == 0 || strlen(t) == 0) {
        return "";
    }
    
    int sLen = strlen(s);
    int tLen = strlen(t);
    
    // 如果 s 的长度小于 t，不可能包含 t 的所有字符
    if (sLen < tLen) {
        return "";
    }
    
    // 使用数组代替哈希表记录字符频次（ASCII码范围）
    // need[i] 记录 t 中字符 i 的出现次数
    // window[i] 记录当前窗口中字符 i 的出现次数
    int need[128] = {0};
    int window[128] = {0};
    
    // 统计字符串 t 中每个字符的频次
    for (int i = 0; i < tLen; i++) {
        need[t[i]]++;
    }
    
    // 统计 t 中不同字符的个数
    int needCnt = 0;
    for (int i = 0; i < 128; i++) {
        if (need[i] > 0) {
            needCnt++;
        }
    }
    
    // 滑动窗口的左右指针
    int left = 0, right = 0;
    // 窗口中满足 need 条件的字符种类数
    int valid = 0;
    // 记录最小覆盖子串的起始索引及长度
    int start = 0, len = INT_MAX;
    
    // 开始滑动窗口
    while (right < sLen) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 扩大窗口
        right++;
        
        // 进行窗口内数据的一系列更新
        if (need[c] > 0) {
            window[c]++;
            // 当前字符在窗口中的数量达到需求
            if (window[c] == need[c]) {
                valid++;
            }
        }
        
        // 判断左侧窗口是否要收缩
        while (valid == needCnt) {
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            
            // 进行窗口内数据的一系列更新
            if (need[d] > 0) {
                // 如果移除字符 d 后不满足条件，valid 减一
                if (window[d] == need[d]) {
                    valid--;
                }
                window[d]--;
            }
        }
    }
    
    // 返回最小覆盖子串
    if (len == INT_MAX) {
        return "";
    }
    
    // 分配内存并复制结果
    char* result = (char*)malloc((len + 1) * sizeof(char));
    strncpy(result, s + start, len);
    result[len] = '\0';
    
    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 最小覆盖子串

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：找到字符串 s 中包含字符串 t 所有字符的最小子串，要求子串中每个字符的数量不少于 t 中该字符的数量。

📥 **输入输出**：
- **输入**：字符串 s（源字符串）、字符串 t（目标字符串）
- **输出**：返回 s 中涵盖 t 所有字符的最小子串，如果不存在则返回空字符串

---

## 2️⃣ 实现原理

💡 **核心思路**：使用滑动窗口（双指针）算法，通过扩展和收缩窗口来找到满足条件的最小子串。

📋 **实现步骤**：
1. 统计目标字符串 t 中每个字符的出现次数，存储在 need 数组中
2. 使用双指针维护一个滑动窗口，右指针不断扩展窗口
3. 当窗口满足条件时（包含 t 的所有字符且数量足够），记录当前窗口并尝试收缩左指针
4. 在所有满足条件的窗口中找到长度最小的那个

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用数组代替哈希表提高访问效率（ASCII 字符集）
- 通过 valid 变量高效判断窗口是否满足条件，避免每次遍历比较
- 滑动窗口的扩展与收缩时机控制
- 边界条件的精确处理

## 4️⃣ 使用场景

### ✅ 适用情况：
- 在长字符串中查找包含特定字符集合的最短子串
- 字符串匹配问题，需要考虑字符频次而非仅仅存在性
- 需要在线性时间内解决的子串查找问题

### ⚠️ 前提条件：
- 输入字符串不为空
- 需要查找的子串字符可以重复
- 字符集范围确定（如 ASCII）

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(m + n)，其中 m 是字符串 s 的长度，n 是字符串 t 的长度，每个字符最多被访问两次

- 💾 空间复杂度：O(1)，使用固定大小的数组（128个ASCII字符）

## 6️⃣ 注意事项

### 🚩 边界情况：
- 输入字符串为空或长度为0
- s 的长度小于 t 的长度
- t 中包含 s 中不存在的字符
- s 本身就是满足条件的最小子串

### 💥 易错点：
- 混淆字符存在性和字符数量要求
- 窗口收缩条件判断错误，导致错过最优解
- valid 变量更新时机不正确
- 内存分配和字符串复制时忘记添加结束符 '\0'
</details>
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-27-Algolia.mdx===
---FRONTMATTER---
slug: Algolia
title: 为 Docusaurus 添加 Algolia 搜索功能
authors: eurekaX
tags: [Algolia,Search,搜索]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

本文介绍使用 Algolia 的配置方法，为网站添加搜索功能。
<!-- truncate -->

# <B2> 配置 Algolia 教程 🔎</B2>

下面内容待施工。。。🥱
---END CONTENT---

===FILE_SEPARATOR===
===FILE_INFO:blog\2025-08-27-i18n.mdx===
---FRONTMATTER---
slug: i18n
title: 国际化
authors: eurekaX
tags: [i18n]
---END FRONTMATTER---

---CONTENT---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

本文介绍使用 i18n 的配置方法，是对于 Docusaurus 官方教程的补充。
<!-- truncate -->

# <B2> 配置 i18n 教程 🎬</B2>

```
yarn write-translations --locale en
```

```
# 确保英文文档目录存在且有内容
mkdir -p i18n/en/docusaurus-plugin-content-docs/current
cp -r docs/* i18n/en/docusaurus-plugin-content-docs/current/

# 确保有英文博客内容（如果有的话）
mkdir -p i18n/en/docusaurus-plugin-content-blog
cp -r blog/* i18n/en/docusaurus-plugin-content-blog/ 2>/dev/null || true
```

```
yarn build --locale en && yarn serve
```

```
yarn start --locale en
```

:::tip[默认情况]
`yarn start`默认运行中文的
:::
---END CONTENT---

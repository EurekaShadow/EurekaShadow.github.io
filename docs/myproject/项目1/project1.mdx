---
sidebar_label: '基于物联网的工地扬尘与噪音实时监测系统'
sidebar_position: 1.0
description: 这是我的毕业设计，也是我实现的第一个完整的嵌入式项目，颇具纪念意义！
---

import CardImg from '@site/src/components/CardImg';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## 项目背景

### 项目来源
本项目为本科毕业设计课题，由指导老师提供选题。随着城市化进程加快，建筑工地产生的扬尘和噪音污染已成为影响城市环境质量和居民生活的重要因素。传统的环境监测方式存在实时性差、数据分散等问题，因此设计一套基于物联网的实时监测系统具有重要的现实意义。

### 实际问题解决
虽然市场上已有一些成熟的环境监测产品，但本项目旨在：
- 构建一个成本相对较低的监测原型系统
- 实现数据的实时采集、传输、显示
- 提供本地和远程双重报警机制
- 验证基于STM32的嵌入式物联网解决方案的可行性

### 项目定位
需要说明的是，本项目主要定位于技术验证和学习实践，是一个功能原型而非商业化产品。系统在精度、稳定性、防护等级等方面仍有提升空间，距离实际工程应用还需要进一步优化和完善。

### 社会价值与应用前景
该项目体现了物联网技术在环境保护领域的应用潜力，为后续相关研究和产品开发提供了技术参考。通过自主设计和实现，加深了对嵌入式系统、传感器技术、无线通信和云平台应用等知识的理解。

## 项目概览

**项目名称**：基于物联网的工地扬尘与噪音实时监测系统

**开发时间**：2025年2月 - 2025年5月

**项目类型**：个人毕业设计项目

**技术栈**：
- 主控芯片：STM32F103C8T6
- 开发语言：C语言
- 通信模块：ESP8266-01S WiFi模块
- 传感器：PMS7003（粉尘）、XM7903（噪音）、DHT11（温度、湿度）
- 本地界面：0.96寸OLED显示屏
- 远程界面：基于HBuilder X开发的移动端数据展示APP
- 通信协议：MQTT
- 云平台：OneNet

> 一句话描述：这是一个实时监测建筑工地PM2.5、PM10、噪音等环境参数的物联网系统

## 系统设计与实现

### 系统整体架构图
<p><CardImg src="/img/Docs/project1_3.jpg" alt="架构图" isCenter={true} /></p>

### PCB设计与原理图
<p><CardImg src="/img/Docs/project1_2.jpg" alt="原理图" isCenter={true} /></p>

### 关键代码
#### 1. 扬尘检测
`PMS7003`传感器数据解析模块，负责从串口接收的原始数据包中提取`PM2.5`等关键环境参数。
<Tabs>

  <TabItem value="PMS7003_c" label="PMS7003.c">
```c title="PMS7003.c"
/**
 * @file    PMS7003.c
 * @brief   PMS7003粉尘传感器驱动程序
 * @details 实现PMS7003传感器的数据解析和初始化功能
 */

#include "PMS7003.h"

/**
 * @brief   解析16位数据的宏定义
 * @details 将两个连续字节合并为一个16位无符号整数，高字节在前
 * @param   packet 指向数据包的指针
 * @param   index  数据在数据包中的起始索引
 * @return  uint16_t 解析后的16位数据
 */
#define PARSE_DATA(packet, index) \
    ((uint16_t)((packet[index] << 8) | packet[index + 1]))

// 注：传感器大约每隔1秒通过串口向MCU发送一次数据

/**
 * @brief   PMS7003数据包中各字段的索引位置枚举
 * @details 定义PMS7003数据包中各个数据字段在数组中的索引位置
 */
typedef enum {
    PM1_0_CF1    = 4,   ///< PM1.0浓度(CF=1标准)数据索引(高8位)
    PM2_5_CF1    = 6,   ///< PM2.5浓度(CF=1标准)数据索引(高8位)
    PM10_CF1     = 8,   ///< PM10浓度(CF=1标准)数据索引(高8位)
    PM1_0_Env    = 10,  ///< PM1.0浓度(大气环境)数据索引(高8位)
    PM2_5_Env    = 12,  ///< PM2.5浓度(大气环境)数据索引(高8位)
    PM10_Env     = 14,  ///< PM10浓度(大气环境)数据索引(高8位)
    Particles0_3 = 16,  ///< ≥0.3μm颗粒物数量数据索引(高8位)
    Particles0_5 = 18,  ///< ≥0.5μm颗粒物数量数据索引(高8位)
    Particles1_0 = 20,  ///< ≥1.0μm颗粒物数量数据索引(高8位)
    Particles2_5 = 22,  ///< ≥2.5μm颗粒物数量数据索引(高8位)
    Particles5_0 = 24,  ///< ≥5.0μm颗粒物数量数据索引(高8位)
    Particles10  = 26   ///< ≥10μm颗粒物数量数据索引(高8位)
} PM_DataIndex;

/**
 * @brief   解析PMS7003传感器数据包
 * @details 从串口接收的原始数据包中提取PM2.5等关键环境参数
 * @param   packet 指向接收到的数据包指针
 * @param   packet_len 数据包长度
 * @retval  PM_SensorData 解析后的传感器数据结构体
 * @note    数据校验已在串口1中断函数中完成，此处主要进行数据提取
 */
PM_SensorData PMS_ParseDataPacket(const uint8_t *packet, size_t packet_len) {
    PM_SensorData data = {0};           // 初始化数据结构体
    data.is_valid = false;              // 默认设置为无效数据

    // 基础校验：检查空指针或长度不足
    // (此处无需进行数据校验，因为在串口1中断函数已经校验过了)
    if (packet == NULL || packet_len < Particles10 + 2) {
        return data;
    }
    
    // 解析各字段数据
    data.pm1_0_cf1    = PARSE_DATA(packet, PM1_0_CF1);      // PM1.0 CF=1标准值
    data.pm2_5_cf1    = PARSE_DATA(packet, PM2_5_CF1);      // PM2.5 CF=1标准值
    data.pm10_cf1     = PARSE_DATA(packet, PM10_CF1);       // PM10 CF=1标准值
    data.pm1_0_env    = PARSE_DATA(packet, PM1_0_Env);      // PM1.0 大气环境值
    data.pm2_5_env    = PARSE_DATA(packet, PM2_5_Env);      // PM2.5 大气环境值
    data.pm10_env     = PARSE_DATA(packet, PM10_Env);       // PM10 大气环境值
    data.particles0_3 = PARSE_DATA(packet, Particles0_3);   // ≥0.3μm颗粒数量
    data.particles0_5 = PARSE_DATA(packet, Particles0_5);   // ≥0.5μm颗粒数量
    data.particles1_0 = PARSE_DATA(packet, Particles1_0);   // ≥1.0μm颗粒数量
    data.particles2_5 = PARSE_DATA(packet, Particles2_5);   // ≥2.5μm颗粒数量
    data.particles5_0 = PARSE_DATA(packet, Particles5_0);   // ≥5.0μm颗粒数量
    data.particles10  = PARSE_DATA(packet, Particles10);    // ≥10μm颗粒数量
    
    data.is_valid = true;  // 数据解析成功，标记为有效
    return data;
}

/**
 * @brief   初始化PMS7003传感器
 * @details 配置PMS7003传感器的控制引脚(GPIOB5和GPIOB6)
 * @param   void
 * @retval  void
 * @note    B5引脚控制传感器使能，B6引脚控制传感器复位
 */
void PMS7003_Init(void){
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);   // 使能GPIOB时钟
    
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;        // 推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6;  // 配置B5和B6引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       // 输出速度50MHz
    GPIO_Init(GPIOB, &GPIO_InitStructure);                  // 初始化GPIOB
    
    // 设置B5、B6引脚为高电平，使传感器处于正常工作状态
    GPIO_SetBits(GPIOB, GPIO_Pin_5 | GPIO_Pin_6);
}
```
  </TabItem>

  <TabItem value="PMS7003_h" label="PMS7003.h">
```c title="PMS7003.h"
#ifndef __PMS7003_H
#define __PMS7003_H
#include "stm32f10x.h"                  // Device header
#include <stdbool.h>
#include <stddef.h>  // 用于NULL定义
// 结构体定义（所有需要使用的文件都包含此头文件）
typedef struct {
    uint16_t pm1_0_cf1;    			// 数据1: PM1.0 CF=1
    uint16_t pm2_5_cf1;     		// 数据2: PM2.5 CF=1
    uint16_t pm10_cf1;      		// 数据3: PM10 CF=1
    uint16_t pm1_0_env;     		// 数据4: PM1.0 大气环境
    uint16_t pm2_5_env;     		// 数据5: PM2.5 大气环境
    uint16_t pm10_env;      		// 数据6: PM10 大气环境
    uint16_t particles0_3;  		// 数据7: ≥0.3μm颗粒数
    uint16_t particles0_5;  		// 数据8: ≥0.5μm颗粒数
    uint16_t particles1_0;  		// 数据9: ≥1.0μm颗粒数
    uint16_t particles2_5;  		// 数据10: ≥2.5μm颗粒数
    uint16_t particles5_0;  		// 数据11: ≥5.0μm颗粒数
    uint16_t particles10;   		// 数据12: ≥10μm颗粒数
    bool is_valid;          		// 校验通过标志
} PM_SensorData;
PM_SensorData PMS_ParseDataPacket(const uint8_t *packet, size_t packet_len);
void PMS7003_Init(void);
#endif 


//以空行结尾

```
  </TabItem>

</Tabs>

#### 2. 噪音检测
`XM7903`传感器数据解析模块，包含`数据包发送`和`数据包解析`两部分代码。
<Tabs>

  <TabItem value="XM7903_c" label="XM7903.c">
```c title="XM7903.c"
/**
 * @file    XM7903.c
 * @brief   XM7903噪音传感器驱动程序
 * @details 实现XM7903传感器的数据读取和解析功能
 */

#include "XM7903.h"

/**
 * @brief XM7903读取噪音数据的Modbus RTU命令包
 * @details 格式为：[地址][功能码][起始地址H][起始地址L][数据长度H][数据长度L][CRC H][CRC L]
 *          0x01: 设备地址
 *          0x03: 读保持寄存器功能码
 *          0x00 0x00: 起始寄存器地址(0x0000)
 *          0x00 0x01: 读取寄存器数量(1个)
 *          0x84 0x0A: CRC16校验码
 */
u8 Read_Noise_Data[8] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x01, 0x84, 0x0A};    

/**
 * @brief   向XM7903传感器发送数据读取命令
 * @details 通过USART3串口发送Modbus RTU读取命令包
 * @param   None
 * @retval  None
 * @note    传感器接收到命令后会返回噪音数据
 */
void XM7903_SendPacket(void)
{
    Serial_SendArray(USART3, Read_Noise_Data, TxPaket_Length); // 发送Modbus读取命令包     
}

/**
 * @brief   解析并获取噪音传感器数据
 * @details 从USART3接收的数据包中提取噪音值，并进行CRC校验
 * @param   None
 * @retval  float - 噪音值(dBA)，解析失败时返回0.0
 * @note    噪音值需要除以10得到实际的小数数值
 */
float Get_Nosie_Data(void)
{
    u16 Noise = 0;  // 存储解析出的噪音原始数据
    
    // 提取接收数据包中的CRC校验码(第6、7字节)
    u16 crc = (Usart3_RxPaket[5] << 8) | Usart3_RxPaket[6];
    
    // 计算接收数据包前5字节的CRC校验码
    u16 calcCrc = crc16(Usart3_RxPaket, 5);  
    
    // CRC校验对比，确保数据完整性
    if (crc == calcCrc) {
        // CRC校验通过，提取噪音数据(第4、5字节)
        Noise = (Usart3_RxPaket[3] << 8) | Usart3_RxPaket[4];  
    }	
    
    // 将原始数据转换为实际噪音值(原始值除以10得到一位小数的dBA值)
    return (float)Noise / 10.0;      
}

```
  </TabItem>

  <TabItem value="XM7903_h" label="XM7903.h">
```c title="XM7903.h"
/**
 * @file    XM7903.h
 * @brief   XM7903噪音传感器驱动头文件
 * @details 声明XM7903传感器相关的函数和宏定义
 */

#ifndef __XM7903_H
#define __XM7903_H

#include "stm32f10x.h"    // STM32F10x系列处理器头文件
#include "CRC16.h"        // CRC16校验算法头文件
#include "usart.h"        // USART串口通信头文件

#define TxPaket_Length    8    ///< 发送数据包长度(字节)

void XM7903_SendPacket(void);

float Get_Nosie_Data(void);

#endif 

```
  </TabItem>

</Tabs>

#### 3. 主函数
#### 主程序流程图
<img
  src="/img/Docs/project1_4.jpg"
  alt="主程序流程图"
  style={{
    width: '100%',
    maxWidth: '200px',
    height: 'auto',
    display: 'block',
    margin: '0 auto'
  }}
/>

#### 主程序关键代码
```c title="main.c"
int main(){
	Initialize_Hardware();
	ReadStoreErrorTime();
	Check_Reset_Way();//检查复位方式，若是看门狗复位，复位次数加一并储存到FLASH中	    
	Initialize_System();
	OLED_UI_Init(&MainMenuPage);//UI初始化
	MyRTC_Init();//系统时间设置
	MYIWD_Init(2000);//独立看门狗初始化，喂狗间隔为2000ms
	PM_Data.pm2_5_env = 100;//静态警报测试
	decibels = 40;
	PM2_5_ENV = PM_Data.pm2_5_env;
	while(1){
		Get_dBA();//获取噪音数据
		DMATaskHandler();//获取扬尘数据
                Handle_Alarm();// 处理报警条件
                OLED_UI_MainLoop();	//显示刷新
		TaskHandler();//任务处理（包含数据发送、时间获取、警报处理等事件）
		Handle_Thresholds();//保存与恢复默认阈值
		Handle_Network_Data();//接收OneNet数据
		IWDG_ReloadCounter();//喂狗
	}
}

//中断函数
void TIM4_IRQHandler(void)
{
	if (TIM_GetITStatus(TIM4, TIM_IT_Update) == SET)
	{
		OLED_UI_InterruptHandler();
		
		TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
	}
}
void TIM2_IRQHandler(void)
{
    // 检查是否有更新中断发生
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    {
        TaskSchedule();
        // 清除更新中断的标志位
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
    }

}
```

#### 程序执行流程说明
系统主程序采用**事件驱动的循环架构**，主要包含以下几个核心环节：

1. **系统初始化阶段**
   - 硬件外设初始化（OLED、传感器、通信模块等）
   - 网络连接与云平台接入
   - 系统参数加载与看门狗配置

2. **主循环事件处理**
   - 传感器数据采集与处理
   - 环境参数监测与报警判断
   - 数据上传与远程指令处理
   - 用户界面刷新与交互响应

3. **任务调度机制**
   采用基于时间片的**任务调度器**管理多个并发任务：
   - 数据发送任务（3秒周期）
   - 传感器读取任务（1秒周期）
   - 报警处理任务（0.5秒周期）
   - 网络数据处理任务（事件触发）

4. **异常处理与系统维护**
   - 看门狗喂狗确保系统稳定运行
   - 错误检测与自动恢复机制
   - 数据存储与状态保存
### 实物展示
<img
  src="/img/Docs/project1_1.jpg"
  alt="示例图片"
  style={{
    width: '100%',
    maxWidth: '350px',
    height: 'auto',
    display: 'block',
    margin: '0 auto'
  }}
/>

### 实现功能
- 实时检测环境中的PM2.5、PM10、噪音等参数。
- 实时上传环境数据至云平台，供用户在手机端查看。
- 当扬尘、噪音大于阈值时，发出声光警报。
- 系统复位与故障记录<sup>[1](#module-explanation)</sup>
- 可在本地或手机端进行阈值修改
- OLED UI简洁、易用

### 功能演示

<iframe 
  width="100%" 
  height="500" 
  src="https://www.bilibili.com/video/BV15tn1zWETX/?spm_id_from=333.1387.homepage.video_card.click&vd_source=bc8505b367ad154f03537e6dcbc577d8" 
  frameborder="0" 
  allowfullscreen>
</iframe>

#### 说明

该视频为毕业设计后期制作，主要用于毕设答辩过程的现场演示。需要注意的是：

1. 视频中个别部分在实际答辩时配有现场讲解说明，但未能完全体现在视频中
2. 演示内容并非项目全貌，未涵盖各个功能模块的详细展示以及数据准确性的验证过程
3. 以上缺失内容已在毕业论文中有详细阐述

本视频作为项目的简要功能演示，应已足够，如有需要，后续可进行图文补充说明。


## 项目成果评估

本项目作为本科毕业设计原型系统，在有限时间与资源条件下，基本实现了预设功能目标。以下从功能完整性、性能表现和系统稳定性三个方面进行客观评估。


### 功能实现程度

| 预设功能 | 实现情况 | 说明 |
|--------|--------|------|
| 实时监测 PM2.5/PM10/噪音 | ✅ 完全实现 | PMS7003 每 2 秒输出一次数据，XM7903 每 0.5 秒轮询一次，数据实时刷新于 OLED 与手机端 |
| 数据无线上传至云平台 | ✅ 完全实现 | 通过 ESP8266 使用 MQTT 协议，每 3 秒向 OneNet 发送一次 JSON 数据包，包含所有传感器读数 |
| 超限声光报警 | ✅ 完全实现 | 本地通过蜂鸣器和 LED 报警；手机 APP 以图标形式显示扬尘或噪音超限状态，实现远程可视化提示 |
| 本地与远程阈值配置 | ✅ 基本实现 | 支持双向同步：本地 OLED 菜单可修改并保存阈值至 FLASH；手机端也可设置阈值并通过 OneNet 下发，设备接收后自动更新并在 OLED 显示 |
| 系统异常监控与故障恢复 | ✅ 实现 | 系统具备多级异常处理能力：(1) 主循环卡死时由独立看门狗触发复位；(2) 传感器或通信故障（如 PMS7003 连续无数据、MQTT 发送/接收失败）累计超限后，记录错误类型与时间至 FLASH 并复位；(3) 报警模块异常仅记录日志，不复位。所有历史错误可通过 OLED 菜单 “更多 → 错误日志” 查询。 |

> **总结**：项目已完整实现从数据采集、云端上传、跨端报警到异常自恢复的全链路功能，本地与远程交互基本同步，作为本科毕设原型系统，达到了功能验证与工程实践的双重目标。

### 性能指标

受限于个人条件，未使用专业级环境监测仪器进行标定，但通过**对比测试、逻辑验证与实地部署**，对系统关键性能进行了评估。

#### 1. 测量精度与响应特性

- **PM2.5 监测**  
  采用“点燃纸张”作为可控颗粒物源进行功能验证：  
  - 引入测试源后，PM2.5 浓度在数秒内从约 40 µg/m³ 快速上升至 **495 µg/m³**，触发本地 LED 报警；  
  - 移除测试源并自然通风后，数值逐步回落至 **44 µg/m³**，表明传感器对浓度变化**响应迅速、恢复稳定**。  
  > 虽无法提供绝对精度，但重复测试中趋势一致，符合 PMS7003 激光散射原理的预期行为。

- **噪音监测**  
  使用**标准声级计**（自购手持式分贝计）与系统并置测试：  
  - 在 220 Hz 正弦波稳定声源下，系统读数为 **75 dB(A)**，标准分贝计读数为 **74.3 dB(A)**，偏差仅 **0.7 dB**；  
  - 在工地实测中，远离施工区测得 **63 dB(A)**，靠近施工区测得 **88 dB(A)** 并成功触发报警，与现场感知一致。  
  > 结果表明 XM7903 在常见噪声范围内（`<90 dB`）具备良好线性度与实用性。

- **温湿度监测**  
  DHT11 仅用于环境辅助参考，未参与核心逻辑判断，其 ±2°C / ±5% RH 的典型误差在本项目中可接受。

#### 2. 系统响应时间

| 场景 | 响应延迟 | 说明 |
|------|--------|------|
| 环境突变 → OLED 更新 | ≤ 2 秒 | 如点燃纸张后，OLED 在 1–2 秒内显示 PM2.5 上升 |
| 本地采集 → OneNet 云端可见 | 3–4 秒 | 受限于 MQTT 每 3 秒发送一次的周期设计 |
| 超限 → 本地报警触发 | < 1 秒 | 阈值判断在主循环高频执行 |
| 手机端阈值修改 → 设备生效 | ≤ 3 秒 | OneNet 下行指令接收后立即更新，APP 因拉取机制存在界面刷新延迟 |

> 注：受限于个人条件，测试分别在宿舍阳台（PM2.5）、寝室（噪音）及工地围挡外（约30分钟实地运行）等非标准环境中进行。系统在此期间运行正常，未发生死机或通信中断，初步验证了其基础可靠性。

### 稳定性测试结果

本项目进行了**24小时连续运行测试**，并通过系统内置的**错误日志**机制统计异常复位情况。

#### 测试结果
- **总复位次数**：25次  
- **主要复位原因**：数据无法发送至 OneNet 云平台（占比 96%）  
- **平均恢复时间**：约 20–30 秒（从复位触发到重新连接 WiFi 并成功上传数据）

#### 分析与反思

**1. 复位主因是外部网络不稳定**  
测试期间使用手机热点作为网络源，其信号质量存在明显波动。日志分析显示，系统复位并非均匀分布：在网络较差时段，**10分钟内曾连续触发5次以上“数据无法发送”异常并导致复位**；而在网络相对稳定的时段，**可连续4–5小时无任何复位发生**。这表明复位行为高度依赖外部网络状态。由于系统将“MQTT 发送失败”视为影响核心功能的严重异常，一旦检测到通信失败即触发独立看门狗复位，以确保软硬件状态彻底重置，避免错误累积。

**2. 系统具备良好的自恢复能力**  
尽管复位频繁，但每次均能自动重新初始化网络、传感器及通信模块，并在30秒内恢复正常监测与数据上传。据此估算，**24小时内有效运行时间超过99%。**

**3. 当前策略的合理性与局限性**  
在资源受限（无 RTOS、内存紧张）的条件下，采用“异常即复位”是一种简单可靠的容错方案，可有效避免状态混乱或内存泄漏等更严重问题。  
但该策略对网络抖动过于敏感，**以短暂服务中断为代价换取系统确定性恢复**。

#### 不足及后续改进思路

当前系统在检测到数据连续`两次无法发送`至云平台后，会立即进入`3秒延时`（期间不再尝试发送），超时后因未喂狗而触发硬复位。该逻辑存在明显缺陷：**即使网络在延时期间恢复，系统也无法感知，仍会强制复位**，造成不必要的服务中断。

更合理的策略是引入**可撤销的故障确认机制**：
- 当连续两次发送失败时，置位 `network_failure_pending` 标志；
- 在定时器中断中检测该标志，若置位则启动3秒倒计时；
- **在此期间，若任一次数据发送成功，则清空标志并取消复位流程**；
- 仅当3秒内始终无法成功发送，才真正触发看门狗复位。

此方案在保留快速响应严重故障能力的同时，有效避免了对瞬时网络抖动的过度反应，可显著提升系统可用性。

#### 结论
在当前测试条件下，系统虽因外部网络问题导致短时间频繁复位，但**核心监测功能保持高可用，且具备可靠的自恢复能力**。作为本科毕设原型系统，已满足基本稳定性要求。

> 受限于当前测试环境，本项目完成了24小时连续运行验证。若未来具备更稳定的网络与供电条件，可进一步开展7×24小时老化测试，以全面评估长期可靠性。




## 开发过程与挑战  
### 遇到的主要技术难题  

1. **多传感器数据同步与异常检测机制设计**  
   - 系统需同时处理 PMS7003（PM2.5）、XM7903（噪音）、DHT11（温湿度） 三种异构传感器；  
   - 各传感器通信方式不同（UART+DMA、UART轮询、单总线），且无统一中断触发机制；  
   - 如何在无 RTOS 的裸机环境下，可靠判断“传感器失联”而非“瞬时干扰” 成为难点。  
   - 📌 典型问题：XM7903 数据包 CRC 校验失败导致 `decibels=0`，但系统需区分“真故障”与“偶发丢包”。  

2. **OLED 动态文本显示的边界逻辑缺陷**  
   - 菜单系统支持长字符串滚动显示，但当一行需滚动、下一行接近显示极限但不滚动时，静态行出现异常左偏移；  
   - 问题表现为：视觉错位 + 反显条覆盖不全（如 `temp:85` 中 “5” 裸露在外）；  
   - 初期难以复现，且与按键切换菜单行顺序强相关，调试困难。  

3. **Flash 存储空间逼近 MCU 极限引发的隐性崩溃**  
   - STM32F103C8T6（64KB Flash）在编译优化等级低时，程序体积达 63.87KB；  
   - 导致复位后无法正常启动（疑似向量表加载异常），必须重新烧录；  
   - 此类问题无明确错误提示，排查耗时极长。  

4. **看门狗复位策略过于激进，缺乏“可撤销”容错窗口**  
   - 原逻辑：连续 2 次数据发送失败 → 进入 `Delay_s(3)` → 必然复位；  
   - 缺陷：即使第 3 次能成功，也无法阻止复位，造成不必要的服务中断；  
   - 类似问题也存在于传感器异常处理中（如 `Dust_Data_Error` 强制延时复位）。  

5. **任务调度与时序耦合导致的副作用**  
   - 报警记录任务（`ALARM_WRITE_INTERVAL_MS = 10s`）与噪音数据接收存在未知干扰；  
   - 注释中提到：“此值居然能影响噪音数据接收”，疑似因频繁操作 Flash 或主循环阻塞导致 UART 接收缓冲区溢出。
### 解决方案和思路

✅ 1. **构建“基于时间片 + DMA 触发”的混合任务调度器**  
   - 设计 `TaskComps_t` 结构体，实现软件定时器轮询；  
   - 对 PMS7003 使用 DMA + 标志位 触发数据解析，避免主循环轮询阻塞；  
   - 对 DHT11、ESP8266 等慢速设备采用重试 + 超时退出策略（如 DHT11 初始化最多重试 5 次后跳过）；  
   - **优势**：在无 OS 下实现近似“并发”，资源开销极低。

✅ 2. **修复 OLED 显示逻辑：动态计算完整字符串宽度**  
   - **根本原因**：滚动判断时未包含动态参数值（如 `%d` 替换后的数字）；  
   - **修复方法**：
     ```c
     // 错误：仅计算格式字符串宽度
     CalcStringWidth("噪音阈值：%d dBA");
     // 正确：传入实际值，计算完整显示宽度
     CalcStringWidth("噪音阈值：%d dBA", Noise_Limit);
     ```
   - 同步修正 `OLED_PrintfMixArea` 调用，确保反显条覆盖完整文本。

✅ 3. **严格控制 Flash 使用，启用编译器高级优化**  
   - 将 Keil 的 Optimization Level 提升至 `-O3`，程序体积从 >64KB 降至安全范围；  
   - 在代码注释中明确提醒：“务必开启高优化等级，否则 Flash 溢出会导致复位失败”；  
   - 同时为 ROM 预留 4–6KB 余量，避免临界状态下的不可控行为。

✅ 4. **提出“可撤销故障确认”机制（待实施）**  
   - 放弃“失败即延时复位”的硬逻辑；  
   - 改为：置标志位 → 启动 3 秒观察窗 → 若期间恢复则取消复位；  
   - 此方案已在文档中详细描述，具备直接落地条件。

✅ 5. **模块化错误处理，区分“致命错误”与“可恢复异常”**  
   - 对 ESP8266 初始化、MQTT 连接等关键步骤，**区分错误码类型**：  
     - 配置错误（如鉴权失败）→ 直接复位；  
     - 网络超时 → 重试若干次后复位；  
   - 对传感器数据异常，**仅记录错误类型并存储到 Flash**，暂不强制复位（如已注释掉 `NOise_Data_Error` 的 `Delay_s(3)`）。
### 学习心得体会

**“稳定”不等于“零故障”，而是“可控恢复”**  
在资源受限的嵌入式系统中，追求绝对无错既不现实也不必要。真正重要的是：当异常发生时，系统能否以确定性方式恢复，并保留关键状态。本次项目通过看门狗 + Flash 日志 + 自恢复流程，实现了这一目标。

**细节决定成败，边界条件是 bug 的温床**  
OLED 显示偏移、Flash 临界溢出等问题，都源于对“边缘场景”的忽视。今后开发中，我会更注重：  
- 字符串长度计算是否包含动态内容；  
- 存储空间是否预留安全余量；  
- 任务时序是否存在隐性耦合。

**裸机开发也能写出高内聚、低耦合的代码**  
通过 `TaskComps`、`DMATaskComps`、`ErrorType()` 等抽象，即使没有 RTOS，也能实现清晰的模块划分。这让我意识到：**架构思想比工具更重要**。

**调试日志和用户反馈是解决问题的双翼**  
如果没有 OLED 实时显示初始化状态、没有详细的错误码分类，很多问题将陷入“黑盒”。未来项目中，我会更早引入可视化调试手段。

**工程是权衡的艺术**  
为了节省 RAM，放弃动态内存分配；为了简化逻辑，采用“异常即复位”；这些选择都有代价，但在约束条件下做出了最优解——这正是嵌入式工程师的核心价值。


## 未来改进方向
- 当前存在的局限性
- 可能的优化方案
- 扩展功能设想


## 补充说明
<div id="module-explanation">
1. 通过看门狗持续监控系统运行状态。当检测到系统异常时，自动触发系统复位并将错误信息（包括错误类型和发生时间）保存至FLASH存储器，支持通过OLED显示屏查询历史故障记录。
</div>

---
sidebar_label: '工地环境实时监测终端'
title: 工地环境实时监测终端
sidebar_position: 1.0
description: 这是我的毕业设计，也是我实现的第一个完整的嵌入式项目，颇具纪念意义！
---

import CardImg from '@site/src/components/CardImg';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';

## 项目背景

### 项目来源
本项目为本科毕业设计课题，由指导老师提供选题。随着城市化进程加快，建筑工地产生的扬尘和噪音污染已成为影响城市环境质量和居民生活的重要因素。传统的环境监测方式存在实时性差、数据分散等问题，因此设计一套基于物联网的实时监测系统具有重要的现实意义。

### 实际问题解决
虽然市场上已有一些成熟的环境监测产品，但本项目旨在：
- 构建一个成本相对较低的监测原型系统
- 实现数据的实时采集、传输、显示
- 提供本地和远程双重报警机制
- 验证基于STM32的嵌入式物联网解决方案的可行性

### 项目定位
需要说明的是，本项目主要定位于技术验证和学习实践，是一个功能原型而非商业化产品。系统在精度、稳定性、防护等级等方面仍有提升空间，距离实际工程应用还需要进一步优化和完善。

### 社会价值与应用前景
该项目体现了物联网技术在环境保护领域的应用潜力，为后续相关研究和产品开发提供了技术参考。通过自主设计和实现，加深了对嵌入式系统、传感器技术、无线通信和云平台应用等知识的理解。

## 项目概览

**项目名称**：基于物联网的工地扬尘与噪音实时监测系统

**开发时间**：2025年2月 - 2025年5月

**项目类型**：个人毕业设计项目

**技术栈**：
- 主控芯片：STM32F103C8T6
- 开发语言：C语言
- 通信模块：ESP8266-01S WiFi模块
- 传感器：PMS7003（粉尘）、XM7903（噪音）、DHT11（温度、湿度）
- 本地界面：0.96寸OLED显示屏
- 远程界面：基于HBuilder X开发的移动端数据展示APP
- 通信协议：MQTT
- 云平台：OneNet

> 一句话描述：这是一个实时监测建筑工地PM2.5、PM10、噪音等环境参数的物联网系统

## 系统设计与实现

### 系统整体架构图
<p><CardImg src="/img/Docs/project1_3.jpg" alt="架构图" isCenter={true} /></p>

### PCB设计与原理图
<p><CardImg src="/img/Docs/project1_2.jpg" alt="原理图" isCenter={true} /></p>

### 关键代码
#### 1. 扬尘检测
`PMS7003`传感器数据解析模块，负责从串口接收的原始数据包中提取`PM2.5`等关键环境参数。
<Tabs>

  <TabItem value="PMS7003_c" label="PMS7003.c">
```c title="PMS7003.c"
/**
 * @file    PMS7003.c
 * @brief   PMS7003粉尘传感器驱动程序
 * @details 实现PMS7003传感器的数据解析和初始化功能
 */

#include "PMS7003.h"

/**
 * @brief   解析16位数据的宏定义
 * @details 将两个连续字节合并为一个16位无符号整数，高字节在前
 * @param   packet 指向数据包的指针
 * @param   index  数据在数据包中的起始索引
 * @return  uint16_t 解析后的16位数据
 */
#define PARSE_DATA(packet, index) \
    ((uint16_t)((packet[index] << 8) | packet[index + 1]))

// 注：传感器大约每隔1秒通过串口向MCU发送一次数据

/**
 * @brief   PMS7003数据包中各字段的索引位置枚举
 * @details 定义PMS7003数据包中各个数据字段在数组中的索引位置
 */
typedef enum {
    PM1_0_CF1    = 4,   ///< PM1.0浓度(CF=1标准)数据索引(高8位)
    PM2_5_CF1    = 6,   ///< PM2.5浓度(CF=1标准)数据索引(高8位)
    PM10_CF1     = 8,   ///< PM10浓度(CF=1标准)数据索引(高8位)
    PM1_0_Env    = 10,  ///< PM1.0浓度(大气环境)数据索引(高8位)
    PM2_5_Env    = 12,  ///< PM2.5浓度(大气环境)数据索引(高8位)
    PM10_Env     = 14,  ///< PM10浓度(大气环境)数据索引(高8位)
    Particles0_3 = 16,  ///< ≥0.3μm颗粒物数量数据索引(高8位)
    Particles0_5 = 18,  ///< ≥0.5μm颗粒物数量数据索引(高8位)
    Particles1_0 = 20,  ///< ≥1.0μm颗粒物数量数据索引(高8位)
    Particles2_5 = 22,  ///< ≥2.5μm颗粒物数量数据索引(高8位)
    Particles5_0 = 24,  ///< ≥5.0μm颗粒物数量数据索引(高8位)
    Particles10  = 26   ///< ≥10μm颗粒物数量数据索引(高8位)
} PM_DataIndex;

/**
 * @brief   解析PMS7003传感器数据包
 * @details 从串口接收的原始数据包中提取PM2.5等关键环境参数
 * @param   packet 指向接收到的数据包指针
 * @param   packet_len 数据包长度
 * @retval  PM_SensorData 解析后的传感器数据结构体
 * @note    数据校验已在串口1中断函数中完成，此处主要进行数据提取
 */
PM_SensorData PMS_ParseDataPacket(const uint8_t *packet, size_t packet_len) {
    PM_SensorData data = {0};           // 初始化数据结构体
    data.is_valid = false;              // 默认设置为无效数据

    // 基础校验：检查空指针或长度不足
    // (此处无需进行数据校验，因为在串口1中断函数已经校验过了)
    if (packet == NULL || packet_len < Particles10 + 2) {
        return data;
    }
    
    // 解析各字段数据
    data.pm1_0_cf1    = PARSE_DATA(packet, PM1_0_CF1);      // PM1.0 CF=1标准值
    data.pm2_5_cf1    = PARSE_DATA(packet, PM2_5_CF1);      // PM2.5 CF=1标准值
    data.pm10_cf1     = PARSE_DATA(packet, PM10_CF1);       // PM10 CF=1标准值
    data.pm1_0_env    = PARSE_DATA(packet, PM1_0_Env);      // PM1.0 大气环境值
    data.pm2_5_env    = PARSE_DATA(packet, PM2_5_Env);      // PM2.5 大气环境值
    data.pm10_env     = PARSE_DATA(packet, PM10_Env);       // PM10 大气环境值
    data.particles0_3 = PARSE_DATA(packet, Particles0_3);   // ≥0.3μm颗粒数量
    data.particles0_5 = PARSE_DATA(packet, Particles0_5);   // ≥0.5μm颗粒数量
    data.particles1_0 = PARSE_DATA(packet, Particles1_0);   // ≥1.0μm颗粒数量
    data.particles2_5 = PARSE_DATA(packet, Particles2_5);   // ≥2.5μm颗粒数量
    data.particles5_0 = PARSE_DATA(packet, Particles5_0);   // ≥5.0μm颗粒数量
    data.particles10  = PARSE_DATA(packet, Particles10);    // ≥10μm颗粒数量
    
    data.is_valid = true;  // 数据解析成功，标记为有效
    return data;
}

/**
 * @brief   初始化PMS7003传感器
 * @details 配置PMS7003传感器的控制引脚(GPIOB5和GPIOB6)
 * @param   void
 * @retval  void
 * @note    B5引脚控制传感器使能，B6引脚控制传感器复位
 */
void PMS7003_Init(void){
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);   // 使能GPIOB时钟
    
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;        // 推挽输出模式
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6;  // 配置B5和B6引脚
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;       // 输出速度50MHz
    GPIO_Init(GPIOB, &GPIO_InitStructure);                  // 初始化GPIOB
    
    // 设置B5、B6引脚为高电平，使传感器处于正常工作状态
    GPIO_SetBits(GPIOB, GPIO_Pin_5 | GPIO_Pin_6);
}
```
  </TabItem>

  <TabItem value="PMS7003_h" label="PMS7003.h">
```c title="PMS7003.h"
#ifndef __PMS7003_H
#define __PMS7003_H
#include "stm32f10x.h"                  // Device header
#include <stdbool.h>
#include <stddef.h>  // 用于NULL定义
// 结构体定义（所有需要使用的文件都包含此头文件）
typedef struct {
    uint16_t pm1_0_cf1;    			// 数据1: PM1.0 CF=1
    uint16_t pm2_5_cf1;     		// 数据2: PM2.5 CF=1
    uint16_t pm10_cf1;      		// 数据3: PM10 CF=1
    uint16_t pm1_0_env;     		// 数据4: PM1.0 大气环境
    uint16_t pm2_5_env;     		// 数据5: PM2.5 大气环境
    uint16_t pm10_env;      		// 数据6: PM10 大气环境
    uint16_t particles0_3;  		// 数据7: ≥0.3μm颗粒数
    uint16_t particles0_5;  		// 数据8: ≥0.5μm颗粒数
    uint16_t particles1_0;  		// 数据9: ≥1.0μm颗粒数
    uint16_t particles2_5;  		// 数据10: ≥2.5μm颗粒数
    uint16_t particles5_0;  		// 数据11: ≥5.0μm颗粒数
    uint16_t particles10;   		// 数据12: ≥10μm颗粒数
    bool is_valid;          		// 校验通过标志
} PM_SensorData;
PM_SensorData PMS_ParseDataPacket(const uint8_t *packet, size_t packet_len);
void PMS7003_Init(void);
#endif 


//以空行结尾

```
  </TabItem>

</Tabs>

#### 2. 噪音检测
`XM7903`传感器数据解析模块，包含`数据包发送`和`数据包解析`两部分代码。
<Tabs>

  <TabItem value="XM7903_c" label="XM7903.c">
```c title="XM7903.c"
/**
 * @file    XM7903.c
 * @brief   XM7903噪音传感器驱动程序
 * @details 实现XM7903传感器的数据读取和解析功能
 */

#include "XM7903.h"

/**
 * @brief XM7903读取噪音数据的Modbus RTU命令包
 * @details 格式为：[地址][功能码][起始地址H][起始地址L][数据长度H][数据长度L][CRC H][CRC L]
 *          0x01: 设备地址
 *          0x03: 读保持寄存器功能码
 *          0x00 0x00: 起始寄存器地址(0x0000)
 *          0x00 0x01: 读取寄存器数量(1个)
 *          0x84 0x0A: CRC16校验码
 */
u8 Read_Noise_Data[8] = {0x01, 0x03, 0x00, 0x00, 0x00, 0x01, 0x84, 0x0A};    

/**
 * @brief   向XM7903传感器发送数据读取命令
 * @details 通过USART3串口发送Modbus RTU读取命令包
 * @param   None
 * @retval  None
 * @note    传感器接收到命令后会返回噪音数据
 */
void XM7903_SendPacket(void)
{
    Serial_SendArray(USART3, Read_Noise_Data, TxPaket_Length); // 发送Modbus读取命令包     
}

/**
 * @brief   解析并获取噪音传感器数据
 * @details 从USART3接收的数据包中提取噪音值，并进行CRC校验
 * @param   None
 * @retval  float - 噪音值(dBA)，解析失败时返回0.0
 * @note    噪音值需要除以10得到实际的小数数值
 */
float Get_Nosie_Data(void)
{
    u16 Noise = 0;  // 存储解析出的噪音原始数据
    
    // 提取接收数据包中的CRC校验码(第6、7字节)
    u16 crc = (Usart3_RxPaket[5] << 8) | Usart3_RxPaket[6];
    
    // 计算接收数据包前5字节的CRC校验码
    u16 calcCrc = crc16(Usart3_RxPaket, 5);  
    
    // CRC校验对比，确保数据完整性
    if (crc == calcCrc) {
        // CRC校验通过，提取噪音数据(第4、5字节)
        Noise = (Usart3_RxPaket[3] << 8) | Usart3_RxPaket[4];  
    }	
    
    // 将原始数据转换为实际噪音值(原始值除以10得到一位小数的dBA值)
    return (float)Noise / 10.0;      
}

```
  </TabItem>

  <TabItem value="XM7903_h" label="XM7903.h">
```c title="XM7903.h"
/**
 * @file    XM7903.h
 * @brief   XM7903噪音传感器驱动头文件
 * @details 声明XM7903传感器相关的函数和宏定义
 */

#ifndef __XM7903_H
#define __XM7903_H

#include "stm32f10x.h"    // STM32F10x系列处理器头文件
#include "CRC16.h"        // CRC16校验算法头文件
#include "usart.h"        // USART串口通信头文件

#define TxPaket_Length    8    ///< 发送数据包长度(字节)

void XM7903_SendPacket(void);

float Get_Nosie_Data(void);

#endif 

```
  </TabItem>

</Tabs>

#### 3. 主函数
#### 主程序流程图
<img
  src="/img/Docs/project1_4.jpg"
  alt="主程序流程图"
  style={{
    width: '100%',
    maxWidth: '200px',
    height: 'auto',
    display: 'block',
    margin: '0 auto'
  }}
/>

#### 主程序关键代码
```c title="main.c"
int main(){
	Initialize_Hardware();
	ReadStoreErrorTime();
	Check_Reset_Way();//检查复位方式，若是看门狗复位，复位次数加一并储存到FLASH中	    
	Initialize_System();
	OLED_UI_Init(&MainMenuPage);//UI初始化
	MyRTC_Init();//系统时间设置
	MYIWD_Init(2000);//独立看门狗初始化，喂狗间隔为2000ms
	PM_Data.pm2_5_env = 100;//静态警报测试
	decibels = 40;
	PM2_5_ENV = PM_Data.pm2_5_env;
	while(1){
		Get_dBA();//获取噪音数据
		DMATaskHandler();//获取扬尘数据
                Handle_Alarm();// 处理报警条件
                OLED_UI_MainLoop();	//显示刷新
		TaskHandler();//任务处理（包含数据发送、时间获取、警报处理等事件）
		Handle_Thresholds();//保存与恢复默认阈值
		Handle_Network_Data();//接收OneNet数据
		IWDG_ReloadCounter();//喂狗
	}
}

//中断函数
void TIM4_IRQHandler(void)
{
	if (TIM_GetITStatus(TIM4, TIM_IT_Update) == SET)
	{
		OLED_UI_InterruptHandler();
		
		TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
	}
}
void TIM2_IRQHandler(void)
{
    // 检查是否有更新中断发生
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
    {
        TaskSchedule();
        // 清除更新中断的标志位
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
    }

}
```

#### 程序执行流程说明
系统主程序采用**事件驱动的循环架构**，主要包含以下几个核心环节：

1. **系统初始化阶段**
   - 硬件外设初始化（OLED、传感器、通信模块等）
   - 网络连接与云平台接入
   - 系统参数加载与看门狗配置

2. **主循环事件处理**
   - 传感器数据采集与处理
   - 环境参数监测与报警判断
   - 数据上传与远程指令处理
   - 用户界面刷新与交互响应

3. **任务调度机制**
   采用基于时间片的**任务调度器**管理多个并发任务：
   - 数据发送任务（3秒周期）
   - 传感器读取任务（1秒周期）
   - 报警处理任务（0.5秒周期）
   - 网络数据处理任务（事件触发）

4. **异常处理与系统维护**
   - 看门狗喂狗确保系统稳定运行
   - 错误检测与自动恢复机制
   - 数据存储与状态保存
### 实物展示
<img
  src="/img/Docs/project1_1.jpg"
  alt="示例图片"
  style={{
    width: '100%',
    maxWidth: '350px',
    height: 'auto',
    display: 'block',
    margin: '0 auto'
  }}
/>

### 实现功能
- 实时检测环境中的PM2.5、PM10、噪音等参数。
- 实时上传环境数据至云平台，供用户在手机端查看。
- 当扬尘、噪音大于阈值时，发出声光警报。
- 系统复位与故障记录。
- 可在本地或手机端进行阈值修改。
- OLED UI简洁、易用。

### 功能演示

<iframe 
  width="100%" 
  height="500" 
  src="https://www.bilibili.com/video/BV15tn1zWETX/?spm_id_from=333.1387.homepage.video_card.click&vd_source=bc8505b367ad154f03537e6dcbc577d8" 
  frameborder="0" 
  allowfullscreen>
</iframe>

#### 说明

该视频为毕业设计后期制作，主要用于毕设答辩过程的现场演示。需要注意的是：

1. 视频中个别部分在实际答辩时配有现场讲解说明，但未能完全体现在视频中
2. 演示内容并非项目全貌，未涵盖各个功能模块的详细展示以及数据准确性的验证过程
3. 以上缺失内容已在毕业论文中有详细阐述

本视频作为项目的简要功能演示，应已足够，如有需要，后续可进行图文补充说明。


## 项目成果评估

本项目作为本科毕业设计原型系统，在有限时间与资源条件下，基本实现了预设功能目标。以下从功能完整性、性能表现和系统稳定性三个方面进行客观评估。


### 功能实现程度

| 预设功能 | 实现情况 | 说明 |
|--------|--------|------|
| 实时监测 PM2.5/PM10/噪音 | ✅ 完全实现 | PMS7003 每 2 秒输出一次数据，XM7903 每 0.5 秒轮询一次，数据实时刷新于 OLED 与手机端 |
| 数据无线上传至云平台 | ✅ 完全实现 | 通过 ESP8266 使用 MQTT 协议，每 3 秒向 OneNet 发送一次 JSON 数据包，包含所有传感器读数 |
| 超限声光报警 | ✅ 完全实现 | 本地通过蜂鸣器和 LED 报警；手机 APP 以图标形式显示扬尘或噪音超限状态，实现远程可视化提示 |
| 本地与远程阈值配置 | ✅ 基本实现 | 支持双向同步：本地 OLED 菜单可修改并保存阈值至 FLASH；手机端也可设置阈值并通过 OneNet 下发，设备接收后自动更新并在 OLED 显示 |
| 系统异常监控与故障恢复 | ✅ 实现 | 系统具备多级异常处理能力：(1) 主循环卡死时由独立看门狗触发复位；(2) 传感器或通信故障（如 PMS7003 连续无数据、MQTT 发送/接收失败）累计超限后，记录错误类型与时间至 FLASH 并复位；(3) 报警模块异常仅记录日志，不复位。所有历史错误可通过 OLED 菜单 “更多 → 错误日志” 查询。 |

> **总结**：项目已完整实现从数据采集、云端上传、跨端报警到异常自恢复的全链路功能，本地与远程交互基本同步，作为本科毕设原型系统，达到了功能验证与工程实践的双重目标。

### 性能指标

受限于个人条件，未使用专业级环境监测仪器进行标定，但通过**对比测试、逻辑验证与实地部署**，对系统关键性能进行了评估。

#### 1. 测量精度与响应特性

- **PM2.5 监测**  
  采用“点燃纸张”作为可控颗粒物源进行功能验证：  
  - 引入测试源后，PM2.5 浓度在数秒内从约 40 µg/m³ 快速上升至 **495 µg/m³**，触发本地 LED 报警；  
  - 移除测试源并自然通风后，数值逐步回落至 **44 µg/m³**，表明传感器对浓度变化**响应迅速、恢复稳定**。  
  > 虽无法提供绝对精度，但重复测试中趋势一致，符合 PMS7003 激光散射原理的预期行为。

- **噪音监测**  
  使用**标准声级计**（自购手持式分贝计）与系统并置测试：  
  - 在 220 Hz 正弦波稳定声源下，系统读数为 **75 dB(A)**，标准分贝计读数为 **74.3 dB(A)**，偏差仅 **0.7 dB**；  
  - 在工地实测中，远离施工区测得 **63 dB(A)**，靠近施工区测得 **88 dB(A)** 并成功触发报警，与现场感知一致。  
  > 结果表明 XM7903 在常见噪声范围内（`<90 dB`）具备良好线性度与实用性。

- **温湿度监测**  
  DHT11 仅用于环境辅助参考，未参与核心逻辑判断，其 ±2°C / ±5% RH 的典型误差在本项目中可接受。

#### 2. 系统响应时间

| 场景 | 响应延迟 | 说明 |
|------|--------|------|
| 环境突变 → OLED 更新 | ≤ 2 秒 | 如点燃纸张后，OLED 在 1–2 秒内显示 PM2.5 上升 |
| 本地采集 → OneNet 云端可见 | 3–4 秒 | 受限于 MQTT 每 3 秒发送一次的周期设计 |
| 超限 → 本地报警触发 | < 1 秒 | 阈值判断在主循环高频执行 |
| 手机端阈值修改 → 设备生效 | ≤ 3 秒 | OneNet 下行指令接收后立即更新，APP 因拉取机制存在界面刷新延迟 |

> 注：受限于个人条件，测试分别在宿舍阳台（PM2.5）、寝室（噪音）及工地围挡外（约30分钟实地运行）等非标准环境中进行。系统在此期间运行正常，未发生死机或通信中断，初步验证了其基础可靠性。

### 稳定性测试结果

本项目进行了**24小时连续运行测试**，并通过系统内置的**错误日志**机制统计异常复位情况。

#### 测试结果
- **总复位次数**：25次  
- **主要复位原因**：数据无法发送至 OneNet 云平台（占比 96%）  
- **平均恢复时间**：约 20–30 秒（从复位触发到重新连接 WiFi 并成功上传数据）

#### 分析与反思

**1. 复位主因是外部网络不稳定**  
测试期间使用手机热点作为网络源，其信号质量存在明显波动。日志分析显示，系统复位并非均匀分布：在网络较差时段，**10分钟内曾连续触发5次以上“数据无法发送”异常并导致复位**；而在网络相对稳定的时段，**可连续4–5小时无任何复位发生**。这表明复位行为高度依赖外部网络状态。由于系统将“MQTT 发送失败”视为影响核心功能的严重异常，一旦检测到通信失败即触发独立看门狗复位，以确保软硬件状态彻底重置，避免错误累积。

**2. 系统具备良好的自恢复能力**  
尽管复位频繁，但每次均能自动重新初始化网络、传感器及通信模块，并在30秒内恢复正常监测与数据上传。据此估算，**24小时内有效运行时间超过99%。**

**3. 当前策略的合理性与局限性**  
在资源受限（无 RTOS、内存紧张）的条件下，采用“异常即复位”是一种简单可靠的容错方案，可有效避免状态混乱或内存泄漏等更严重问题。  
但该策略对网络抖动过于敏感，**以短暂服务中断为代价换取系统确定性恢复**。

#### 不足及后续改进思路

当前系统在检测到数据连续`两次无法发送`至云平台后，会立即进入`3秒延时`（期间不再尝试发送），超时后因未喂狗而触发硬复位。该逻辑存在明显缺陷：**即使网络在延时期间恢复，系统也无法感知，仍会强制复位**，造成不必要的服务中断。

更合理的策略是引入**可撤销的故障确认机制**：
- 当连续两次发送失败时，置位 `network_failure_pending` 标志；
- 在定时器中断中检测该标志，若置位则启动3秒倒计时；
- **在此期间，若任一次数据发送成功，则清空标志并取消复位流程**；
- 仅当3秒内始终无法成功发送，才真正触发看门狗复位。

此方案在保留快速响应严重故障能力的同时，有效避免了对瞬时网络抖动的过度反应，可显著提升系统可用性。

#### 结论
在当前测试条件下，系统虽因外部网络问题导致短时间频繁复位，但**核心监测功能保持高可用，且具备可靠的自恢复能力**。作为本科毕设原型系统，已满足基本稳定性要求。

> 受限于当前测试环境，本项目完成了24小时连续运行验证。若未来具备更稳定的网络与供电条件，可进一步开展7×24小时老化测试，以全面评估长期可靠性。




## 开发过程与挑战

### 遇到的主要技术难题与应对思路

1. **多传感器异步采集与故障判别**  
   系统需同时驱动 PMS7003（UART+DMA）、XM7903（UART轮询）、DHT11（单总线）三种通信方式不同的传感器。  
   在裸机环境下，如何区分“偶发通信失败”和“真实硬件故障”是一大挑战——例如 XM7903 偶尔 CRC 校验失败会返回 `decibels=0`，但不应立即判定为故障。  
   **→ 解法**：引入“重试+超时”机制，对非关键传感器允许有限次失败；仅当连续异常且无法恢复时才记录错误，避免误判。


2. **Flash 空间逼近极限引发隐性崩溃**  
   STM32F103C8T6（64KB Flash）在低优化等级下程序体积达 63.87KB，导致复位后向量表加载异常，设备无法启动，且无明确报错。  
   **→ 解法**：强制启用 `-O3` 编译优化，将代码体积压缩至安全范围，并在注释中明确标注：“必须开启高优化，否则可能无法启动”。

3. **看门狗与错误处理过于激进**  
   原逻辑中，连续两次通信失败即触发 `Delay_s(3)` 并复位，即使后续能恢复也无法取消，造成不必要的服务中断。类似问题也存在于传感器异常处理中。  
   **→ 解法**：提出“可撤销故障确认”机制——置错误标志后启动 3 秒观察窗口，若期间恢复正常则取消复位。该方案已设计完成，具备落地条件。

### 未完成的尝试  
> 一个未竟的声学实验 🎧

曾尝试在资源极其有限的条件下——仅 STM32F103 开发板 + 低成本 LM386 麦克风模块，无专业仪器，亦无导师指导——通过裸机采集音频信号，结合 FFT 或时域算法，实现 A 计权声压级（dB(A)）的实时计算，目标是让读数接近标准分贝计。

过程中反复调试 ADC 采样、DMA 配置、频谱分析、RMS 与幅值计算，并多次尝试校准。  
虽在频率识别和能量估算上取得部分进展 ，但 **幅值精度与多频段校准始终无法稳定达标** 。

#### 🔍 根源可能不在代码，而在系统：  
> 硬件输入不可靠（频响不平、噪声干扰、无抗混叠滤波），  
> 软件受限于 MCU 算力（无 FPU、定点运算误差大）。

如今回看，这或许是我毕设中最“理想丰满、现实骨感”的一环 😅。  
我原以为是个算法问题，最终才明白——  
**这是一个横跨声学、模拟电路、信号处理与计量标准的系统工程，远超本科毕设的合理边界** 🧩。

而真正的收获，并非做出一个可用的声级计，  
而是 **学会了在局限中理性取舍，在失败中看清问题的全貌** 💡。

若未来的某天，  
我有了更扎实的信号处理基础、更好的测试设备，
或只是多了一点耐心 ⏳，
也许会回过头来，完成这份未竟的尝试——  
不为证明什么，  
只为兑现当初那个相信 **“自己能造出点什么”** 的年轻人的心愿 ❤️。

---

### 学习心得体会

这次毕设让我深刻体会到：**嵌入式开发的难点，往往不在“会不会写代码”，而在“如何在资源、时间与知识的多重约束下，做出合理判断”**。

面对**多传感器协同、Flash 空间告急、错误处理失控**等问题，我学会了不再追求“完美方案”，而是寻找“足够好且可维护”的平衡点——比如用软件**定时器模拟任务调度**，用**重试机制**替代硬复位，以及对引入的第三方 OLED UI 代码进行**深度裁剪**（移除未用功能、精简字体资源），再配合 `-O3` **编译优化**，才将程序体积从临界状态压缩至安全范围。这些不是妥协，而是在现实土壤中长出的工程智慧：真正的资源管理，既需要人对代码的理解与取舍，也离不开工具链的高效支持**。

而那个未能完成的声学实验，则教会我另一课：**有些问题，单靠热情和努力是不够的**。当硬件底座不稳、理论基础薄弱、验证手段缺失时，再精巧的算法也只是空中楼阁。这让我开始敬畏“系统性”——真正的可靠，来自软硬协同、校准闭环与对物理世界的尊重。

更重要的是，我不再害怕“未完成”。  
毕设不必是完美的作品，而应是一面镜子：照见自己的能力边界，也映出未来的成长方向。  
那些调试到凌晨的崩溃、反复推翻的逻辑、最终放弃的功能……它们没有消失，而是沉淀为一种**工程师的直觉**：知道什么该深挖，什么该绕行，什么值得等待更好的时机。

这条路还很长，但至少现在，我已能坦然地说：  
> “我知道自己能做什么，也知道暂时还做不到什么——而这，就是进步的起点。”



## 未来改进方向

### 当前存在的局限性

尽管系统已实现核心功能并具备基础稳定性，但在实际部署中仍存在若干关键局限：

- **网络依赖性强**：当前错误处理策略对 MQTT 通信失败过于敏感，导致在弱网环境下频繁复位，影响服务连续性；
- **硬件精度受限**：XM7903 虽能满足一般噪声趋势判断，但缺乏 A 计权滤波与专业校准，无法替代标准声级计；PMS7003 在高湿环境下易受干扰；
- **资源紧张制约功能扩展**：STM32F103C8T6 的 Flash 与 RAM 几乎耗尽，难以支持更复杂的协议（如 HTTPS）、OTA 升级或本地数据缓存；
- **人机交互较基础**：OLED 菜单为静态设计，缺乏动态反馈与多级配置能力。

### 可能的优化方案

针对上述问题，可从软硬件协同角度进行以下改进：

1. **增强网络容错能力**  
   落地已在文档中设计的“可撤销故障确认”机制：当通信失败时启动观察窗口，若期间恢复则取消复位，避免因瞬时网络抖动导致服务中断。

2. **引入低功耗与断网续传机制**  
   增加 SPI Flash 或利用内部 EEPROM 缓存未上传数据，在网络恢复后自动补发，提升数据完整性。

3. **升级主控平台**  
   迁移至 STM32F4 系列（带 FPU、更大 Flash/RAM），可支持：
   - 更高效的浮点运算（利于信号处理）；
   - FreeRTOS 实现任务隔离；
   - TLS 加密连接 OneNet，提升安全性。

4. **完善传感器校准流程**  
   设计简易校准模式：通过手机播放标准频率音源 + 标准分贝计读数，自动拟合各频段增益系数，提升噪声测量实用性。

### 扩展功能设想

若条件允许，系统可进一步演进为面向小微工地的轻量化环境监测节点：

- **多节点组网**：通过 LoRa 或 NB-IoT 实现多个监测点数据汇聚，构建局部环境热力图；
- **边缘智能预警**：基于历史数据训练简单阈值模型（如滑动平均+突变检测），减少误报；
- **太阳能供电 + IP54 防护外壳**：提升户外长期部署能力；
- **开放 API 接口**：供第三方平台（如智慧工地管理系统）接入数据。

> 毕设虽已结束，但这个项目对我而言并非终点，而是一个**可生长的技术原型**。  
> 它承载了我第一次完整走通“需求→设计→实现→验证→反思”全流程的全部印记。  
> 未来无论是否继续打磨它，这段经历都已教会我：**真正的工程，始于代码，成于取舍，终于敬畏**。

## <B2>[项目代码](https://github.com/Eureka12138github/My_UGP)</B2>



---
slug: /Issues
title: Issues Encountered
sidebar_position: 3
description: This page documents the problems encountered during the deployment of the documentation site and their solutions.
---

import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## <B2>Deployment Delay</B2>

This is what appears locally after running `yarn deploy`, showing `Done in ...`. But is the deployment really successful?

<p><CardImg src="/img/Issues/Deploy_Fake_Done.jpg" alt="Deployment not actually successful" isCenter={true} isBoxed={true} /></p>

Afterward, when visiting `https://eurekashadow.github.io/` or the domain `https://www.eurekashadow.xin/`, the following page appears:

<p><CardImg src="/img/Issues/After_Dploy.jpg" alt="There isn't a Git Pages site here." isCenter={true} isBoxed={true} /></p>

This might be because the free CI/CD resources (Runners) used by GitHub Actions are shared globally, and during <Highlight>peak usage periods</Highlight>, there may be <Highlight>queuing issues</Highlight>.
By checking the `Actions` tab in `GitHub`, you can see the deployment is in a queued state, so just wait patiently. After some time, the deployment will succeed:
<p><CardImg src="/img/Issues/Real_Deploy_Done.jpg" alt="Deployment actually successful" isCenter={true} isBoxed={true} /></p>

After further use, it was discovered that **after fixing the CNAME issue**, this so-called deployment delay problem no longer occurred. Perhaps it wasn‚Äôt due to <Highlight>peak usage periods</Highlight> at all‚Äîthe real culprit might have been the **incorrect CNAME.txt** file!

---

## <B2>About CNAME</B2>

While reading this [article](https://xxx.zhangyuqi.top/docs/MyWebsite/StudyBuildWebsite#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D), the author mentioned creating a blank `CNAME.txt` file in the `static` directory.

The issue I encountered was that every time the local deployment completed, the **custom domain would disappear** on GitHub's end, like this: (even though I had already entered the domain earlier)
<p><CardImg src="/img/Issues/domain_issue1.jpg" alt="Domain missing" isCenter={true} isBoxed={true} /></p>

<details>
<summary>Problem Analysis</summary>

Re-entering the domain:
<p><CardImg src="/img/Issues/domain_issue2.jpg" alt="Re-entering the domain" isCenter={true} isBoxed={true} /></p>

After entering the domain, GitHub Actions is triggered again:
<p><CardImg src="/img/Issues/deploy_done_in26s.jpg" alt="Deployment actually successful" isCenter={true} isBoxed={true} /></p>

At this point, when I checked the `git-pages` branch in the GitHub repository, I noticed it had generated a `CNAME` file (as shown below, with no file extension), containing my domain `www.eurekashadow.xin`.
I speculate that this `CNAME` file was automatically generated when re-adding the `Custom domain` on GitHub. So, was the previously mentioned `CNAME.txt` unnecessary? Or should the correct approach have been to create a `CNAME` file and add the domain `www.eurekashadow.xin` inside it?
<p><CardImg src="/img/Issues/About_CNAME1.jpg" alt="Is CNAME redundant?" isCenter={true} isBoxed={true} /></p>

Content of the `CNAME` file:
<p><CardImg src="/img/Issues/About_CNAME2.jpg" alt="Is CNAME redundant?" isCenter={true} isBoxed={true} /></p>

</details>

### <B3>CNAME Issue Conclusion</B3>

After testing, it was confirmed that `CNAME.txt` is indeed **redundant**! The correct approach is:

<details>
<summary>Create a **no-extension** CNAME file</summary>

<p><CardImg src="/img/Issues/Creat_CNAME1.jpg" alt="Step 1" isCenter={true} isBoxed={true} /></p>
<p><CardImg src="/img/Issues/Creat_CNAME2.jpg" alt="Step 2" isCenter={true} isBoxed={true} /></p>
<p><CardImg src="/img/Issues/Creat_CNAME3.jpg" alt="Step 3" isCenter={true} isBoxed={true} /></p>

</details>

Add your domain to the newly created `CNAME` file:
<p><CardImg src="/img/Issues/Modified_CNAME.jpg" alt="Adding the domain" isCenter={true} isBoxed={true} /></p>

After this, the deployment should proceed normally:

``` bash
yarn deploy
```


The domain names on Github will not be lost.Ôºö
<p><CardImg src="/img/Issues/CNAME_Issue_Fixed.jpg" alt="The CNAME issue has been resolved." isCenter={true} isBoxed={true} /></p>

---

## <B2>Highlighting conflicts with line numbers (not resolved)</B2>

This is my docusaurus.config.js configuration:

```js title="docusaurus.config.js"
prism: {
  // Code highlighting theme - Light theme uses GitHub style
  theme: prismThemes.github,
  // Code highlighting theme - Dark theme uses the Dracula style
  darkTheme: prismThemes.dracula,
  
  // Custom code highlighting configuration
  magicComments: [
	// Highlighting - Used to emphasize important code lines
	{
	  className: 'code-block-highlighted-line',  // CSS class name
	  line: 'highlight-next-line',               // Inline markup
	  block: { start: 'highlight-start', end: 'highlight-end' }  // Block tag
	},
	// New code marker - Used to identify newly added code lines
	{
	  className: 'code-block-add-line',
	  line: 'highlight-add-line',
	  block: { start: 'highlight-add-start', end: 'highlight-add-end' }
	},
	// Update code markers - Used to identify modified code lines
	{
	  className: 'code-block-update-line',
	  line: 'highlight-update-line',
	  block: { start: 'highlight-update-start', end: 'highlight-update-end' }
	},
	// Error code marker - Used to identify problematic code lines
	{
	  className: 'code-block-error-line',
	  line: 'highlight-error-line',
	  block: { start: 'highlight-error-start', end: 'highlight-error-end' }
	},
  ],
  
  // Additional supported languages (beyond the default list of supported languages)
  // Default supported language list reference:https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/generate-prism-languages/index.ts#L9-L23
  // Prism.js Complete list of supported languages:https://prismjs.com/#supported-languages
  additionalLanguages: [
	'java',   // Java programming language
	'json',   // JSON data format
	'c',
  ],
},
```

This is about the configuration of custom.css:
```css title="custom.css"
/* Style of the code highlighted lines */
.code-block-highlighted-line {
  background-color: rgba(255, 255, 0, 0.2); /* Yellow Highlight */
  display: block;
  margin: 0; /* Avoid layout issues */
  padding: 0 1em; /* Using em units is more flexible */
}

.code-block-add-line {
  background-color: rgba(0, 255, 0, 0.2); /* New Green Feature */
  display: block;
  margin: 0;
  padding: 0 1em;
}

.code-block-update-line {
  background-color: rgba(0, 0, 255, 0.2); /* Blue Update */
  display: block;
  margin: 0;
  padding: 0 1em;
}

.code-block-error-line {
  background-color: rgba(255, 0, 0, 0.2); /* Red Error */
  display: block;
  margin: 0;
  padding: 0 1em;
}

/* Styles for dark theme */
html[data-theme='dark'] .code-block-highlighted-line {
  background-color: rgba(255, 255, 0, 0.2);
}

html[data-theme='dark'] .code-block-add-line {
  background-color: rgba(0, 255, 0, 0.2);
}

html[data-theme='dark'] .code-block-update-line {
  background-color: rgba(0, 0, 255, 0.2);
}

html[data-theme='dark'] .code-block-error-line {
  background-color: rgba(255, 0, 0, 0.2);
}
```

This is the method of using both highlighting and line numbers:
```
\```c showLineNumbers
#include <stdio.h>

int main() {
    //Highlight the next line( highlight-next-line)
    printf("Hello, World!\n");
    
    //Highlighting begins( highlight-start)
    int x = 10;
    int y = 20;
    int sum = x + y;
    //Highlighting ends( highlight-end)
    
    return 0;
}
\```
```
This is an example of a conflict situation:
<p><CardImg src="/img/Issues/HighlightConflict.jpg" alt="The CNAME issue has been resolved." isCenter={true} isBoxed={true} /></p>

Highlighting and line numbers can be used **separately**, but using both together will cause **conflicts**. [Others](https://imroc.cc/note/docusaurus/codeblock#%E9%AB%98%E4%BA%AE%E5%A4%9A%E8%A1%8C/) can all use them normally. Why can't I? The reason has not been identified yet! 
The temporary compromise solution is to use the two separately. (20250919)

---

## <B2>üì¶ The excessive size of node_modules causes lag issues</B2>

### üéØ Problem Phenomenon 

Obvious performance issues were observed in the local development environment: 

- When the size of the `node_modules` folder becomes excessively large (reaching 17GB), the locally running website experiences severe lag.
- Navigation between pages is slow, usually taking more than 3 seconds to complete.
- The compilation time of the development server significantly increases.
- The overall development experience deteriorates, affecting work efficiency.

### üîß Issue resolved

Solve this Issue by cleaning the `node_modules` folder:

```bash title="bash"
npm install rimraf -g                           # Install the rimraf tool
rimraf node_modules                             # Delete "node_modules"
npm cache clean --force                         # clear cache
# npm config set registry https://registry.npmmirror.com/  # Use the new Taobao mirror (optional)
npm install                                     # Reinstall dependencies		
```		

### ‚ú® The effect after cleaning 
- The size of `node_modules` has been reduced from 17GB to approximately 200MB.
- The compilation speed of the project has significantly improved.
- Page transitions are completed almost instantly.
- The local development environment runs smoothly.

### üí° Why is cleaning safe? 
1. **Dependency Declaration Mechanism**
- All the actual dependencies used by the project are clearly recorded in the `package.json` file
- `node_modules` is merely the "instantiation" result of these declared dependencies
- When reinstalling, all the necessary dependencies will be restored according to the `package.json` file 
2. **Design Principles of npm/yarn**
- The package manager ensures that all the dependencies specified in the `package.json` file are correctly installed.
- It will not omit any explicitly declared dependencies during reinstallation.

### üìù Conclusion of the issue 
The excessive size of `node_modules` can significantly affect the performance of the local development environment. Regular cleaning is an effective method to maintain the efficient operation of the development environment. This issue is particularly prominent in large projects and should be carried out as a routine maintenance task. 
### ‚ö†Ô∏è Important Update (Further Observation) 
Further practice has revealed that the sluggishness of the development environment may have multiple causes: 
1. `node_modules` size issue (This section mainly discusses)
2. Docusaurus build cache issue (This might be **more important**) 
If merely cleaning the `node_modules` directory doesn't yield significant results, it is recommended to try clearing the Docusaurus build cache.

### üöÄ A truly effective solution

<Tabs>
  <TabItem value="yarn" label="yarn">
    ```bash
    yarn clear
    ```
  </TabItem>
  
  <TabItem value="npx" label="npx">
    ```bash
    npx docusaurus clear
    ```
  </TabItem>  
</Tabs>

This indicates that the sluggishness of the development environment is mainly caused by the build cache and the status of the development server, rather than the size of the node_modules. However, it is still necessary to regularly clean up unnecessary dependencies, which can effectively reduce disk space waste.

---

## <B2>The Issue of the build folder being too large</B2>

This problem had been lingering for a very long time, but finally it was resolved. I'm very relieved! ~ü•±

## Problem Description
The "build" folder, or more precisely, the six js files within it, are extremely large, each being approximately 20mb in size. This ultimately results in the build folder reaching a total size of 128mb. I asked the AI about it and it said this is a very abnormal situation. Even large-scale file servers' build folders usually do not reach this magnitude. 
## Solution Process
So I tried every possible way to "slim down" the build process. At first, I discovered that the `ForMDX.js` file imported large libraries that were not being used. At that moment, I almost thought the problem was solved. But when I checked the build attribute and it was still 128mb, it hit me like a ton of bricks. I was about to break down at that moment. 
It's already 2 o'clock in the morning. Ugh, haven‚Äôt watched Mortal‚Äôs Journey today. Curious about Han Li‚Äôs demonic psyche in this episode. Then, with the assistance of the AI, I gradually investigated but still couldn't find the problem. Later, an idea struck me, and I deleted the unused `src/components/FileBlock.tsx` and `src/theme/MDXComponents.tsx` files. The problem was solved! The build was successful and "thinned out", becoming around 13mb. 
## Current Status
At present, there is neither joy nor regret, just a sense of numbness. Let's deal with the further records of this issue tomorrow. For now, I am going to bed.

<details>
<summary>AI-generated question summary</summary>

## Problem Background
- **Observation**: The `build` folder abnormally grew to 128MB in size
- **After resolution**: After deleting two incomplete files, the `build` folder returned to a normal size of 13MB
- **Root cause**:
  - Kept `src/components/FileBlock.tsx`
  - Kept `src/theme/MDXComponents.tsx`
  - But didn't complete the `plugins` configuration in `docusaurus.config.js`

## Root Cause Analysis

### Primary Causes
1. **Circular dependency and improper imports**
   - FileBlock component used `require('!!raw-loader!@site/' + filepath)`
   - Dynamic imports caused webpack to attempt processing all project files

2. **MDX component circular references**
   - MDXComponents.tsx re-exported the CodeBlock component
   - Created confusion in component mapping

3. **Build tool misconfiguration**
   - Webpack failed to properly resolve dependencies
   - Numerous unnecessary files were bundled
   - Generated incorrect code-split chunks

## Problem Resolution Process

### Complete Issue Chain
```
Unfinished FileBlock component ‚Üí Dynamic raw-loader imports ‚Üí Webpack attempts to process all files ‚Üí 
Massive duplicate bundling ‚Üí Incorrect code splitting ‚Üí Oversized JS file generation ‚Üí 128MB build output
```


### Solution
After removing the two problematic files, webpack resumed normal operation:
1. Eliminated dynamic import source
2. Restored normal component mapping
3. Resolved build tool confusion

## Lessons Learned

### Key Development Practices
1. **Hidden Dangers of Unfinished Features**
   - Residual code can significantly impact the project even when inactive
   - Regularly clean up unused code files

2. **Risks of Dynamic Imports**
   - Exercise caution with dynamic paths like `require('!!raw-loader!@site/' + filepath)`
   - May trigger build tools to process all potential files

3. **Component Override Considerations**
   - Ensure default Docusaurus component overrides don't break existing dependencies

### Preventive Measures
- Regularly clean up unused code files
- Use separate branches for experimental features
- Periodically check dependencies of custom components
- Pay attention to proper theme component overrides

## Follow-up Recommendations

For reimplementing file import functionality:
1. Complete full plugin configuration, especially `exclude` rules
2. Limit file access scope using allowlist mechanism
3. Avoid fully dynamic paths - use more specific path patterns

## Conclusion
**The 13MB build size is normal**, confirming the issue is fully resolved. This case demonstrates that in frontend development, problems may originate from seemingly unrelated residual files, may originate from seemingly unrelated residual files, highlighting the importance of thorough cleanup of unfinished features.

</details>

## CardImg Component Image Click Freeze Issue

The original image component code was located in `ForMDX.js`, and was later migrated out to `CardImg.js`.

In `CardImg.js`, the following should be imported:
```
import { PhotoProvider, PhotoView } from 'react-photo-view';
import Lazyimg from 'react-lazyimg-component';
import 'react-photo-view/dist/react-photo-view.css';
```

In fact, it is lacking:
```
import 'react-photo-view/dist/react-photo-view.css';
```

Since `ForMDX.js` still kept those three imports, `CardImg.js` had an `implicit dependency` on `ForMDX.js`, making the image component work properly at that time.

Later while troubleshooting the oversized `build` folder issue, those three imports in `ForMDX.js` were found to be **redundant** and got removed. This broke the **implicit dependency**, causing the image component to stop working.

These implicit dependency issues can be nasty to debug. In this case, the image component could at least be refactored to restore functionality. But if faced with a situation where refactoring becomes extremely difficult or nearly impossible, tracking down such `implicit dependencies` would be **a nightmare!**

Got lucky this time - vaguely remembered the image component needed those three imports, so the fix was straightforward. Let this serve as a reminder: avoid creating such hidden dependencies in the first place. ü•±

---

## Resolving Vercel Preview Deployment Errors

### Problem Description
When deploying to the `gh-pages` branch of GitHub Pages using `yarn deploy`, Vercel automatically detects branch changes and attempts to create a Preview deployment. However, since the `gh-pages` branch only contains static files without a `package.json`, the build fails, showing a ‚ùåpreview error in GitHub Deployments.

### Root Cause
- Vercel by default creates Preview deployments for all branch pushes
- The `gh-pages` branch contains only built static files, lacking source code and build configuration
- Vercel fails when attempting to run `npm run build`

### Solution

**Configure Production Build:**
1. Go to Vercel project Settings ‚Üí Git
2. Under Behavior options, select **"Only build production"**
3. Ensure the production branch is set to `main` (or your primary branch)
4. Save settings






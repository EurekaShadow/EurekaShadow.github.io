---
slug: LearnGit
title: Git学习
authors: eurekaX
tags: [Git]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Git 使用技巧汇总
<!-- truncate -->

### 测试 git diff 功能

- `git diff`：查看**未暂存文件**与上次提交之间的差异。
- `git diff --staged`：查看**已暂存文件**与上次提交之间的差异。

✅ **一句话总结**：如果文件在**未暂存区**，使用 `git diff`；如果文件**已暂存**，使用 `git diff --staged`。

---

### 提交操作

- `git commit -a`：跳过 `git add` 阶段，一键暂存并提交所有修改。
- `git commit --amend`：撤销最近一次提交，并允许：
  - 使用 `git add` 补充遗漏的文件；
  - 编辑或保留原有的提交信息后重新提交。

🔁 适用于刚提交完发现还有文件没添加，或者需要修改提交信息的情况。

---

### 文件重命名操作

- `git mv <原文件名> <新文件名>`：用于重命名 Git 跟踪的文件。

示例：

```bash
git mv test1.txt test.txt
```

---

### 撤销暂存操作

- `git reset HEAD <文件名>`：取消某个文件的暂存状态。

示例：

```bash
git reset HEAD README.md
```

📌 常用于误将某些文件加入暂存区后想将其移出的情况。

---

### 放弃本地修改

- `git restore <文件名>`：放弃对该文件的所有本地修改。

⚠️ **注意**：该操作不可逆，请确保确实不需要这些修改后再执行。

---

## 分支切换与紧急修复流程

假设你现在正在解决问题53，当前处于 `iss53` 分支上，而 `main` 分支突然出现了问题，需要马上修复。

✅ **处理步骤如下**：

1. 切换回 `main` 分支：

   ```bash
   git switch main
   ```

2. 创建一个临时分支 `hotfix` 来修复问题：

   ```bash
   git checkout -b hotfix
   ```

3. 修复完成后，提交更改。

4. 切换回 `main` 分支并合并修复内容：

   ```bash
   git checkout main
   git merge hotfix
   ```

5. 删除临时分支（问题已修复）：

   ```bash
   git branch -d hotfix
   ```

6. 回到 `iss53` 分支继续开发：

   ```bash
   git switch iss53
   ```

---

## 合并冲突说明及解决方法

### ⚠️ 冲突原因

当 `main` 和 `iss53` 分支**同时修改了同一个文件的相同部分**（例如 `README.md`），Git 无法判断应该保留哪边的内容，就会提示冲突。

### 示例场景

- 在 `main` 分支下修改了 `README.md` 并提交；
- 然后切换到 `iss53` 分支，在此分支下也修改了 `README.md` 并提交；
- 最后切换回 `main` 分支，尝试合并 `iss53`，出现冲突。

---

### 🔧 解决步骤

1. 打开冲突文件（如 `README.md`），你会看到类似如下内容：

   ```html
   <<<<<<< HEAD
   This is the content from main.
   =======
   This is the content from iss53.
   >>>>>>> iss53
   ```

2. 手动编辑文件，选择你想要保留的内容，删除冲突标记。
3. 添加修改后的文件到暂存区：

   ```bash
   git add README.md
   ```

4. 提交合并结果：

   ```bash
   git commit -m "Fixed conflict"
   ```

---

### 💡 如何避免冲突？

- **保持分支同步**：在修改前先拉取最新代码；
- **及时合并分支**：避免两个分支长时间不合并；
- **明确分工**：团队协作时尽量避免多人修改同一文件的关键区域；
- **使用 Pull Request 审查机制**：提前发现潜在冲突。

---

## ✅ 实际测试说明

这是一个测试内容，当前文本是在 `iss53` 分支下编写完成的。之前已经与 `main` 分支合并。

按照预期，切换回 `main` 分支后，再合并 `iss53` 分支不会产生冲突，也就是说，在 `main` 分支下也能看到这段新增内容。

---

## 查看当前仓库的用户配置 😊

<Tabs>

  <TabItem value="global" label="全局">
```bash
git config --global user.name
git config --global user.email
```
  </TabItem>

  <TabItem value="local" label="本地">
```bash
git config user.name
git config user.email
```
  </TabItem>
 
</Tabs>

## 配置当前仓库的用户配置 🛠️

<Tabs>

  <TabItem value="global" label="全局">
```bash
git config --global user.name "GlobalAuthor"
git config --global user.email "global@example.com"
```
  </TabItem>

  <TabItem value="local" label="本地">
```bash
# 不加 --local 参数（默认就是局部配置）
git config user.name "LocalAuthor"
git config user.email "local@example.com"
```
  </TabItem>
 
</Tabs>

## 移除当前仓库的用户配置 🛠

<Tabs>

  <TabItem value="global" label="全局">
```bash
# 移除全局用户配置
git config --global --unset user.name
git config --global --unset user.email
```
  </TabItem>

  <TabItem value="local" label="本地">
```bash
# 移除本地用户配置
git config --unset user.name
git config --unset user.email
```
  </TabItem>
 
</Tabs>

## 切换作者推送代码 🔁
如果想要使用全局配置的作者信息进行推送，需要先删除局部（本地仓库）的作者配置。

1. 删除本地仓库的用户配置：
```bash
# 进入你的仓库目录
cd your-repository

# 删除本地的用户配置
git config --unset user.name
git config --unset user.email
```
2. 验证配置是否已删除：
```bash
# 查看当前仓库的用户配置（应该没有输出）
git config --local --list | grep user

# 查看生效的配置（应该显示全局配置）
git config --list | grep user
```
3. 确认使用的是全局配置：
```bash
# 查看当前生效的用户信息
git config user.name
git config user.email
```

4. 提交时的作者信息
删除本地配置后，新提交将使用全局配置的作者信息：
```bash
# 此时的提交将使用全局配置的作者
git commit -m "message"
```

## GitHub 身份识别机制总结 📚

### 核心原理 ⚡
- **提交作者识别**：基于 Git 提交中的 `user.name` 和 `user.email`
- **SSH 密钥作用**：仅用于认证访问权限，不决定提交作者

### 场景分析 🎭
**配置情况**：
- 全局作者：A
- 局部作者：B（本地仓库配置）
- SSH 密钥：A 的密钥
- 仓库权限：通过 A 的密钥访问 C 的仓库

**识别结果**：GitHub 显示推送者为 **B**（局部配置优先）

### 关键命令 🔑
```bash
# 查看当前身份配置
git config user.name
git config user.email

# 查看提交身份
git var GIT_AUTHOR_IDENT
git log --pretty=format:"%an <%ae>" -1
```
### 最终效果 🎯
- 提交作者：B（局部配置）
- 推送权限：A（SSH 密钥认证）
- 仓库所有者：C（实际仓库拥有者）

## 解决 Key is already in use 问题 💡

1. 为不同账户生成不同的密钥对
```bash
# 为用户A生成密钥
ssh-keygen -t rsa -b 4096 -C "userA@example.com" -f ~/.ssh/userA_key

# 为用户B生成密钥
ssh-keygen -t rsa -b 4096 -C "userB@example.com" -f ~/.ssh/userB_key
```

2. 配置 SSH 配置文件区分不同账户
创建/编辑 `~/.ssh/config` 文件：
```bash
# 用户A的配置
Host github-userA
    HostName github.com
    User git
    IdentityFile ~/.ssh/userA_key

# 用户B的配置
Host github-userB
    HostName github.com
    User git
    IdentityFile ~/.ssh/userB_key
```

3. 克隆和推送时使用不同 Host
```bash
# 克隆用户A的仓库
git clone git@github-userA:username/repo.git

# 克隆用户B的仓库
git clone git@github-userB:username/repo.git
```

4. 为现有仓库更改 remote URL
```
# 更改为用户A的配置
git remote set-url origin git@github-userA:username/repo.git

# 更改为用户B的配置
git remote set-url origin git@github-userB:username/repo.git
```

### 验证配置 ✅
```bash
# 测试连接用户A
ssh -T git@github-userA

# 测试连接用户B
ssh -T git@github-userB
```
这样就可以用不同的密钥管理不同账户的仓库访问权限。🎉

## 将本地新建分支推送到远端
```bash
git push -u origin your-branch-name
```







---
slug: LeetCode228
title: 汇总区间
authors: eurekaX
tags: [数组]
---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——228题](https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 返回恰好覆盖数组中所有数字的最小有序区间范围列表
 * 
 * @param nums 有序整数数组（无重复元素）
 * @param numsSize 数组长度
 * @param returnSize 返回数组的长度
 * @return 区间范围字符串数组
 */
char** summaryRanges(int* nums, int numsSize, int* returnSize) {
    // 处理空数组情况
    if (numsSize == 0) {
        *returnSize = 0;
        return NULL;
    }
    
    // 分配结果数组内存，最坏情况下每个元素都是独立区间
    char** result = (char**)malloc(numsSize * sizeof(char*));
    *returnSize = 0;
    
    // 使用双指针遍历数组
    int start = 0;  // 当前区间的起始位置
    for (int end = 0; end < numsSize; end++) {
        // 如果到达数组末尾或者下一个元素不连续，则形成一个区间
        if (end + 1 == numsSize || nums[end] + 1 != nums[end + 1]) {
            // 分配单个结果字符串内存
            result[*returnSize] = (char*)malloc(25 * sizeof(char)); // 足够存储两个int和"->"
            
            // 根据区间长度决定输出格式
            if (start == end) {
                // 单个元素区间
                sprintf(result[*returnSize], "%d", nums[start]);
            } else {
                // 多个元素区间
                sprintf(result[*returnSize], "%d->%d", nums[start], nums[end]);
            }
            
            (*returnSize)++;  // 结果计数增加
            start = end + 1;  // 更新下一个区间的起始位置
        }
    }
    
    return result;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 汇总区间

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：将有序整数数组中的连续数字合并为区间表示

📥 **输入输出**：
- **输入**：`nums` - 有序整数数组（无重复元素）, `numsSize` - 数组长度
- **输出**：返回区间范围字符串数组，每个区间按照"a->b"或"a"格式表示

---

## 2️⃣ 实现原理

💡 **核心思路**：使用双指针技术识别连续数字区间

📋 **实现步骤**：
1. 特殊情况处理：空数组直接返回
2. 使用双指针遍历数组，start标记区间起点，end寻找区间终点
3. 当发现不连续数字时，将当前区间添加到结果中
4. 根据区间长度决定输出格式

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 双指针法识别连续区间
- 利用`nums[end] + 1 != nums[end + 1]`判断连续性
- sprintf函数格式化字符串输出

## 4️⃣ 使用场景

### ✅ 适用情况：
- 数据压缩：将连续数据合并为区间表示
- 日志分析：将连续的时间戳或ID合并显示
- 数组可视化：简化大量连续数据的展示

### ⚠️ 前提条件：
- 输入数组必须有序
- 数组元素不能有重复

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，只需要遍历数组一次
- 💾 空间复杂度：O(1)，不考虑输出数组的话只使用常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 空数组
- 单元素数组
- 所有元素都是连续的情况

### 💥 易错点：
- 内存分配大小计算
- 区间边界判断条件
- 字符串格式化输出

## 7️⃣ 补充说明


以示例 `nums = [0,1,2,4,5,7]` 来逐步说明代码执行过程：

1. **初始化阶段**：
   - `result`：分配内存用于存储结果
   - `returnSize = 0`：结果计数器初始化
   - `start = 0`：第一个区间的起始位置

2. **第一次循环 (end=0)**：
   - 检查 `nums[0]+1 = 1` 是否等于 `nums[1] = 1` → 相等，继续

3. **第二次循环 (end=1)**：
   - 检查 `nums[1]+1 = 2` 是否等于 `nums[2] = 2` → 相等，继续

4. **第三次循环 (end=2)**：
   - 检查 `nums[2]+1 = 3` 是否等于 `nums[3] = 4` → 不相等，找到区间终点
   - 当前区间为 `[0,2]`，格式化为 `"0->2"`
   - `result[0] = "0->2"`，`returnSize = 1`
   - 更新 `start = 3`（下一个区间的起点）

5. **第四次循环 (end=3)**：
   - 检查 `nums[3]+1 = 5` 是否等于 `nums[4] = 5` → 相等，继续

6. **第五次循环 (end=4)**：
   - 检查 `nums[4]+1 = 6` 是否等于 `nums[5] = 7` → 不相等，找到区间终点
   - 当前区间为 `[3,4]`（即`[4,5]`），格式化为 `"4->5"`
   - `result[1] = "4->5"`，`returnSize = 2`
   - 更新 `start = 5`

7. **第六次循环 (end=5)**：
   - 已到达数组末尾
   - 当前区间为 `[5,5]`（即`[7,7]`），格式化为 `"7"`
   - `result[2] = "7"`，`returnSize = 3`

最终结果：`["0->2","4->5","7"]`
</details>

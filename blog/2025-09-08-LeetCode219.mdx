---
slug: LeetCode219
title: 存在重复元素Ⅱ
authors: eurekaX
tags: [数组,哈希表,滑动窗口]
---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——219题](https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 判断数组中是否存在两个不同的索引 i 和 j，
 * 满足 nums[i] == nums[j] 且 abs(i - j) <= k
 *
 * @param nums 整数数组
 * @param numsSize 数组长度
 * @param k 限制索引差值的整数
 * @return 如果存在满足条件的两个索引返回true，否则返回false
 */
bool containsNearbyDuplicate(int* nums, int numsSize, int k) {
    // 遍历数组中的每个元素
    for (int i = 0; i < numsSize; i++) {
        // 检查当前元素后面最多k个位置内的元素
        // 确保索引不越界，j从i+1开始到min(i+k+1, numsSize)
        for (int j = i + 1; j <= i + k && j < numsSize; j++) {
            // 如果找到相等的元素，且索引差值不超过k，则返回true
            if (nums[i] == nums[j]) {
                return true;
            }
        }
    }
    
    // 遍历完成后未找到满足条件的元素对，返回false
    return false;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 [存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/)

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：判断数组中是否存在两个不同的索引 i 和 j，满足 nums[i] == nums[j] 且 abs(i - j) <= k

📥 **输入输出**：
- **输入**：
  - `nums`: 整数数组
  - `k`: 限制索引差值的整数
- **输出**：如果存在满足条件的两个索引返回 true，否则返回 false

---

## 2️⃣ 实现原理

💡 **核心思路**：通过双重循环遍历数组，对于每个元素检查其后最多 k 个位置是否存在相同元素

📋 **实现步骤**：
1. 外层循环遍历数组中的每个元素
2. 内层循环检查当前元素后面最多 k 个位置的元素
3. 如果找到值相等的元素，直接返回 true
4. 遍历完成未找到满足条件的元素对，返回 false

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用双重循环控制索引范围，内层循环上限为 `i+k` 和 `numsSize-1` 的较小值
- 利用短路求值避免数组越界访问
- 通过限制内层循环范围优化不必要的比较

## 4️⃣ 使用场景

### ✅ 适用情况：
- 在固定窗口大小内查找重复元素
- 数组去重检查且允许特定距离内的重复
- 滑动窗口相关问题

### ⚠️ 前提条件：
- 数组长度大于等于1
- k值非负

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n×min(k,n))，其中 n 是数组长度，最坏情况下需要对每个元素检查最多 k 个后续元素

- 💾 空间复杂度：O(1)，只使用了常数额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组只有一个元素
- k值为0的情况
- k值大于等于数组长度的情况

### 💥 易错点：
- 忘记检查数组边界导致越界访问
- 误解题意，没有正确理解 abs(i-j) <= k 的含义
- 循环条件设置错误，可能导致遗漏或重复比较

## 7️⃣ 补充说明

**输入**: `nums = [1,0,1,1]`, `k = 1`

1. **i = 0** (`nums[0] = 1`):
   - 内层循环 j 从 1 到 min(0+1, 3) = 1
   - `j = 1`: `nums[1] = 0`, `1 != 0`, 继续
   - 无匹配

2. **i = 1** (`nums[1] = 0`):
   - 内层循环 j 从 2 到 min(1+1, 3) = 2
   - `j = 2`: `nums[2] = 1`, `0 != 1`, 继续
   - 无匹配

3. **i = 2** (`nums[2] = 1`):
   - 内层循环 j 从 3 到 min(2+1, 3) = 3
   - `j = 3`: `nums[3] = 1`, `1 == 1`, 找到匹配!
   - 检查索引差值: `|2-3| = 1 <= 1` ✓
   - 返回 `true`

这个例子中，索引 2 和 3 处的元素都为 1，且它们的索引差值为 1，不大于 k=1，因此函数返回 true。
</details>

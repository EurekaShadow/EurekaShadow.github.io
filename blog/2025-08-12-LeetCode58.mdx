---
slug: LeetCode58
title: 最后一个单词的长度
authors: eurekaX
tags: [字符串]
---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——58题](https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 返回字符串中最后一个单词的长度
 * @param s 输入字符串，由若干单词组成，单词前后用空格隔开
 * @return 最后一个单词的长度
 */
int lengthOfLastWord(char* s) {
    // 从字符串末尾开始向前遍历，跳过尾部空格
    int end = strlen(s) - 1;
    while (end >= 0 && s[end] == ' ') {
        end--;
    }
    
    // 从最后一个非空格字符开始，向前计算单词长度
    int length = 0;
    while (end >= 0 && s[end] != ' ') {
        length++;
        end--;
    }
    
    // 返回最后一个单词的长度
    return length;
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 Length of Last Word

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定一个由若干单词组成的字符串，单词之间用空格分隔，返回最后一个单词的长度。

📥 **输入输出**：
- **输入**：char* s - 一个由英文字母和空格组成的字符串
- **输出**：int - 字符串中最后一个单词的长度

---

## 2️⃣ 实现原理

💡 **核心思路**：采用反向遍历的方法，从字符串末尾开始查找，跳过尾部空格后统计最后一个单词的字符个数。

📋 **实现步骤**：
1. 获取字符串长度，从末尾开始遍历
2. 跳过字符串尾部的所有空格字符
3. 从最后一个非空格字符开始向前统计，直到遇到空格或到达字符串开头
4. 返回统计的字符个数作为最后一个单词的长度

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 反向遍历：避免处理前导空格，直接定位到最后一个单词
- 双指针思想：一个指针用于跳过空格，另一个用于统计单词长度
- 边界处理：正确处理字符串末尾的空格和字符串边界

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要获取文本中最后一个单词的相关信息
- 文本处理中需要分析单词结构
- 字符串解析操作

### ⚠️ 前提条件：
- 输入字符串至少包含一个单词
- 单词仅由英文字母组成，单词之间用空格分隔

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n)，其中n是字符串的长度，最坏情况下需要遍历整个字符串

- 💾 空间复杂度：O(1)，只使用了常数级别的额外空间

## 6️⃣ 注意事项

### 🚩 边界情况：
- 字符串末尾有多个空格
- 字符串只有一个单词
- 字符串开头有多个空格

### 💥 易错点：
- 忘记处理字符串末尾的空格
- 边界条件判断错误，可能导致数组越界
- 混淆单词长度计算的起止位置

## 7⃣ 补充说明

示例: "Hello World"
```
字符串: "Hello World"
索引:    01234567890

步骤:
1. end = 10 (指向 '\0' 前的字符 'd')
2. 跳过空格: 无尾部空格，end 保持为 10
3. 计算单词长度:
   - 'd'(10) -> length=1, end=9
   - 'l'(9)  -> length=2, end=8
   - 'r'(8)  -> length=3, end=7
   - 'o'(7)  -> length=4, end=6
   - 'W'(6)  -> length=5, end=5
   - ' '(5)  -> 遇到空格，停止
4. 返回 length = 5
```
</details>

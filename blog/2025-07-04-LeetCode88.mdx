---
slug: LeetCode88
title: 合并两个有序数组
authors: eurekaX
tags: [数组]
---

### 力扣面试经典——88题

<!-- truncate -->

给你两个按**非递减顺序**排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n`，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你合并 `nums2` 到 `nums1` 中，使合并后的数组同样按**非递减顺序**排列。

> ⚠️ 注意：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0`，应忽略。`nums2` 的长度为 `n`。

---

### 🧪 示例说明

#### 示例 1：
> 输入：  
> `nums1 = [1, 2, 3, 0, 0, 0]`, `m = 3`  
> `nums2 = [2, 5, 6]`, `n = 3`  
>
> 输出：  
> `[1, 2, 2, 3, 5, 6]`  
>
> 解释：需要合并 `[1,2,3]` 和 `[2,5,6]`。  
> 合并结果是 `[1, 2, 2, 3, 5, 6]`，其中斜体加粗标注的为 `nums1` 中的原始元素。

#### 示例 2：
> 输入：  
> `nums1 = [1]`, `m = 1`  
> `nums2 = []`, `n = 0`  
>
> 输出：  
> `[1]`

#### 示例 3：
> 输入：  
> `nums1 = [0]`, `m = 0`  
> `nums2 = [1]`, `n = 1`  
>
> 输出：  
> `[1]`  
>
> 解释：因为 `m = 0`，所以 `nums1` 中没有有效元素。`0` 只是为了确保合并结果可以顺利存放到 `nums1` 中。

---

### 🔍 提示：

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `-10^9 <= nums1[i], nums2[j] <= 10^9`

---

### 🚀 进阶挑战：

你可以设计实现一个时间复杂度为 `O(m + n)` 的算法解决此问题吗？

---

### 💡 推荐阅读：

如果你正在开发文档站点（如 Docusaurus），也可以考虑将代码片段封装到 `<details>` 标签中，避免页面过于冗长：

<details>
<summary>点击展开 C 语言参考答案</summary>

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n) {
    int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }

    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}
```

</details>
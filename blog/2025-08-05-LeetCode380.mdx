---
slug: LeetCode380
title: O(1)时间插入、删除和获取随机元素

authors: eurekaX
tags: [数组]
---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[力扣面试经典——380题](https://leetcode.cn/problems/insert-delete-getrandom-o1/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * 哈希表节点结构体
 * 用于存储元素值和其在数组中的索引位置
 */
typedef struct {
    int value;              // 元素值
    int index;              // 该元素在数组中的索引位置
    UT_hash_handle hh;      // uthash库所需的句柄
} HashItem;

/**
 * RandomizedSet结构体
 * 组合数组和哈希表实现O(1)时间复杂度的插入、删除和随机获取操作
 */
typedef struct {
    int* nums;              // 存储实际元素的数组
    int numsSize;           // 当前数组中元素的个数
    HashItem* indices;      // 哈希表，存储元素值到索引的映射
} RandomizedSet;

/**
 * 创建RandomizedSet对象
 * @return 新创建的RandomizedSet对象指针
 */
RandomizedSet* randomizedSetCreate() {
    srand(time(NULL)); // 初始化随机数种子
    RandomizedSet* obj = (RandomizedSet*)malloc(sizeof(RandomizedSet));
    obj->nums = (int*)malloc(sizeof(int) * 200000); // 预分配足够空间
    obj->numsSize = 0;                              // 初始元素个数为0
    obj->indices = NULL;                            // 哈希表初始为空
    return obj;
}

/**
 * 向集合中插入元素
 * @param obj RandomizedSet对象指针
 * @param val 要插入的元素值
 * @return 插入成功返回true，元素已存在返回false
 */
bool randomizedSetInsert(RandomizedSet* obj, int val) {
    HashItem* tmp = NULL;
    // 在哈希表中查找元素是否已存在
    HASH_FIND_INT(obj->indices, &val, tmp);
    if (tmp != NULL) {
        return false; // 元素已存在，插入失败
    }
    
    // 将新元素添加到数组末尾
    obj->nums[obj->numsSize] = val;
    
    // 在哈希表中创建新节点，记录元素值和其在数组中的索引
    tmp = (HashItem*)malloc(sizeof(HashItem));
    tmp->value = val;
    tmp->index = obj->numsSize;
    HASH_ADD_INT(obj->indices, value, tmp);
    
    obj->numsSize++; // 数组元素个数增加
    return true;
}

/**
 * 从集合中删除元素
 * @param obj RandomizedSet对象指针
 * @param val 要删除的元素值
 * @return 删除成功返回true，元素不存在返回false
 */
bool randomizedSetRemove(RandomizedSet* obj, int val) {
    HashItem* tmp = NULL;
    // 在哈希表中查找要删除的元素
    HASH_FIND_INT(obj->indices, &val, tmp);
    if (tmp == NULL) {
        return false; // 元素不存在，删除失败
    }
    
    // 获取要删除元素在数组中的索引位置
    int index = tmp->index;
    
    // 获取数组中最后一个元素的值
    int lastValue = obj->nums[obj->numsSize - 1];
    // 将最后一个元素移动到要删除元素的位置（覆盖要删除的元素）
    obj->nums[index] = lastValue;
    
    // 更新最后一个元素在哈希表中的索引位置
    HashItem* lastItem = NULL;
    HASH_FIND_INT(obj->indices, &lastValue, lastItem);
    if (lastItem != NULL) {
        lastItem->index = index;
    }
    
    // 从哈希表中删除目标元素节点并释放内存
    HASH_DEL(obj->indices, tmp);
    free(tmp);
    
    obj->numsSize--; // 数组元素个数减少
    return true;
}

/**
 * 随机获取集合中的一个元素
 * @param obj RandomizedSet对象指针
 * @return 随机返回的元素值
 */
int randomizedSetGetRandom(RandomizedSet* obj) {
    // 使用随机数生成0到numsSize-1之间的索引
    int randomIndex = rand() % obj->numsSize;
    return obj->nums[randomIndex]; // 返回数组中对应位置的元素
}

/**
 * 释放RandomizedSet对象占用的内存
 * @param obj RandomizedSet对象指针
 */
void randomizedSetFree(RandomizedSet* obj) {
    // 遍历并释放哈希表中所有的节点内存
    HashItem* curr, *tmp;
    HASH_ITER(hh, obj->indices, curr, tmp) {
        HASH_DEL(obj->indices, curr);
        free(curr);
    }
    
    // 释放数组内存和对象本身内存
    free(obj->nums);
    free(obj);
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 O(1)时间插入、删除和获取随机元素

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：设计一个支持在平均O(1)时间复杂度下进行插入、删除和获取随机元素的数据结构

📥 **输入输出**：
- **输入**：
  - `val`：要插入或删除的整数值
  - 无参数：用于获取随机元素
- **输出**：
  - `insert`：插入成功返回true，失败返回false
  - `remove`：删除成功返回true，失败返回false
  - `getRandom`：返回集合中的任意一个元素
  - `create`：返回初始化的RandomizedSet对象
  - `free`：释放对象内存，无返回值

---

## 2️⃣ 实现原理

💡 **核心思路**：使用数组存储元素以支持O(1)随机访问，结合哈希表记录元素值到索引的映射以支持O(1)查找

📋 **实现步骤**：
1. 使用动态数组存储所有元素，支持通过索引O(1)访问任意元素
2. 使用哈希表维护元素值到数组索引的映射关系，支持O(1)查找元素
3. 插入时将元素添加到数组末尾并在哈希表中记录索引
4. 删除时将目标元素与数组末尾元素交换，更新哈希表并删除目标元素

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- **数组+哈希表组合**：数组支持随机访问，哈希表支持快速查找
- **删除元素时的交换技巧**：将待删除元素与末尾元素交换，避免数组元素移动
- **双重数据结构同步维护**：同时维护数组和哈希表中元素信息的一致性

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要频繁进行插入、删除和随机访问操作的场景
- 对时间复杂度要求严格的随机集合应用
- 实现随机抽样或随机化算法的数据结构

### ⚠️ 前提条件：
- 元素值唯一，不支持重复元素
- 需要足够的内存空间维护数组和哈希表
- getRandom调用时集合必须非空

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：
  - insert: O(1) 平均时间复杂度
  - remove: O(1) 平均时间复杂度
  - getRandom: O(1) 时间复杂度
  - create: O(1) 时间复杂度
  - free: O(n) 时间复杂度，n为元素个数

- 💾 空间复杂度：O(n)，n为存储的元素个数，需要数组和哈希表存储

## 6️⃣ 注意事项

### 🚩 边界情况：
- 插入已存在的元素
- 删除不存在的元素
- 集合为空时调用getRandom（题目保证不会出现）
- 集合只有一个元素时的删除操作

### 💥 易错点：
- 删除元素后忘记更新交换元素在哈希表中的索引
- 内存释放不完整，忘记释放哈希表节点
- getRandom实现中随机数范围错误，应为[0, numsSize)

## 7️⃣ 惑之未解

这是力扣里面的最优解？但是我看不懂~😂

我现在打算先理解灵码给出的代码吧，之后再来探索下面的内容！🧐
暂时将下面代码全部删除，现在正在排查build文件夹过大的问题（发现不是这里的代码块导致的问题，日后可恢复！！！）
</details>

## <B2>[补充解释](/blog/LeetCode380plus)</B2>

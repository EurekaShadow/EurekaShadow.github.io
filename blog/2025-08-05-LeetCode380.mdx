---
slug: LeetCode380
title: O(1)æ—¶é—´æ’å…¥ã€åˆ é™¤å’Œè·å–éšæœºå…ƒç´ 

authors: eurekaX
tags: [æ•°ç»„]
---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';


### <B2>[åŠ›æ‰£é¢è¯•ç»å…¸â€”â€”380é¢˜](https://leetcode.cn/problems/insert-delete-getrandom-o1/?envType=study-plan-v2&envId=top-interview-150 "åŠ›æ‰£")</B2>

<!-- truncate -->


### ğŸ’¡ å‚è€ƒä»£ç ï¼š

```c
/**
 * å“ˆå¸Œè¡¨èŠ‚ç‚¹ç»“æ„ä½“
 * ç”¨äºå­˜å‚¨å…ƒç´ å€¼å’Œå…¶åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ä½ç½®
 */
typedef struct {
    int value;              // å…ƒç´ å€¼
    int index;              // è¯¥å…ƒç´ åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ä½ç½®
    UT_hash_handle hh;      // uthashåº“æ‰€éœ€çš„å¥æŸ„
} HashItem;

/**
 * RandomizedSetç»“æ„ä½“
 * ç»„åˆæ•°ç»„å’Œå“ˆå¸Œè¡¨å®ç°O(1)æ—¶é—´å¤æ‚åº¦çš„æ’å…¥ã€åˆ é™¤å’Œéšæœºè·å–æ“ä½œ
 */
typedef struct {
    int* nums;              // å­˜å‚¨å®é™…å…ƒç´ çš„æ•°ç»„
    int numsSize;           // å½“å‰æ•°ç»„ä¸­å…ƒç´ çš„ä¸ªæ•°
    HashItem* indices;      // å“ˆå¸Œè¡¨ï¼Œå­˜å‚¨å…ƒç´ å€¼åˆ°ç´¢å¼•çš„æ˜ å°„
} RandomizedSet;

/**
 * åˆ›å»ºRandomizedSetå¯¹è±¡
 * @return æ–°åˆ›å»ºçš„RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 */
RandomizedSet* randomizedSetCreate() {
    srand(time(NULL)); // åˆå§‹åŒ–éšæœºæ•°ç§å­
    RandomizedSet* obj = (RandomizedSet*)malloc(sizeof(RandomizedSet));
    obj->nums = (int*)malloc(sizeof(int) * 200000); // é¢„åˆ†é…è¶³å¤Ÿç©ºé—´
    obj->numsSize = 0;                              // åˆå§‹å…ƒç´ ä¸ªæ•°ä¸º0
    obj->indices = NULL;                            // å“ˆå¸Œè¡¨åˆå§‹ä¸ºç©º
    return obj;
}

/**
 * å‘é›†åˆä¸­æ’å…¥å…ƒç´ 
 * @param obj RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 * @param val è¦æ’å…¥çš„å…ƒç´ å€¼
 * @return æ’å…¥æˆåŠŸè¿”å›trueï¼Œå…ƒç´ å·²å­˜åœ¨è¿”å›false
 */
bool randomizedSetInsert(RandomizedSet* obj, int val) {
    HashItem* tmp = NULL;
    // åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾å…ƒç´ æ˜¯å¦å·²å­˜åœ¨
    HASH_FIND_INT(obj->indices, &val, tmp);
    if (tmp != NULL) {
        return false; // å…ƒç´ å·²å­˜åœ¨ï¼Œæ’å…¥å¤±è´¥
    }
    
    // å°†æ–°å…ƒç´ æ·»åŠ åˆ°æ•°ç»„æœ«å°¾
    obj->nums[obj->numsSize] = val;
    
    // åœ¨å“ˆå¸Œè¡¨ä¸­åˆ›å»ºæ–°èŠ‚ç‚¹ï¼Œè®°å½•å…ƒç´ å€¼å’Œå…¶åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•
    tmp = (HashItem*)malloc(sizeof(HashItem));
    tmp->value = val;
    tmp->index = obj->numsSize;
    HASH_ADD_INT(obj->indices, value, tmp);
    
    obj->numsSize++; // æ•°ç»„å…ƒç´ ä¸ªæ•°å¢åŠ 
    return true;
}

/**
 * ä»é›†åˆä¸­åˆ é™¤å…ƒç´ 
 * @param obj RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 * @param val è¦åˆ é™¤çš„å…ƒç´ å€¼
 * @return åˆ é™¤æˆåŠŸè¿”å›trueï¼Œå…ƒç´ ä¸å­˜åœ¨è¿”å›false
 */
bool randomizedSetRemove(RandomizedSet* obj, int val) {
    HashItem* tmp = NULL;
    // åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾è¦åˆ é™¤çš„å…ƒç´ 
    HASH_FIND_INT(obj->indices, &val, tmp);
    if (tmp == NULL) {
        return false; // å…ƒç´ ä¸å­˜åœ¨ï¼Œåˆ é™¤å¤±è´¥
    }
    
    // è·å–è¦åˆ é™¤å…ƒç´ åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ä½ç½®
    int index = tmp->index;
    
    // è·å–æ•°ç»„ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å€¼
    int lastValue = obj->nums[obj->numsSize - 1];
    // å°†æœ€åä¸€ä¸ªå…ƒç´ ç§»åŠ¨åˆ°è¦åˆ é™¤å…ƒç´ çš„ä½ç½®ï¼ˆè¦†ç›–è¦åˆ é™¤çš„å…ƒç´ ï¼‰
    obj->nums[index] = lastValue;
    
    // æ›´æ–°æœ€åä¸€ä¸ªå…ƒç´ åœ¨å“ˆå¸Œè¡¨ä¸­çš„ç´¢å¼•ä½ç½®
    HashItem* lastItem = NULL;
    HASH_FIND_INT(obj->indices, &lastValue, lastItem);
    if (lastItem != NULL) {
        lastItem->index = index;
    }
    
    // ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ç›®æ ‡å…ƒç´ èŠ‚ç‚¹å¹¶é‡Šæ”¾å†…å­˜
    HASH_DEL(obj->indices, tmp);
    free(tmp);
    
    obj->numsSize--; // æ•°ç»„å…ƒç´ ä¸ªæ•°å‡å°‘
    return true;
}

/**
 * éšæœºè·å–é›†åˆä¸­çš„ä¸€ä¸ªå…ƒç´ 
 * @param obj RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 * @return éšæœºè¿”å›çš„å…ƒç´ å€¼
 */
int randomizedSetGetRandom(RandomizedSet* obj) {
    // ä½¿ç”¨éšæœºæ•°ç”Ÿæˆ0åˆ°numsSize-1ä¹‹é—´çš„ç´¢å¼•
    int randomIndex = rand() % obj->numsSize;
    return obj->nums[randomIndex]; // è¿”å›æ•°ç»„ä¸­å¯¹åº”ä½ç½®çš„å…ƒç´ 
}

/**
 * é‡Šæ”¾RandomizedSetå¯¹è±¡å ç”¨çš„å†…å­˜
 * @param obj RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 */
void randomizedSetFree(RandomizedSet* obj) {
    // éå†å¹¶é‡Šæ”¾å“ˆå¸Œè¡¨ä¸­æ‰€æœ‰çš„èŠ‚ç‚¹å†…å­˜
    HashItem* curr, *tmp;
    HASH_ITER(hh, obj->indices, curr, tmp) {
        HASH_DEL(obj->indices, curr);
        free(curr);
    }
    
    // é‡Šæ”¾æ•°ç»„å†…å­˜å’Œå¯¹è±¡æœ¬èº«å†…å­˜
    free(obj->nums);
    free(obj);
}
```

### ğŸ“– æ€»ç»“ï¼š

<details>
<summary>ç‚¹å‡»å±•å¼€é¢˜ç›®æ€»ç»“</summary>
# ğŸ¤” O(1)æ—¶é—´æ’å…¥ã€åˆ é™¤å’Œè·å–éšæœºå…ƒç´ 

---

## 1ï¸âƒ£ é¢˜ç›®æ ¸å¿ƒä¿¡æ¯

ğŸ¯ **åŠŸèƒ½æè¿°**ï¼šè®¾è®¡ä¸€ä¸ªæ”¯æŒåœ¨å¹³å‡O(1)æ—¶é—´å¤æ‚åº¦ä¸‹è¿›è¡Œæ’å…¥ã€åˆ é™¤å’Œè·å–éšæœºå…ƒç´ çš„æ•°æ®ç»“æ„

ğŸ“¥ **è¾“å…¥è¾“å‡º**ï¼š
- **è¾“å…¥**ï¼š
  - `val`ï¼šè¦æ’å…¥æˆ–åˆ é™¤çš„æ•´æ•°å€¼
  - æ— å‚æ•°ï¼šç”¨äºè·å–éšæœºå…ƒç´ 
- **è¾“å‡º**ï¼š
  - `insert`ï¼šæ’å…¥æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false
  - `remove`ï¼šåˆ é™¤æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false
  - `getRandom`ï¼šè¿”å›é›†åˆä¸­çš„ä»»æ„ä¸€ä¸ªå…ƒç´ 
  - `create`ï¼šè¿”å›åˆå§‹åŒ–çš„RandomizedSetå¯¹è±¡
  - `free`ï¼šé‡Šæ”¾å¯¹è±¡å†…å­˜ï¼Œæ— è¿”å›å€¼

---

## 2ï¸âƒ£ å®ç°åŸç†

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**ï¼šä½¿ç”¨æ•°ç»„å­˜å‚¨å…ƒç´ ä»¥æ”¯æŒO(1)éšæœºè®¿é—®ï¼Œç»“åˆå“ˆå¸Œè¡¨è®°å½•å…ƒç´ å€¼åˆ°ç´¢å¼•çš„æ˜ å°„ä»¥æ”¯æŒO(1)æŸ¥æ‰¾

ğŸ“‹ **å®ç°æ­¥éª¤**ï¼š
1. ä½¿ç”¨åŠ¨æ€æ•°ç»„å­˜å‚¨æ‰€æœ‰å…ƒç´ ï¼Œæ”¯æŒé€šè¿‡ç´¢å¼•O(1)è®¿é—®ä»»æ„å…ƒç´ 
2. ä½¿ç”¨å“ˆå¸Œè¡¨ç»´æŠ¤å…ƒç´ å€¼åˆ°æ•°ç»„ç´¢å¼•çš„æ˜ å°„å…³ç³»ï¼Œæ”¯æŒO(1)æŸ¥æ‰¾å…ƒç´ 
3. æ’å…¥æ—¶å°†å…ƒç´ æ·»åŠ åˆ°æ•°ç»„æœ«å°¾å¹¶åœ¨å“ˆå¸Œè¡¨ä¸­è®°å½•ç´¢å¼•
4. åˆ é™¤æ—¶å°†ç›®æ ‡å…ƒç´ ä¸æ•°ç»„æœ«å°¾å…ƒç´ äº¤æ¢ï¼Œæ›´æ–°å“ˆå¸Œè¡¨å¹¶åˆ é™¤ç›®æ ‡å…ƒç´ 

---

## 3ï¸âƒ£ å…³é”®ç‚¹è§£æ

### ğŸ¯ ä»£ç æŠ€å·§
- **æ•°ç»„+å“ˆå¸Œè¡¨ç»„åˆ**ï¼šæ•°ç»„æ”¯æŒéšæœºè®¿é—®ï¼Œå“ˆå¸Œè¡¨æ”¯æŒå¿«é€ŸæŸ¥æ‰¾
- **åˆ é™¤å…ƒç´ æ—¶çš„äº¤æ¢æŠ€å·§**ï¼šå°†å¾…åˆ é™¤å…ƒç´ ä¸æœ«å°¾å…ƒç´ äº¤æ¢ï¼Œé¿å…æ•°ç»„å…ƒç´ ç§»åŠ¨
- **åŒé‡æ•°æ®ç»“æ„åŒæ­¥ç»´æŠ¤**ï¼šåŒæ—¶ç»´æŠ¤æ•°ç»„å’Œå“ˆå¸Œè¡¨ä¸­å…ƒç´ ä¿¡æ¯çš„ä¸€è‡´æ€§

## 4ï¸âƒ£ ä½¿ç”¨åœºæ™¯

### âœ… é€‚ç”¨æƒ…å†µï¼š
- éœ€è¦é¢‘ç¹è¿›è¡Œæ’å…¥ã€åˆ é™¤å’Œéšæœºè®¿é—®æ“ä½œçš„åœºæ™¯
- å¯¹æ—¶é—´å¤æ‚åº¦è¦æ±‚ä¸¥æ ¼çš„éšæœºé›†åˆåº”ç”¨
- å®ç°éšæœºæŠ½æ ·æˆ–éšæœºåŒ–ç®—æ³•çš„æ•°æ®ç»“æ„

### âš ï¸ å‰ææ¡ä»¶ï¼š
- å…ƒç´ å€¼å”¯ä¸€ï¼Œä¸æ”¯æŒé‡å¤å…ƒç´ 
- éœ€è¦è¶³å¤Ÿçš„å†…å­˜ç©ºé—´ç»´æŠ¤æ•°ç»„å’Œå“ˆå¸Œè¡¨
- getRandomè°ƒç”¨æ—¶é›†åˆå¿…é¡»éç©º

## 5ï¸âƒ£ å¤æ‚åº¦åˆ†æ

- â±ï¸ æ—¶é—´å¤æ‚åº¦ï¼š
  - insert: O(1) å¹³å‡æ—¶é—´å¤æ‚åº¦
  - remove: O(1) å¹³å‡æ—¶é—´å¤æ‚åº¦
  - getRandom: O(1) æ—¶é—´å¤æ‚åº¦
  - create: O(1) æ—¶é—´å¤æ‚åº¦
  - free: O(n) æ—¶é—´å¤æ‚åº¦ï¼Œnä¸ºå…ƒç´ ä¸ªæ•°

- ğŸ’¾ ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œnä¸ºå­˜å‚¨çš„å…ƒç´ ä¸ªæ•°ï¼Œéœ€è¦æ•°ç»„å’Œå“ˆå¸Œè¡¨å­˜å‚¨

## 6ï¸âƒ£ æ³¨æ„äº‹é¡¹

### ğŸš© è¾¹ç•Œæƒ…å†µï¼š
- æ’å…¥å·²å­˜åœ¨çš„å…ƒç´ 
- åˆ é™¤ä¸å­˜åœ¨çš„å…ƒç´ 
- é›†åˆä¸ºç©ºæ—¶è°ƒç”¨getRandomï¼ˆé¢˜ç›®ä¿è¯ä¸ä¼šå‡ºç°ï¼‰
- é›†åˆåªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶çš„åˆ é™¤æ“ä½œ

### ğŸ’¥ æ˜“é”™ç‚¹ï¼š
- åˆ é™¤å…ƒç´ åå¿˜è®°æ›´æ–°äº¤æ¢å…ƒç´ åœ¨å“ˆå¸Œè¡¨ä¸­çš„ç´¢å¼•
- å†…å­˜é‡Šæ”¾ä¸å®Œæ•´ï¼Œå¿˜è®°é‡Šæ”¾å“ˆå¸Œè¡¨èŠ‚ç‚¹
- getRandomå®ç°ä¸­éšæœºæ•°èŒƒå›´é”™è¯¯ï¼Œåº”ä¸º[0, numsSize)

## 7ï¸âƒ£ æƒ‘ä¹‹æœªè§£

è¿™æ˜¯åŠ›æ‰£é‡Œé¢çš„æœ€ä¼˜è§£ï¼Ÿä½†æ˜¯æˆ‘çœ‹ä¸æ‡‚~ğŸ˜‚

æˆ‘ç°åœ¨æ‰“ç®—å…ˆç†è§£çµç ç»™å‡ºçš„ä»£ç å§ï¼Œä¹‹åå†æ¥æ¢ç´¢ä¸‹é¢çš„å†…å®¹ï¼ğŸ§
```c 
/**
 * FNVå“ˆå¸Œç®—æ³•å¸¸é‡å®šä¹‰
 * FNV32_BASE: FNV-1å“ˆå¸Œç®—æ³•çš„åŸºç¡€å€¼
 * FNV32_PRIME: FNV-1å“ˆå¸Œç®—æ³•çš„ç´ æ•°
 */
#define FNV32_BASE ((unsigned int) 0x811c9dc5)
#define FNV32_PRIME ((unsigned int) 0x01000193)

/**
 * FNV-1å“ˆå¸Œç®—æ³•å®ç°
 * @param buf è¦å“ˆå¸Œçš„æ•°æ®ç¼“å†²åŒº
 * @param len æ•°æ®é•¿åº¦
 * @return è®¡ç®—å¾—åˆ°çš„å“ˆå¸Œå€¼
 */
static unsigned int memhash(const void *buf, size_t len)
{
	unsigned int hash = FNV32_BASE;
	unsigned char *ucbuf = (unsigned char *) buf;
	while (len--) {
		unsigned int c = *ucbuf++;
		hash = (hash * FNV32_PRIME) ^ c;
	}
	return hash;
}

/**
 * å“ˆå¸Œè¡¨é¡¹ç»“æ„ä½“
 * ç”¨äºé“¾å¼è§£å†³å“ˆå¸Œå†²çª
 */
struct hashmap_entry {
    unsigned int hash;                  // å­˜å‚¨é¢„è®¡ç®—çš„å“ˆå¸Œå€¼
    struct hashmap_entry *next;         // æŒ‡å‘ä¸‹ä¸€ä¸ªå†²çªé¡¹çš„æŒ‡é’ˆ
};

/**
 * åˆå§‹åŒ–å“ˆå¸Œè¡¨é¡¹
 * @param entry è¦åˆå§‹åŒ–çš„å“ˆå¸Œè¡¨é¡¹
 * @param hash  é¢„è®¡ç®—çš„å“ˆå¸Œå€¼
 */
static inline void hashmap_entry_init(struct hashmap_entry *entry, unsigned int hash) {
    entry->hash = hash;
    entry->next = NULL;
}

/**
 * æ ¹æ®é”®å€¼è®¡ç®—å“ˆå¸Œå€¼å¹¶åˆå§‹åŒ–å“ˆå¸Œè¡¨é¡¹
 */
#define __hashmap_entry_init(entry, key, len) hashmap_entry_init(entry, memhash(key, len))

/**
 * å“ˆå¸Œè¡¨é¡¹æ¯”è¾ƒå›è°ƒå‡½æ•°ç±»å‹å®šä¹‰
 * @param entry     å“ˆå¸Œè¡¨ä¸­çš„é¡¹
 * @param key       è¦æ¯”è¾ƒçš„é”®
 * @param key_data  é”®æ•°æ®
 * @return ç›¸ç­‰è¿”å›0ï¼Œä¸ç›¸ç­‰è¿”å›é0å€¼
 */
typedef int (*hashmap_entry_cmp_callback)(struct hashmap_entry *entry, struct hashmap_entry *key, void *key_data);

/**
 * å“ˆå¸Œè¡¨ç»“æ„ä½“
 */
struct hashmap {
    struct hashmap_entry **table;       // å“ˆå¸Œæ¡¶æ•°ç»„
    unsigned int table_size;            // å“ˆå¸Œæ¡¶æ•°ç»„å¤§å°
    unsigned int private_size;          // å½“å‰å­˜å‚¨çš„å…ƒç´ æ•°é‡
    hashmap_entry_cmp_callback cmp;     // å…ƒç´ æ¯”è¾ƒå›è°ƒå‡½æ•°
    unsigned int grow_at;               // è§¦å‘æ‰©å®¹çš„é˜ˆå€¼
    unsigned int shrink_at;             // è§¦å‘æ”¶ç¼©çš„é˜ˆå€¼
};

/**
 * å“ˆå¸Œè¡¨é…ç½®å¸¸é‡
 * hashmap_init_size: åˆå§‹å“ˆå¸Œè¡¨å¤§å°
 * hashmap_factor: è´Ÿè½½å› å­(ç™¾åˆ†æ¯”)
 * hashmap_resize_bit: æ‰©å®¹/æ”¶ç¼©æ—¶çš„ä½ç§»é‡
 */
#define hashmap_init_size 64
#define hashmap_factor 80
#define hashmap_resize_bit 2

/**
 * åˆ†é…å“ˆå¸Œè¡¨æ¡¶æ•°ç»„
 * @param map  å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param size æ¡¶æ•°ç»„å¤§å°
 */
static void alloc_table(struct hashmap *map, unsigned int size) 
{
        map->table_size = size;
        map->table = calloc(size, sizeof(void *));  // åˆå§‹åŒ–ä¸ºNULL

        // è®¡ç®—æ‰©å®¹å’Œæ”¶ç¼©é˜ˆå€¼
        map->grow_at = size * hashmap_factor / 100;
        if (size <= hashmap_init_size) 
            map->shrink_at = 0;
        else 
            map->shrink_at = map->grow_at / ((1 << hashmap_resize_bit) + 1); 
}

/**
 * æ¯”è¾ƒä¸¤ä¸ªå“ˆå¸Œè¡¨é¡¹æ˜¯å¦ç›¸ç­‰
 * @param map       å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param entry     å“ˆå¸Œè¡¨ä¸­çš„é¡¹
 * @param key       è¦æ¯”è¾ƒçš„é”®
 * @param key_data  é”®æ•°æ®
 * @return ç›¸ç­‰è¿”å›trueï¼Œå¦åˆ™è¿”å›false
 */
static inline int entry_equals(struct hashmap *map, struct hashmap_entry *entry, struct hashmap_entry *key, void *key_data) 
{
    return ((entry->hash == key->hash) && (entry == key || !map->cmp(entry, key, key_data))); 
}

/**
 * åˆå§‹åŒ–å“ˆå¸Œè¡¨
 * @param map        å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param init_size  åˆå§‹å¤§å°
 * @param cmp        æ¯”è¾ƒå›è°ƒå‡½æ•°
 */
static void hashmap_init(struct hashmap *map, unsigned int init_size, hashmap_entry_cmp_callback cmp) 
{
    
    unsigned int size = hashmap_init_size;

    map->cmp = cmp;

    // æ ¹æ®åˆå§‹å¤§å°è®¡ç®—åˆé€‚çš„å“ˆå¸Œè¡¨å¤§å°
    init_size = init_size * 100 / hashmap_factor;
    while (init_size > size) {
        size <<= hashmap_resize_bit;
    }

    alloc_table(map, size);
    map->private_size = 0;
}

/**
 * è®¡ç®—å“ˆå¸Œæ¡¶ç´¢å¼•
 * @param map å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param key é”®é¡¹
 * @return æ¡¶ç´¢å¼•
 */
static inline unsigned int bucket(struct hashmap *map, struct hashmap_entry *key) 
{
    return key->hash & (map->table_size - 1);
}

/**
 * æŸ¥æ‰¾é”®é¡¹åœ¨å“ˆå¸Œè¡¨ä¸­çš„ä½ç½®æŒ‡é’ˆ
 * @param map       å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param key       è¦æŸ¥æ‰¾çš„é”®
 * @param key_data  é”®æ•°æ®
 * @return æŒ‡å‘è¯¥é¡¹æŒ‡é’ˆçš„æŒ‡é’ˆ
 */
static struct hashmap_entry **find_entry_ptr(struct hashmap *map, struct hashmap_entry *key, void *key_data) 
{
    unsigned int b = bucket(map, key);

    struct hashmap_entry **entry = &map->table[b];
    while (*entry && !entry_equals(map, *entry, key, key_data)) {
        entry = &(*entry)->next;
    }

    return entry;
}

/**
 * é‡æ–°å“ˆå¸Œï¼ˆæ‰©å®¹æˆ–æ”¶ç¼©ï¼‰
 * @param map      å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param new_size æ–°çš„å“ˆå¸Œè¡¨å¤§å°
 */
static void rehash(struct hashmap *map, unsigned int new_size)
{
    int i, old_size = map->table_size;
    struct hashmap_entry **old_table = map->table;

    alloc_table(map, new_size);

    // å°†æ—§è¡¨ä¸­çš„æ‰€æœ‰é¡¹é‡æ–°æ’å…¥æ–°è¡¨
    for (i = 0; i < old_size; i++) {
        struct hashmap_entry *e = old_table[i];

        while (e) {
            struct hashmap_entry *next = e->next;
            unsigned int b = bucket(map, e);
            e->next = map->table[b];
            map->table[b] = e;
            e = next;
        }
    }
    free(old_table);
}

/**
 * ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤é¡¹
 * @param map       å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param key       è¦ç§»é™¤çš„é”®
 * @param key_data  é”®æ•°æ®
 * @return è¢«ç§»é™¤çš„é¡¹ï¼Œä¸å­˜åœ¨åˆ™è¿”å›NULL
 */
static struct hashmap_entry *hashmap_remove(struct hashmap *map, struct hashmap_entry *key, void *key_data) 
{
    struct hashmap_entry **e;
    struct hashmap_entry *old;

    e = find_entry_ptr(map, key, key_data);
    if (!*e) return NULL;

    old = *e;
    *e = old->next;
    old->next = NULL;

    // å¦‚æœå…ƒç´ æ•°é‡ä½äºæ”¶ç¼©é˜ˆå€¼ï¼Œåˆ™è¿›è¡Œæ”¶ç¼©
    if (--map->private_size < map->shrink_at)
        rehash(map, map->table_size >> hashmap_resize_bit);
    
    return old;
}

/**
 * æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨äºå“ˆå¸Œè¡¨ä¸­
 * @param map       å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param key       è¦æ£€æŸ¥çš„é”®
 * @param key_data  é”®æ•°æ®
 * @return å­˜åœ¨è¿”å›trueï¼Œå¦åˆ™è¿”å›false
 */
static bool hashmap_exists(struct hashmap *map, struct hashmap_entry *key, void *key_data) {
    struct hashmap_entry **e = find_entry_ptr(map, key, key_data);
    if (!*e) return false;
    
    return true;
}

/**
 * å‘å“ˆå¸Œè¡¨ä¸­æ·»åŠ é¡¹
 * @param map    å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param entry  è¦æ·»åŠ çš„é¡¹
 */
static void hashmap_add(struct hashmap *map, struct hashmap_entry *entry) 
{
    unsigned int b = bucket(map, entry);

    entry->next = map->table[b];
    map->table[b] = entry;
    
    // å¦‚æœå…ƒç´ æ•°é‡è¶…è¿‡æ‰©å®¹é˜ˆå€¼ï¼Œåˆ™è¿›è¡Œæ‰©å®¹
    if (++map->private_size > map->grow_at)
        rehash(map, map->table_size << hashmap_resize_bit);
}

/**
 * å‘å“ˆå¸Œè¡¨ä¸­æ”¾ç½®é¡¹ï¼ˆå¦‚æœå·²å­˜åœ¨åˆ™æ›¿æ¢ï¼‰
 * @param map    å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param entry  è¦æ”¾ç½®çš„é¡¹
 * @return è¢«æ›¿æ¢çš„æ—§é¡¹ï¼Œæ²¡æœ‰åˆ™è¿”å›NULL
 */
static struct hashmap_entry *hashmap_put(struct hashmap *map, struct hashmap_entry *entry) {
    struct hashmap_entry *old = hashmap_remove(map, entry, NULL);
    hashmap_add(map, entry);
    return old;
}

/**
 * å“ˆå¸Œè¡¨è¿­ä»£å™¨ç»“æ„ä½“
 */
struct hashmap_iter {
    struct hashmap *map;        // å…³è”çš„å“ˆå¸Œè¡¨
    struct hashmap_entry *next; // ä¸‹ä¸€ä¸ªè¦è®¿é—®çš„é¡¹
    int table_pos;              // å½“å‰æ¡¶ç´¢å¼•
};

/**
 * åˆå§‹åŒ–å“ˆå¸Œè¡¨è¿­ä»£å™¨
 * @param iter è¿­ä»£å™¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param map  è¦è¿­ä»£çš„å“ˆå¸Œè¡¨
 */
static void hashmap_iter_init(struct hashmap_iter *iter, struct hashmap *map)
{
    iter->map = map;
    iter->next = NULL;
    iter->table_pos = 0;
}

/**
 * è·å–è¿­ä»£å™¨çš„ä¸‹ä¸€ä¸ªé¡¹
 * @param iter è¿­ä»£å™¨ç»“æ„ä½“æŒ‡é’ˆ
 * @return ä¸‹ä¸€ä¸ªå“ˆå¸Œè¡¨é¡¹ï¼Œæ²¡æœ‰åˆ™è¿”å›NULL
 */
static struct hashmap_entry *hashmap_iter_next(struct hashmap_iter *iter) {
    struct hashmap_entry *curr = iter->next;

    for ( ; ; ) {
        if (curr) {
            iter->next = curr->next;
            return curr;
        }

        if (iter->table_pos >= iter->map->table_size)
            return NULL;
        
        curr = iter->map->table[iter->table_pos++];
    }
} 

/**
 * æ¸…ç©ºå“ˆå¸Œè¡¨å¹¶é‡Šæ”¾æ‰€æœ‰å†…å­˜
 * @param map    å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param offset é¡¹ç»“æ„ä½“ä¸­hashmap_entryæˆå‘˜çš„åç§»é‡
 */
static void hashmap_clear(struct hashmap *map, unsigned int offset) {
    
    struct hashmap_iter iter;
    struct hashmap_entry *e;

    hashmap_iter_init(&iter, map);

    // é€ä¸ªé‡Šæ”¾æ‰€æœ‰é¡¹çš„å†…å­˜
    while ((e = hashmap_iter_next(&iter)))
        free((char *)e - offset);

    free(map->table);
    memset(map, 0, sizeof(struct hashmap));
}   

/**
 * æ•´å‹é”®å€¼çš„å“ˆå¸Œè¡¨é¡¹ç»“æ„ä½“
 */
struct int_hashmap_entry {
    int key;                    // é”®
    int value;                  // å€¼
    struct hashmap_entry entry; // åŸºç¡€å“ˆå¸Œè¡¨é¡¹
};

/**
 * è®¡ç®—int_hashmap_entryä¸­entryæˆå‘˜çš„åç§»é‡
 */
#define INT_HASHMAP_OFFSET offsetof(struct int_hashmap_entry, entry) 

/**
 * é€šè¿‡å“ˆå¸Œè¡¨é¡¹æŒ‡é’ˆè·å–åŒ…å«å®ƒçš„int_hashmap_entryæŒ‡é’ˆ
 */
#define get_int_hashmap_entry_data(entry, type, member) \
    ((type *) ((u_char *)(entry) - offsetof(type, member)))

/**
 * åˆ›å»ºæ•´å‹å“ˆå¸Œè¡¨é¡¹
 * @param key   é”®
 * @param value å€¼
 * @return æ–°åˆ›å»ºçš„é¡¹ï¼Œå¤±è´¥è¿”å›NULL
 */
static inline struct int_hashmap_entry *int_hashmap_entry_create(int key, int value) {
    struct int_hashmap_entry *int_entry;

    int_entry = malloc(sizeof(struct int_hashmap_entry));
    if (!int_entry) return NULL;

    int_entry->key = key;
    int_entry->value = value;
    __hashmap_entry_init(&int_entry->entry, &key, sizeof(int));
    return int_entry;
}

/**
 * æ•´å‹å“ˆå¸Œè¡¨ç»“æ„ä½“
 */
struct int_hashmap {
    struct hashmap map;  // åŸºç¡€å“ˆå¸Œè¡¨
};

/**
 * æ•´å‹å“ˆå¸Œè¡¨é¡¹æ¯”è¾ƒå‡½æ•°
 * @param entry     å“ˆå¸Œè¡¨ä¸­çš„é¡¹
 * @param key       è¦æ¯”è¾ƒçš„é”®
 * @param key_data  é”®æ•°æ®
 * @return ç›¸ç­‰è¿”å›0ï¼Œä¸ç›¸ç­‰è¿”å›é0å€¼
 */
static int int_hashmap_entry_cmp(struct hashmap_entry *entry, struct hashmap_entry *key, void *key_data) {
    struct int_hashmap_entry *int_entry = get_int_hashmap_entry_data(entry, struct int_hashmap_entry, entry);

    if (key_data) {
        if (int_entry->key == (*(int *) key_data)) return 0;
        else return 1;
    } else {
        struct int_hashmap_entry *key_entry = get_int_hashmap_entry_data(key, struct int_hashmap_entry, entry);
        if (int_entry->key == key_entry->key) return 0;
        return 1;
    }
}

/**
 * åˆå§‹åŒ–æ•´å‹å“ˆå¸Œè¡¨
 * @param int_map   æ•´å‹å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param init_size åˆå§‹å¤§å°
 */
static inline void int_hashmap_init(struct int_hashmap *int_map, unsigned int init_size)
{
    hashmap_init(&int_map->map, init_size, int_hashmap_entry_cmp);
}

/**
 * ä»æ•´å‹å“ˆå¸Œè¡¨ä¸­ç§»é™¤é¡¹
 * @param int_map æ•´å‹å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param key     è¦ç§»é™¤çš„é”®
 * @return è¢«ç§»é™¤çš„é¡¹ï¼Œä¸å­˜åœ¨åˆ™è¿”å›NULL
 */
static inline struct int_hashmap_entry *int_hashmap_remove(struct int_hashmap *int_map, int key) {
    struct hashmap_entry key_entry;
    __hashmap_entry_init(&key_entry, &key, sizeof(int));

    struct hashmap_entry *e = hashmap_remove(&int_map->map, &key_entry, &key);
    if (!e) return NULL;

    struct int_hashmap_entry *data = get_int_hashmap_entry_data(e, struct int_hashmap_entry, entry);

    return data;
}

/**
 * å‘æ•´å‹å“ˆå¸Œè¡¨ä¸­æ”¾ç½®é¡¹
 * @param int_map æ•´å‹å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param key     é”®
 * @param value   å€¼
 * @return è¢«æ›¿æ¢çš„æ—§é¡¹ï¼Œæ²¡æœ‰åˆ™è¿”å›NULL
 */
static inline struct int_hashmap_entry *int_hashmap_put(struct int_hashmap *int_map, int key, int value) {
    struct hashmap_entry *e = hashmap_put(&int_map->map, &int_hashmap_entry_create(key, value)->entry);
    if (!e) return NULL;

    struct int_hashmap_entry *data = get_int_hashmap_entry_data(e, struct int_hashmap_entry, entry);
    return data;
}

/**
 * æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨äºæ•´å‹å“ˆå¸Œè¡¨ä¸­
 * @param int_map æ•´å‹å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param key     è¦æ£€æŸ¥çš„é”®
 * @return å­˜åœ¨è¿”å›trueï¼Œå¦åˆ™è¿”å›false
 */
static inline bool int_hashmap_exists(struct int_hashmap *int_map, int key) {
    struct hashmap_entry key_entry;
    __hashmap_entry_init(&key_entry, &key, sizeof(int));

    return hashmap_exists(&int_map->map, &key_entry, &key);
}

/**
 * å‘æ•´å‹å“ˆå¸Œè¡¨ä¸­æ·»åŠ é¡¹
 * @param int_map æ•´å‹å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 * @param key     é”®
 * @param value   å€¼
 */
static inline void int_hashmap_add(struct int_hashmap *int_map, int key, int value) {
    hashmap_add(&int_map->map, &int_hashmap_entry_create(key, value)->entry);
}

/**
 * æ¸…ç©ºæ•´å‹å“ˆå¸Œè¡¨å¹¶é‡Šæ”¾æ‰€æœ‰å†…å­˜
 * @param int_map æ•´å‹å“ˆå¸Œè¡¨ç»“æ„ä½“æŒ‡é’ˆ
 */
static inline void int_hashmap_clear(struct int_hashmap *int_map) {
    hashmap_clear(&int_map->map, INT_HASHMAP_OFFSET);
}

/**
 * RandomizedSetç»“æ„ä½“
 * ç»“åˆæ•°ç»„å’Œå“ˆå¸Œè¡¨å®ç°O(1)æ—¶é—´å¤æ‚åº¦çš„æ’å…¥ã€åˆ é™¤å’Œéšæœºè·å–
 */
typedef struct {
    int *nums;                  // å­˜å‚¨å®é™…å…ƒç´ çš„æ•°ç»„
    int alloc;                  // æ•°ç»„å·²åˆ†é…çš„ç©ºé—´å¤§å°
    int nr;                     // æ•°ç»„ä¸­å½“å‰å…ƒç´ çš„æ•°é‡
    struct int_hashmap map;     // æ•´å‹å“ˆå¸Œè¡¨ï¼Œå­˜å‚¨å…ƒç´ å€¼åˆ°æ•°ç»„ç´¢å¼•çš„æ˜ å°„
} RandomizedSet;

/**
 * é»˜è®¤æ•°ç»„åˆ†é…å¤§å°
 */
#define DEFAULT_ALLOC 1024

/**
 * åˆ›å»ºRandomizedSetå¯¹è±¡
 * @return æ–°åˆ›å»ºçš„RandomizedSetå¯¹è±¡æŒ‡é’ˆï¼Œå¤±è´¥è¿”å›NULL
 */
RandomizedSet *randomizedSetCreate() {
    RandomizedSet *rand_set;

    rand_set = malloc(sizeof(RandomizedSet));
    if (!rand_set) return NULL;

    rand_set->nums = calloc(DEFAULT_ALLOC, sizeof(int));
    if (!rand_set->nums) {
        free(rand_set);
        return NULL;
    }

    rand_set->alloc = DEFAULT_ALLOC;
    rand_set->nr = 0;
    int_hashmap_init(&rand_set->map, 1024);
    return rand_set;
}

/**
 * å‘é›†åˆä¸­æ’å…¥å…ƒç´ 
 * @param rand_set RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 * @param val      è¦æ’å…¥çš„å…ƒç´ å€¼
 * @return æ’å…¥æˆåŠŸè¿”å›trueï¼Œå…ƒç´ å·²å­˜åœ¨è¿”å›false
 */
bool randomizedSetInsert(RandomizedSet *rand_set, int val) {
    // æ£€æŸ¥å…ƒç´ æ˜¯å¦å·²å­˜åœ¨
    if (int_hashmap_exists(&rand_set->map, val)) return false;

    // å¦‚æœæ•°ç»„ç©ºé—´ä¸è¶³ï¼Œåˆ™æ‰©å®¹
    if (rand_set->nr >= rand_set->alloc) {
        int new_alloc = rand_set->alloc * 2;
        rand_set->nums = realloc(rand_set->nums, new_alloc * sizeof(int));
        if (!rand_set->nums) return false;
        rand_set->alloc = new_alloc;
    }

    // å°†æ–°å…ƒç´ æ·»åŠ åˆ°æ•°ç»„æœ«å°¾
    rand_set->nums[rand_set->nr] = val;
    // åœ¨å“ˆå¸Œè¡¨ä¸­è®°å½•å…ƒç´ å€¼å’Œå…¶åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•
    int_hashmap_add(&rand_set->map, val, rand_set->nr);
    rand_set->nr++;
    return true;
}

/**
 * ä»é›†åˆä¸­åˆ é™¤å…ƒç´ 
 * @param rand_set RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 * @param val      è¦åˆ é™¤çš„å…ƒç´ å€¼
 * @return åˆ é™¤æˆåŠŸè¿”å›trueï¼Œå…ƒç´ ä¸å­˜åœ¨è¿”å›false
 */
bool randomizedSetRemove(RandomizedSet *rand_set, int val) {
    // ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤å…ƒç´ å¹¶è·å–å…¶ä¿¡æ¯
    struct int_hashmap_entry *entry = int_hashmap_remove(&rand_set->map, val);
    if (!entry) return false;

    // è·å–è¦åˆ é™¤å…ƒç´ åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•
    int index = entry->value;
    // è·å–æ•°ç»„ä¸­æœ€åä¸€ä¸ªå…ƒç´ çš„å€¼
    int last_val = rand_set->nums[--rand_set->nr];
    // å°†æœ€åä¸€ä¸ªå…ƒç´ ç§»åŠ¨åˆ°è¦åˆ é™¤å…ƒç´ çš„ä½ç½®
    rand_set->nums[index] = last_val;

    // å¦‚æœåˆ é™¤çš„ä¸æ˜¯æœ€åä¸€ä¸ªå…ƒç´ ï¼Œéœ€è¦æ›´æ–°æœ€åä¸€ä¸ªå…ƒç´ åœ¨å“ˆå¸Œè¡¨ä¸­çš„ç´¢å¼•
    if (index != rand_set->nr) {
        struct int_hashmap_entry *last_entry = int_hashmap_remove(&rand_set->map, last_val);
        last_entry->value = index;
        hashmap_add(&rand_set->map.map, &last_entry->entry);
    }

    free(entry);  // é‡Šæ”¾è¢«åˆ é™¤é¡¹çš„å†…å­˜
    return true;
}

/**
 * éšæœºè·å–é›†åˆä¸­çš„ä¸€ä¸ªå…ƒç´ 
 * @param rand_set RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 * @return éšæœºè¿”å›çš„å…ƒç´ å€¼
 */
int randomizedSetGetRandom(RandomizedSet *rand_set) {
    // ä½¿ç”¨éšæœºæ•°ç”Ÿæˆ0åˆ°nr-1ä¹‹é—´çš„ç´¢å¼•
    return rand_set->nums[rand() % rand_set->nr];
}

/**
 * é‡Šæ”¾RandomizedSetå¯¹è±¡å ç”¨çš„å†…å­˜
 * @param rand_set RandomizedSetå¯¹è±¡æŒ‡é’ˆ
 */
void randomizedSetFree(RandomizedSet *rand_set) {
    if (rand_set->nums)
        free(rand_set->nums);
    int_hashmap_clear(&rand_set->map);

    free(rand_set);
}

/**
 * Your RandomizedSet struct will be instantiated and called as such:
 * RandomizedSet* obj = randomizedSetCreate();
 * bool param_1 = randomizedSetInsert(obj, val);
 
 * bool param_2 = randomizedSetRemove(obj, val);
 
 * int param_3 = randomizedSetGetRandom(obj);
 
 * randomizedSetFree(obj);
*/
```
</details>

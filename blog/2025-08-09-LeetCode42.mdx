---
slug: LeetCode42
title: 接雨水
authors: eurekaX
tags: [数组]
---
import { Highlight, Keyword, Light, B1, B2, B3, BH3, B3W, MyColor} from '@site/src/components/ForMDX';
import CardImg from '@site/src/components/CardImg';

### <B2>[力扣面试经典——42题](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-interview-150 "力扣")</B2>

<!-- truncate -->


### 💡 参考代码：

```c
/**
 * @brief 计算柱状图中能够接住的雨水总量
 * 
 * 使用双指针法解决接雨水问题。对于每个位置，能接住的雨水量取决于其左侧和右侧的最大高度中的较小值。
 * 通过维护两个指针和对应的左右侧最大高度，从两端向中间遍历，累计可接雨水量。
 * 
 * @param height 柱子高度数组，每个元素代表一个宽度为1的柱子的高度
 * @param heightSize 数组长度，表示柱子的数量
 * @return int 返回能够接住的雨水总量
 * 
 * @example
 * 输入: height = [0,1,0,2,1,0,1,3,2,1,2,1], heightSize = 12
 * 输出: 6
 * 
 * @example
 * 输入: height = [4,2,0,3,2,5], heightSize = 6
 * 输出: 9
 * 
 * @complexity
 * 时间复杂度: O(n) - 只需要遍历一次数组
 * 空间复杂度: O(1) - 只使用了常数级别的额外空间
 */
int trap(int* height, int heightSize) {
    // 柱子数量少于3个时无法接住雨水
    if (heightSize <= 2) return 0;
    
    int left = 0;           // 左指针，从数组起始位置开始
    int right = heightSize - 1;  // 右指针，从数组末尾位置开始
    int leftMax = 0;        // 记录左侧遍历过程中的最大高度
    int rightMax = 0;       // 记录右侧遍历过程中的最大高度
    int result = 0;         // 累计接住的雨水总量
    
    // 双指针向中间移动，直到相遇
    while (left < right) {
        // 当左侧柱子高度小于右侧柱子高度时，处理左侧
        if (height[left] < height[right]) {
            // 如果当前柱子高度大于等于左侧最大高度，说明此位置接不到雨水
            if (height[left] >= leftMax) {
                leftMax = height[left];//更新左侧最大高度
            } else {
                // 否则可以接住雨水，累加到结果中
                result += leftMax - height[left];
            }
            left++;  // 左指针右移
        } else {
            // 当右侧柱子高度小于等于左侧柱子高度时，处理右侧
            // 如果当前柱子高度大于等于右侧最大高度，说明此位置接不到雨水
            if (height[right] >= rightMax) {
                rightMax = height[right];//更新右侧最大高度
            } else {
                // 否则可以接住雨水，累加到结果中
                result += rightMax - height[right];
            }
            right--; // 右指针左移
        }
    }
    
    return result;  // 返回接住的雨水总量
}
```

### 📖 总结：

<details>
<summary>点击展开题目总结</summary>
# 🤔 接雨水

---

## 1️⃣ 题目核心信息

🎯 **功能描述**：给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子下雨之后能接多少雨水。

📥 **输入输出**：
- **输入**：`height` - 柱子高度数组，每个元素代表一个宽度为1的柱子的高度；`heightSize` - 数组长度
- **输出**：返回能够接住的雨水总量（整数）

---

## 2️⃣ 实现原理

💡 **核心思路**：使用双指针法，从数组两端向中间遍历，通过维护左右两侧的最大高度来计算每个位置能够接住的雨水量。

📋 **实现步骤**：
1. 初始化左右指针分别指向数组首尾，同时维护左侧最大高度和右侧最大高度
2. 比较左右指针所指元素的大小，选择较小的一侧进行处理
3. 如果当前元素大于等于该侧最大高度，则更新最大高度
4. 如果当前元素小于该侧最大高度，则累加可接雨水量（最大高度减去当前高度）
5. 移动处理过的指针，重复步骤2-4直到左右指针相遇

---

## 3️⃣ 关键点解析

### 🎯 代码技巧
- 使用双指针从两端向中间逼近，减少空间复杂度
- 利用"短板效应"思想，总是处理较矮一侧的柱子
- 通过维护单侧最大值避免了预处理整个数组的需要
- 巧妙利用高度比较结果决定处理方向

## 4️⃣ 使用场景

### ✅ 适用情况：
- 需要计算地形中能够存储的水量
- 处理类似"容器盛水"的几何问题
- 需要在数组中寻找"凹陷"区域的累积值

### ⚠️ 前提条件：
- 输入数组元素为非负整数
- 数组长度至少为3才能接住雨水
- 每个柱子宽度固定为1

## 5️⃣ 复杂度分析

- ⏱️ 时间复杂度：O(n) - 只需要遍历一次数组，每个元素最多被访问一次

- 💾 空间复杂度：O(1) - 只使用了常数级别的额外空间，不依赖数组大小

## 6️⃣ 注意事项

### 🚩 边界情况：
- 数组长度小于3时无法接住雨水，直接返回0
- 数组为空或为NULL的情况
- 所有柱子高度相同的情况

### 💥 易错点：
- 混淆左右最大高度的更新条件，应该是大于等于时更新
- 忘记在处理完一个位置后移动指针
- 错误地在两侧高度相等时的处理逻辑
- 没有正确理解雨水量计算公式：min(leftMax, rightMax) - currentHeight

## 7️⃣ 补充解释

正确的理解方式
让我用一个简单的例子来说明：
```
索引:     0   1   2   3   4   5   6
高度:     2   0   1   0   0   1   3
          L           *           R
```		  
对于位置 * (索引3)，它的"两侧"是指：

- 左侧：`height[0]`, `height[1]`, `height[2]` 中的最大值 = max(2,0,1) = 2
- 右侧：`height[4]`, `height[5]`, `height[6]` 中的最大值 = max(0,1,3) = 3
所以位置3能接的雨水 = min(2,3) - 0 = 2

为什么比较`height[0]`和`height[11]`？

在双指针法中，我们比较 `height[left]` 和 `height[right]` 并不是为了计算这两个位置的雨水，而是为了确定处理方向。

这背后的逻辑是：

- 如果 `height[left]` < `height[right]`，那么我们可以确定左侧指针指向的位置的雨水量只由左侧最大值决定

- 这是因为右边有一个更高的墙，水面高度至少能达到左边的最大值

举个更直观的例子
```
索引:  0  1  2  3  4  5  6  7
高度:  3  0  0  0  0  0  0  5
       L                    R
```	   
当我们比较 height[0]=3 和 height[7]=5 时：

- 因为 3 < 5，所以我们处理左侧位置(索引0)
- 但索引0是边界，不能接雨水
- 然后 left++，继续处理索引1的位置
对于索引1的位置：

- 它左边的最大值是3
- 它右边的最大值是5(注意：是整个右边的最大值，不只是相邻的)
- 所以它能接的雨水 = min(3,5) - 0 = 3

### 总结

- "两侧"指的是当前位置左边所有柱子中的最大值和右边所有柱子中的最大值

- 比较 height[left] 和 height[right] 是为了决定处理策略，而不是计算这两个位置的雨水

- 这是一个巧妙的优化，避免了需要预计算每个位置左右两侧最大值的步骤

**有点懂了，但没完全懂⬇️**
<p><CardImg src="/img/Leetcode42.jpg" alt="例子" isCenter={true} isBoxed={true} /></p>

我理解的 `左侧`、`右侧` 这里的左右侧并不是指某个位置的左右侧，而是左右侧的指针（即上面定义的 left 和 right），比如刚开始时 `height[left] < height[right]` 的
话，表明此刻应该处理左侧指针指向的位置（而并非该位置的左侧）。如果该位置的值 height[left] = 2 ,leftMax = 1 ,即此刻该位置无法接到雨水，像下面这样：
```
      |⬅️//右侧这里相当有无形的“墙”，高度至少是 height[right]
    █ | //真正决定能够接多少雨水的是 leftMax
  █ █ | //此处 leftMax 过小，可见无法接到雨水，于是要更新 leftMax = height[left]
``` 
</details>
